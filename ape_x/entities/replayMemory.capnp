@0x95bed824078b511a;

interface ReplayMemory {
  struct Transition {
    # A transition from one observation to another

    id @0 :Text;                # uuid of the transition, generated by actors
    observation @1 :Data;       # blob
    nextObservation @2 :Data;   # blob
    action @3 :UInt8;           # discrete action of actor
    reward @4 :Float32;         # reward of actor
    done @5 :Bool;              # whether the episode is done
    priority @6 :Float32;       # initial estimate of the priority of the transition, generated by actors
  }

  addTransitionBatch @0 (transitions :List(Transition));      
  # Add a batch of transitions to the replay memory
  # Used by actors to store the transitions they generate
  # Initial priorities are calculated by actors

  sample @1 (batchSize: UInt32) -> (transitions :List(Transition));
  # Sample a batch of transitions from the replay memory
  # Used by the learner to sample transitions for training

  updatePriorities @2 (ids :List(Text), priorities :List(Float32));
  # Update the priorities of the transitions with the given ids
  # Used by the learner to update the priorities of transitions after training
  # on a batch of transitions

  deleteOldTransitions @3 (maxSize :UInt32);
  # Delete old transitions from the replay memory if the size exceeds maxSize
  # Used by the learner to softcap the replay memory size 
}