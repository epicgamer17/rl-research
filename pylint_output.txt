************* Module rl-research
__init__.py:1:0: C0103: Module name "rl-research" doesn't conform to snake_case naming style (invalid-name)
************* Module a2c_agent
A2C/a2c_agent.py:36:0: C0301: Line too long (128/100) (line-too-long)
A2C/a2c_agent.py:45:0: C0301: Line too long (105/100) (line-too-long)
A2C/a2c_agent.py:122:0: C0303: Trailing whitespace (trailing-whitespace)
A2C/a2c_agent.py:127:0: C0303: Trailing whitespace (trailing-whitespace)
A2C/a2c_agent.py:1:0: C0114: Missing module docstring (missing-module-docstring)
A2C/a2c_agent.py:2:0: E0401: Unable to import 'cv2' (import-error)
A2C/a2c_agent.py:3:0: E0401: Unable to import 'torch' (import-error)
A2C/a2c_agent.py:4:0: R0402: Use 'from torch import nn' instead (consider-using-from-import)
A2C/a2c_agent.py:4:0: E0401: Unable to import 'torch.nn' (import-error)
A2C/a2c_agent.py:17:0: E0401: Unable to import 'replay_buffers.a2c_replay_buffer' (import-error)
A2C/a2c_agent.py:17:0: C0413: Import "from replay_buffers.a2c_replay_buffer import A2CReplayBuffer" should be placed at the top of the module (wrong-import-position)
A2C/a2c_agent.py:18:0: C0413: Import "from a2c_network import A2CNetwork" should be placed at the top of the module (wrong-import-position)
A2C/a2c_agent.py:19:0: C0413: Import "import numpy as np" should be placed at the top of the module (wrong-import-position)
A2C/a2c_agent.py:20:0: E0401: Unable to import 'gymnasium' (import-error)
A2C/a2c_agent.py:20:0: C0413: Import "import gymnasium as gym" should be placed at the top of the module (wrong-import-position)
A2C/a2c_agent.py:21:0: E0611: No name 'A2CConfig' in module 'agent_configs' (no-name-in-module)
A2C/a2c_agent.py:21:0: C0413: Import "from agent_configs import A2CConfig" should be placed at the top of the module (wrong-import-position)
A2C/a2c_agent.py:22:0: E0401: Unable to import 'base_agent.agent' (import-error)
A2C/a2c_agent.py:22:0: C0413: Import "from base_agent.agent import BaseAgent" should be placed at the top of the module (wrong-import-position)
A2C/a2c_agent.py:23:0: E0401: Unable to import 'torch.optim' (import-error)
A2C/a2c_agent.py:23:0: C0413: Import "from torch.optim import Adam, SGD" should be placed at the top of the module (wrong-import-position)
A2C/a2c_agent.py:24:0: E0401: Unable to import 'torch.nn.utils' (import-error)
A2C/a2c_agent.py:24:0: C0413: Import "from torch.nn.utils import clip_grad_norm_" should be placed at the top of the module (wrong-import-position)
A2C/a2c_agent.py:27:0: C0115: Missing class docstring (missing-class-docstring)
A2C/a2c_agent.py:27:0: R0902: Too many instance attributes (9/7) (too-many-instance-attributes)
A2C/a2c_agent.py:28:4: R0913: Too many arguments (6/5) (too-many-arguments)
A2C/a2c_agent.py:45:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
A2C/a2c_agent.py:52:15: C0121: Comparison 'self.config.kernel_initializer == None' should be 'self.config.kernel_initializer is None' (singleton-comparison)
A2C/a2c_agent.py:123:4: C0116: Missing function or method docstring (missing-function-docstring)
A2C/a2c_agent.py:128:4: C0116: Missing function or method docstring (missing-function-docstring)
A2C/a2c_agent.py:132:4: W0102: Dangerous default value {} as argument (dangerous-default-value)
A2C/a2c_agent.py:132:4: C0116: Missing function or method docstring (missing-function-docstring)
A2C/a2c_agent.py:132:41: W0613: Unused argument 'info' (unused-argument)
A2C/a2c_agent.py:132:52: W0613: Unused argument 'actionmasking' (unused-argument)
A2C/a2c_agent.py:133:8: W0612: Unused variable 'policy' (unused-variable)
A2C/a2c_agent.py:133:30: W0612: Unused variable 'value' (unused-variable)
A2C/a2c_agent.py:132:4: R0201: Method could be a function (no-self-use)
A2C/a2c_agent.py:138:4: C0116: Missing function or method docstring (missing-function-docstring)
A2C/a2c_agent.py:162:4: C0116: Missing function or method docstring (missing-function-docstring)
A2C/a2c_agent.py:168:4: C0116: Missing function or method docstring (missing-function-docstring)
A2C/a2c_agent.py:182:4: C0116: Missing function or method docstring (missing-function-docstring)
A2C/a2c_agent.py:186:8: C0200: Consider using enumerate instead of iterating with range and len (consider-using-enumerate)
A2C/a2c_agent.py:203:4: C0116: Missing function or method docstring (missing-function-docstring)
A2C/a2c_agent.py:206:8: C0200: Consider using enumerate instead of iterating with range and len (consider-using-enumerate)
A2C/a2c_agent.py:217:4: C0116: Missing function or method docstring (missing-function-docstring)
A2C/a2c_agent.py:217:4: R0914: Too many local variables (17/15) (too-many-locals)
A2C/a2c_agent.py:220:11: E1101: Instance of 'A2CAgent' has no 'training_step' member (no-member)
A2C/a2c_agent.py:224:15: E1101: Instance of 'A2CAgent' has no 'training_step' member (no-member)
A2C/a2c_agent.py:260:15: E1101: Instance of 'A2CAgent' has no 'training_step' member (no-member)
A2C/a2c_agent.py:263:12: E1101: Instance of 'A2CAgent' has no 'training_step' member (no-member)
A2C/a2c_agent.py:266:39: E1101: Instance of 'A2CAgent' has no 'training_step' member (no-member)
A2C/a2c_agent.py:219:30: E0203: Access to member 'training_time' before its definition line 261 (access-member-before-definition)
A2C/a2c_agent.py:223:14: E0203: Access to member 'training_time' before its definition line 261 (access-member-before-definition)
A2C/a2c_agent.py:262:16: E0203: Access to member 'total_environment_steps' before its definition line 266 (access-member-before-definition)
A2C/a2c_agent.py:261:16: W0201: Attribute 'training_time' defined outside __init__ (attribute-defined-outside-init)
A2C/a2c_agent.py:265:8: W0201: Attribute 'training_time' defined outside __init__ (attribute-defined-outside-init)
A2C/a2c_agent.py:266:8: W0201: Attribute 'total_environment_steps' defined outside __init__ (attribute-defined-outside-init)
A2C/a2c_agent.py:1:0: W0611: Unused import dis (unused-import)
A2C/a2c_agent.py:2:0: W0611: Unused log imported from cv2 (unused-import)
A2C/a2c_agent.py:4:0: W0611: Unused torch.nn imported as nn (unused-import)
A2C/a2c_agent.py:19:0: W0611: Unused numpy imported as np (unused-import)
A2C/a2c_agent.py:20:0: W0611: Unused gymnasium imported as gym (unused-import)
A2C/a2c_agent.py:12:0: C0411: standard import "import sys" should be placed before "from cv2 import log" (wrong-import-order)
A2C/a2c_agent.py:13:0: C0411: standard import "from time import time" should be placed before "from cv2 import log" (wrong-import-order)
A2C/a2c_agent.py:18:0: C0411: third party import "from a2c_network import A2CNetwork" should be placed before "from replay_buffers.a2c_replay_buffer import A2CReplayBuffer" (wrong-import-order)
A2C/a2c_agent.py:19:0: C0411: third party import "import numpy as np" should be placed before "from replay_buffers.a2c_replay_buffer import A2CReplayBuffer" (wrong-import-order)
A2C/a2c_agent.py:20:0: C0411: third party import "import gymnasium as gym" should be placed before "from replay_buffers.a2c_replay_buffer import A2CReplayBuffer" (wrong-import-order)
A2C/a2c_agent.py:21:0: C0411: third party import "from agent_configs import A2CConfig" should be placed before "from replay_buffers.a2c_replay_buffer import A2CReplayBuffer" (wrong-import-order)
A2C/a2c_agent.py:23:0: C0411: third party import "from torch.optim import Adam, SGD" should be placed before "from replay_buffers.a2c_replay_buffer import A2CReplayBuffer" (wrong-import-order)
A2C/a2c_agent.py:24:0: C0411: third party import "from torch.nn.utils import clip_grad_norm_" should be placed before "from replay_buffers.a2c_replay_buffer import A2CReplayBuffer" (wrong-import-order)
************* Module a2c_network
A2C/a2c_network.py:42:17: C0303: Trailing whitespace (trailing-whitespace)
A2C/a2c_network.py:43:30: C0303: Trailing whitespace (trailing-whitespace)
A2C/a2c_network.py:44:36: C0303: Trailing whitespace (trailing-whitespace)
A2C/a2c_network.py:45:18: C0303: Trailing whitespace (trailing-whitespace)
A2C/a2c_network.py:1:0: C0114: Missing module docstring (missing-module-docstring)
A2C/a2c_network.py:1:0: R0402: Use 'from torch import nn' instead (consider-using-from-import)
A2C/a2c_network.py:1:0: E0401: Unable to import 'torch.nn' (import-error)
A2C/a2c_network.py:2:0: E0401: Unable to import 'torch' (import-error)
A2C/a2c_network.py:5:0: E0611: No name 'a2c_config' in module 'agent_configs' (no-name-in-module)
A2C/a2c_network.py:5:0: E0401: Unable to import 'agent_configs.a2c_config' (import-error)
A2C/a2c_network.py:6:0: E0401: Unable to import 'torch' (import-error)
A2C/a2c_network.py:8:0: E0401: Unable to import 'modules.conv' (import-error)
A2C/a2c_network.py:9:0: E0401: Unable to import 'modules.dense' (import-error)
A2C/a2c_network.py:10:0: W0404: Reimport 'torch.nn' (imported line 1) (reimported)
A2C/a2c_network.py:10:0: R0402: Use 'from torch import nn' instead (consider-using-from-import)
A2C/a2c_network.py:10:0: E0401: Unable to import 'torch.nn' (import-error)
A2C/a2c_network.py:26:12: C0103: Attribute name "mainStream" doesn't conform to snake_case naming style (invalid-name)
A2C/a2c_network.py:13:0: C0115: Missing class docstring (missing-class-docstring)
A2C/a2c_network.py:22:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
A2C/a2c_network.py:32:4: C0116: Missing function or method docstring (missing-function-docstring)
A2C/a2c_network.py:36:4: C0116: Missing function or method docstring (missing-function-docstring)
A2C/a2c_network.py:40:0: C0115: Missing class docstring (missing-class-docstring)
A2C/a2c_network.py:54:8: C0103: Variable name "B" doesn't conform to snake_case naming style (invalid-name)
A2C/a2c_network.py:106:4: C0116: Missing function or method docstring (missing-function-docstring)
A2C/a2c_network.py:113:4: C0116: Missing function or method docstring (missing-function-docstring)
A2C/a2c_network.py:117:8: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
A2C/a2c_network.py:119:12: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
A2C/a2c_network.py:121:12: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
A2C/a2c_network.py:125:4: C0116: Missing function or method docstring (missing-function-docstring)
A2C/a2c_network.py:133:0: C0115: Missing class docstring (missing-class-docstring)
A2C/a2c_network.py:133:0: R0902: Too many instance attributes (9/7) (too-many-instance-attributes)
A2C/a2c_network.py:150:8: C0103: Variable name "B" doesn't conform to snake_case naming style (invalid-name)
A2C/a2c_network.py:177:19: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
A2C/a2c_network.py:217:4: C0116: Missing function or method docstring (missing-function-docstring)
A2C/a2c_network.py:230:4: C0116: Missing function or method docstring (missing-function-docstring)
A2C/a2c_network.py:234:8: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
A2C/a2c_network.py:236:12: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
A2C/a2c_network.py:238:12: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
A2C/a2c_network.py:239:8: R1705: Unnecessary "else" after "return" (no-else-return)
A2C/a2c_network.py:247:4: C0116: Missing function or method docstring (missing-function-docstring)
A2C/a2c_network.py:259:0: C0115: Missing class docstring (missing-class-docstring)
A2C/a2c_network.py:274:8: C0103: Variable name "B" doesn't conform to snake_case naming style (invalid-name)
A2C/a2c_network.py:301:19: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
A2C/a2c_network.py:264:12: W0613: Unused argument 'output_size' (unused-argument)
A2C/a2c_network.py:323:4: C0116: Missing function or method docstring (missing-function-docstring)
A2C/a2c_network.py:259:0: R0903: Too few public methods (1/2) (too-few-public-methods)
A2C/a2c_network.py:2:0: W0611: Unused import torch (unused-import)
A2C/a2c_network.py:3:0: W0611: Unused import time (unused-import)
A2C/a2c_network.py:3:0: C0411: standard import "import time" should be placed before "import torch.nn as nn" (wrong-import-order)
A2C/a2c_network.py:4:0: C0411: standard import "from typing import Callable, Tuple" should be placed before "import torch.nn as nn" (wrong-import-order)
A2C/a2c_network.py:10:0: C0411: third party import "import torch.nn as nn" should be placed before "from modules.conv import Conv2dStack" (wrong-import-order)
A2C/a2c_network.py:10:0: C0412: Imports from package torch are not grouped (ungrouped-imports)
************* Module test
A2C/test.py:8:0: C0304: Final newline missing (missing-final-newline)
A2C/test.py:1:0: C0114: Missing module docstring (missing-module-docstring)
A2C/test.py:1:0: E0401: Unable to import 'gymnasium' (import-error)
A2C/test.py:2:0: E0401: Unable to import 'torch' (import-error)
A2C/test.py:1:0: W0611: Unused gymnasium imported as gym (unused-import)
A2C/test.py:3:0: W0611: Unused import numpy (unused-import)
************* Module rl-research.alphazero.alphazero_agent
alphazero/alphazero_agent.py:40:0: C0301: Line too long (128/100) (line-too-long)
alphazero/alphazero_agent.py:49:0: C0301: Line too long (111/100) (line-too-long)
alphazero/alphazero_agent.py:97:0: C0303: Trailing whitespace (trailing-whitespace)
alphazero/alphazero_agent.py:268:61: C0303: Trailing whitespace (trailing-whitespace)
alphazero/alphazero_agent.py:282:101: C0303: Trailing whitespace (trailing-whitespace)
alphazero/alphazero_agent.py:282:0: C0301: Line too long (101/100) (line-too-long)
alphazero/alphazero_agent.py:283:109: C0303: Trailing whitespace (trailing-whitespace)
alphazero/alphazero_agent.py:283:0: C0301: Line too long (109/100) (line-too-long)
alphazero/alphazero_agent.py:1:0: C0114: Missing module docstring (missing-module-docstring)
alphazero/alphazero_agent.py:5:0: E0611: No name 'AlphaZeroConfig' in module 'agent_configs' (no-name-in-module)
alphazero/alphazero_agent.py:6:0: E0401: Unable to import 'torch' (import-error)
alphazero/alphazero_agent.py:7:0: E0611: No name 'clip_low_prob_actions' in module 'utils' (no-name-in-module)
alphazero/alphazero_agent.py:7:0: E0611: No name 'normalize_policies' in module 'utils' (no-name-in-module)
alphazero/alphazero_agent.py:7:0: E0611: No name 'action_mask' in module 'utils' (no-name-in-module)
alphazero/alphazero_agent.py:7:0: E0611: No name 'get_legal_moves' in module 'utils' (no-name-in-module)
alphazero/alphazero_agent.py:7:0: E0611: No name 'CategoricalCrossentropyLoss' in module 'utils' (no-name-in-module)
alphazero/alphazero_agent.py:7:0: E0611: No name 'MSELoss' in module 'utils' (no-name-in-module)
alphazero/alphazero_agent.py:15:0: E0401: Unable to import 'torch.optim.sgd' (import-error)
alphazero/alphazero_agent.py:16:0: E0401: Unable to import 'torch.optim.adam' (import-error)
alphazero/alphazero_agent.py:21:0: E0401: Unable to import 'base_agent.agent' (import-error)
alphazero/alphazero_agent.py:21:0: C0413: Import "from base_agent.agent import BaseAgent" should be placed at the top of the module (wrong-import-position)
alphazero/alphazero_agent.py:23:0: C0413: Import "import copy" should be placed at the top of the module (wrong-import-position)
alphazero/alphazero_agent.py:24:0: C0413: Import "import numpy as np" should be placed at the top of the module (wrong-import-position)
alphazero/alphazero_agent.py:25:0: E0401: Unable to import 'replay_buffers.alphazero_replay_buffer' (import-error)
alphazero/alphazero_agent.py:25:0: C0413: Import "from replay_buffers.alphazero_replay_buffer import AlphaZeroReplayBuffer, Game" should be placed at the top of the module (wrong-import-position)
alphazero/alphazero_agent.py:26:0: E0401: Unable to import 'alphazero.alphazero_mcts' (import-error)
alphazero/alphazero_agent.py:26:0: C0413: Import "from alphazero.alphazero_mcts import Node" should be placed at the top of the module (wrong-import-position)
alphazero/alphazero_agent.py:27:0: E0401: Unable to import 'alphazero.alphazero_network' (import-error)
alphazero/alphazero_agent.py:27:0: C0413: Import "from alphazero.alphazero_network import Network" should be placed at the top of the module (wrong-import-position)
alphazero/alphazero_agent.py:28:0: E0401: Unable to import 'torch.nn.utils' (import-error)
alphazero/alphazero_agent.py:28:0: C0413: Import "from torch.nn.utils import clip_grad_norm_" should be placed at the top of the module (wrong-import-position)
alphazero/alphazero_agent.py:31:0: C0115: Missing class docstring (missing-class-docstring)
alphazero/alphazero_agent.py:31:0: R0902: Too many instance attributes (8/7) (too-many-instance-attributes)
alphazero/alphazero_agent.py:32:4: R0913: Too many arguments (6/5) (too-many-arguments)
alphazero/alphazero_agent.py:49:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
alphazero/alphazero_agent.py:98:4: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/alphazero_agent.py:101:11: E1101: Instance of 'AlphaZeroAgent' has no 'training_step' member (no-member)
alphazero/alphazero_agent.py:104:14: E1101: Instance of 'AlphaZeroAgent' has no 'training_step' member (no-member)
alphazero/alphazero_agent.py:105:15: E1101: Instance of 'AlphaZeroAgent' has no 'training_step' member (no-member)
alphazero/alphazero_agent.py:110:16: E1101: Instance of 'AlphaZeroAgent' has no 'total_environment_steps' member (no-member)
alphazero/alphazero_agent.py:123:15: E1101: Instance of 'AlphaZeroAgent' has no 'training_step' member (no-member)
alphazero/alphazero_agent.py:123:70: E1101: Instance of 'AlphaZeroAgent' has no 'training_step' member (no-member)
alphazero/alphazero_agent.py:126:12: E1101: Instance of 'AlphaZeroAgent' has no 'training_step' member (no-member)
alphazero/alphazero_agent.py:114:16: W0612: Unused variable 'minibatch' (unused-variable)
alphazero/alphazero_agent.py:132:4: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/alphazero_agent.py:134:15: W0621: Redefining name 'policy' from outer scope (line 2) (redefined-outer-name)
alphazero/alphazero_agent.py:132:4: R0914: Too many local variables (17/15) (too-many-locals)
alphazero/alphazero_agent.py:196:4: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/alphazero_agent.py:207:12: W0612: Unused variable 'training_iteration' (unused-variable)
alphazero/alphazero_agent.py:236:4: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/alphazero_agent.py:241:15: W0621: Redefining name 'policy' from outer scope (line 2) (redefined-outer-name)
alphazero/alphazero_agent.py:239:11: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
alphazero/alphazero_agent.py:256:4: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/alphazero_agent.py:256:4: W1113: Keyword argument before variable positional arguments list in the definition of predict function (keyword-arg-before-vararg)
alphazero/alphazero_agent.py:256:0: W0613: Unused argument 'args' (unused-argument)
alphazero/alphazero_agent.py:256:0: W0613: Unused argument 'kwargs' (unused-argument)
alphazero/alphazero_agent.py:271:4: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/alphazero_agent.py:271:0: W0613: Unused argument 'args' (unused-argument)
alphazero/alphazero_agent.py:271:0: W0613: Unused argument 'kwargs' (unused-argument)
alphazero/alphazero_agent.py:271:4: R0201: Method could be a function (no-self-use)
alphazero/alphazero_agent.py:275:4: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/alphazero_agent.py:100:21: E0203: Access to member 'training_time' before its definition line 124 (access-member-before-definition)
alphazero/alphazero_agent.py:124:16: W0201: Attribute 'training_time' defined outside __init__ (attribute-defined-outside-init)
alphazero/alphazero_agent.py:128:8: W0201: Attribute 'training_time' defined outside __init__ (attribute-defined-outside-init)
alphazero/alphazero_agent.py:2:0: W0611: Unused policy imported from email (unused-import)
alphazero/alphazero_agent.py:3:0: W0611: Unused M imported from re (unused-import)
alphazero/alphazero_agent.py:18:0: C0411: standard import "import sys" should be placed before "from agent_configs import AlphaZeroConfig" (wrong-import-order)
alphazero/alphazero_agent.py:23:0: C0411: standard import "import copy" should be placed before "from agent_configs import AlphaZeroConfig" (wrong-import-order)
alphazero/alphazero_agent.py:24:0: C0411: third party import "import numpy as np" should be placed before "from base_agent.agent import BaseAgent" (wrong-import-order)
alphazero/alphazero_agent.py:28:0: C0411: third party import "from torch.nn.utils import clip_grad_norm_" should be placed before "from base_agent.agent import BaseAgent" (wrong-import-order)
alphazero/alphazero_agent.py:28:0: C0412: Imports from package torch are not grouped (ungrouped-imports)
************* Module rl-research.alphazero.alphazero_mcts
alphazero/alphazero_mcts.py:1:0: C0114: Missing module docstring (missing-module-docstring)
alphazero/alphazero_mcts.py:7:0: C0115: Missing class docstring (missing-class-docstring)
alphazero/alphazero_mcts.py:18:4: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/alphazero_mcts.py:29:20: C0103: Variable name "p" doesn't conform to snake_case naming style (invalid-name)
alphazero/alphazero_mcts.py:31:25: W0612: Unused variable 'reward' (unused-variable)
alphazero/alphazero_mcts.py:31:33: W0612: Unused variable 'terminated' (unused-variable)
alphazero/alphazero_mcts.py:31:45: W0612: Unused variable 'truncated' (unused-variable)
alphazero/alphazero_mcts.py:36:4: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/alphazero_mcts.py:39:4: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/alphazero_mcts.py:44:4: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/alphazero_mcts.py:47:12: C0103: Variable name "a" doesn't conform to snake_case naming style (invalid-name)
alphazero/alphazero_mcts.py:47:15: C0103: Variable name "n" doesn't conform to snake_case naming style (invalid-name)
alphazero/alphazero_mcts.py:52:4: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/alphazero_mcts.py:75:4: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/alphazero_mcts.py:1:0: W0611: Unused deepcopy imported from copy (unused-import)
alphazero/alphazero_mcts.py:2:0: W0611: Unused inf imported from math (unused-import)
************* Module rl-research.alphazero.alphazero_network
alphazero/alphazero_network.py:1:0: C0114: Missing module docstring (missing-module-docstring)
alphazero/alphazero_network.py:2:0: E0611: No name 'alphazero_config' in module 'agent_configs' (no-name-in-module)
alphazero/alphazero_network.py:2:0: E0401: Unable to import 'agent_configs.alphazero_config' (import-error)
alphazero/alphazero_network.py:3:0: E0401: Unable to import 'torch' (import-error)
alphazero/alphazero_network.py:6:0: E0401: Unable to import 'modules.conv' (import-error)
alphazero/alphazero_network.py:7:0: E0401: Unable to import 'modules.dense' (import-error)
alphazero/alphazero_network.py:8:0: E0401: Unable to import 'modules.residual' (import-error)
alphazero/alphazero_network.py:11:0: C0115: Missing class docstring (missing-class-docstring)
alphazero/alphazero_network.py:11:0: R0902: Too many instance attributes (10/7) (too-many-instance-attributes)
alphazero/alphazero_network.py:24:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
alphazero/alphazero_network.py:36:8: C0103: Variable name "B" doesn't conform to snake_case naming style (invalid-name)
alphazero/alphazero_network.py:43:15: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
alphazero/alphazero_network.py:65:15: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
alphazero/alphazero_network.py:106:4: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/alphazero_network.py:117:4: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/alphazero_network.py:122:8: C0103: Variable name "S" doesn't conform to snake_case naming style (invalid-name)
alphazero/alphazero_network.py:127:12: C0103: Variable name "S" doesn't conform to snake_case naming style (invalid-name)
alphazero/alphazero_network.py:131:12: C0103: Variable name "S" doesn't conform to snake_case naming style (invalid-name)
alphazero/alphazero_network.py:137:12: C0103: Variable name "S" doesn't conform to snake_case naming style (invalid-name)
alphazero/alphazero_network.py:138:12: C0103: Variable name "S" doesn't conform to snake_case naming style (invalid-name)
alphazero/alphazero_network.py:143:0: C0115: Missing class docstring (missing-class-docstring)
alphazero/alphazero_network.py:153:8: C0103: Variable name "B" doesn't conform to snake_case naming style (invalid-name)
alphazero/alphazero_network.py:206:4: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/alphazero_network.py:213:4: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/alphazero_network.py:217:15: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
alphazero/alphazero_network.py:219:8: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
alphazero/alphazero_network.py:221:12: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
alphazero/alphazero_network.py:223:12: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
alphazero/alphazero_network.py:224:12: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
alphazero/alphazero_network.py:228:4: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/alphazero_network.py:236:0: C0115: Missing class docstring (missing-class-docstring)
alphazero/alphazero_network.py:251:8: C0103: Variable name "B" doesn't conform to snake_case naming style (invalid-name)
alphazero/alphazero_network.py:279:19: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
alphazero/alphazero_network.py:307:4: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/alphazero_network.py:316:4: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/alphazero_network.py:320:15: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
alphazero/alphazero_network.py:322:8: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
alphazero/alphazero_network.py:324:12: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
alphazero/alphazero_network.py:326:12: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
alphazero/alphazero_network.py:327:12: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
alphazero/alphazero_network.py:331:4: C0116: Missing function or method docstring (missing-function-docstring)
************* Module rl-research.alphazero.official_pseudocode
alphazero/official_pseudocode.py:3:0: E0611: No name 'google_type_annotations' in module '__future__' (no-name-in-module)
alphazero/official_pseudocode.py:8:0: E0401: Unable to import 'tensorflow' (import-error)
alphazero/official_pseudocode.py:15:0: C0115: Missing class docstring (missing-class-docstring)
alphazero/official_pseudocode.py:15:0: R0902: Too many instance attributes (15/7) (too-many-instance-attributes)
alphazero/official_pseudocode.py:15:0: R0205: Class 'AlphaZeroConfig' inherits from object, can be safely removed from bases in python3 (useless-object-inheritance)
alphazero/official_pseudocode.py:15:0: R0903: Too few public methods (0/2) (too-few-public-methods)
alphazero/official_pseudocode.py:44:0: C0115: Missing class docstring (missing-class-docstring)
alphazero/official_pseudocode.py:44:0: R0205: Class 'Node' inherits from object, can be safely removed from bases in python3 (useless-object-inheritance)
alphazero/official_pseudocode.py:52:4: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/official_pseudocode.py:55:4: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/official_pseudocode.py:61:0: C0115: Missing class docstring (missing-class-docstring)
alphazero/official_pseudocode.py:61:0: R0205: Class 'Game' inherits from object, can be safely removed from bases in python3 (useless-object-inheritance)
alphazero/official_pseudocode.py:69:4: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/official_pseudocode.py:73:4: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/official_pseudocode.py:77:4: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/official_pseudocode.py:77:4: R0201: Method could be a function (no-self-use)
alphazero/official_pseudocode.py:81:4: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/official_pseudocode.py:84:4: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/official_pseudocode.py:87:4: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/official_pseudocode.py:96:4: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/official_pseudocode.py:96:25: W0613: Unused argument 'state_index' (unused-argument)
alphazero/official_pseudocode.py:96:4: R0201: Method could be a function (no-self-use)
alphazero/official_pseudocode.py:100:4: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/official_pseudocode.py:103:4: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/official_pseudocode.py:107:0: C0115: Missing class docstring (missing-class-docstring)
alphazero/official_pseudocode.py:107:0: R0205: Class 'ReplayBuffer' inherits from object, can be safely removed from bases in python3 (useless-object-inheritance)
alphazero/official_pseudocode.py:113:4: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/official_pseudocode.py:118:4: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/official_pseudocode.py:130:0: C0115: Missing class docstring (missing-class-docstring)
alphazero/official_pseudocode.py:130:0: R0205: Class 'Network' inherits from object, can be safely removed from bases in python3 (useless-object-inheritance)
alphazero/official_pseudocode.py:131:4: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/official_pseudocode.py:131:24: W0613: Unused argument 'image' (unused-argument)
alphazero/official_pseudocode.py:131:4: R0201: Method could be a function (no-self-use)
alphazero/official_pseudocode.py:134:4: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/official_pseudocode.py:134:4: R0201: Method could be a function (no-self-use)
alphazero/official_pseudocode.py:139:0: C0115: Missing class docstring (missing-class-docstring)
alphazero/official_pseudocode.py:139:0: R0205: Class 'SharedStorage' inherits from object, can be safely removed from bases in python3 (useless-object-inheritance)
alphazero/official_pseudocode.py:144:4: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/official_pseudocode.py:145:8: R1705: Unnecessary "else" after "return" (no-else-return)
alphazero/official_pseudocode.py:146:38: E1101: Instance of 'dict' has no 'iterkeys' member (no-member)
alphazero/official_pseudocode.py:150:4: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/official_pseudocode.py:163:0: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/official_pseudocode.py:167:8: W0612: Unused variable 'i' (unused-variable)
alphazero/official_pseudocode.py:182:0: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/official_pseudocode.py:194:0: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/official_pseudocode.py:207:0: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/official_pseudocode.py:227:0: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/official_pseudocode.py:239:0: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/official_pseudocode.py:249:0: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/official_pseudocode.py:262:0: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/official_pseudocode.py:269:16: C0103: Variable name "p" doesn't conform to snake_case naming style (invalid-name)
alphazero/official_pseudocode.py:276:0: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/official_pseudocode.py:284:0: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/official_pseudocode.py:288:8: C0103: Variable name "a" doesn't conform to snake_case naming style (invalid-name)
alphazero/official_pseudocode.py:288:11: C0103: Variable name "n" doesn't conform to snake_case naming style (invalid-name)
alphazero/official_pseudocode.py:299:0: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/official_pseudocode.py:314:0: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/official_pseudocode.py:342:19: C0103: Argument name "d" doesn't conform to snake_case naming style (invalid-name)
alphazero/official_pseudocode.py:342:0: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/official_pseudocode.py:342:19: W0613: Unused argument 'd' (unused-argument)
alphazero/official_pseudocode.py:346:15: C0103: Argument name "f" doesn't conform to snake_case naming style (invalid-name)
alphazero/official_pseudocode.py:346:0: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/official_pseudocode.py:350:0: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/official_pseudocode.py:9:0: C0411: standard import "from typing import List" should be placed before "import numpy" (wrong-import-order)
************* Module alphazero_agent
alphazero/tesnorflow graphs/old/alphazero_agent.py:247:0: C0301: Line too long (106/100) (line-too-long)
alphazero/tesnorflow graphs/old/alphazero_agent.py:1:0: C0114: Missing module docstring (missing-module-docstring)
alphazero/tesnorflow graphs/old/alphazero_agent.py:5:0: C0413: Import "import os" should be placed at the top of the module (wrong-import-position)
alphazero/tesnorflow graphs/old/alphazero_agent.py:11:0: E0401: Unable to import 'tensorflow' (import-error)
alphazero/tesnorflow graphs/old/alphazero_agent.py:11:0: C0413: Import "import tensorflow as tf" should be placed at the top of the module (wrong-import-position)
alphazero/tesnorflow graphs/old/alphazero_agent.py:28:0: C0413: Import "import datetime" should be placed at the top of the module (wrong-import-position)
alphazero/tesnorflow graphs/old/alphazero_agent.py:29:0: C0413: Import "import copy" should be placed at the top of the module (wrong-import-position)
alphazero/tesnorflow graphs/old/alphazero_agent.py:30:0: C0413: Import "import numpy as np" should be placed at the top of the module (wrong-import-position)
alphazero/tesnorflow graphs/old/alphazero_agent.py:31:0: E0401: Unable to import 'alphazero.alphazero_network' (import-error)
alphazero/tesnorflow graphs/old/alphazero_agent.py:31:0: C0413: Import "from alphazero.alphazero_network import Network" should be placed at the top of the module (wrong-import-position)
alphazero/tesnorflow graphs/old/alphazero_agent.py:33:0: E0401: Unable to import 'replay_buffers.alphazero_replay_buffer' (import-error)
alphazero/tesnorflow graphs/old/alphazero_agent.py:33:0: C0413: Import "from replay_buffers.alphazero_replay_buffer import ReplayBuffer" should be placed at the top of the module (wrong-import-position)
alphazero/tesnorflow graphs/old/alphazero_agent.py:34:0: E0401: Unable to import 'tensorflow_probability' (import-error)
alphazero/tesnorflow graphs/old/alphazero_agent.py:34:0: C0413: Import "import tensorflow_probability as tfp" should be placed at the top of the module (wrong-import-position)
alphazero/tesnorflow graphs/old/alphazero_agent.py:35:0: C0413: Import "import matplotlib.pyplot as plt" should be placed at the top of the module (wrong-import-position)
alphazero/tesnorflow graphs/old/alphazero_agent.py:36:0: E0401: Unable to import 'gymnasium' (import-error)
alphazero/tesnorflow graphs/old/alphazero_agent.py:36:0: C0413: Import "import gymnasium as gym" should be placed at the top of the module (wrong-import-position)
alphazero/tesnorflow graphs/old/alphazero_agent.py:38:0: E0401: Unable to import 'alphazero.old.MCTS_alphazero' (import-error)
alphazero/tesnorflow graphs/old/alphazero_agent.py:38:0: C0413: Import "import alphazero.old.MCTS_alphazero as MCTS" should be placed at the top of the module (wrong-import-position)
alphazero/tesnorflow graphs/old/alphazero_agent.py:39:0: C0413: Import "import random" should be placed at the top of the module (wrong-import-position)
alphazero/tesnorflow graphs/old/alphazero_agent.py:40:0: C0413: Import "import gc" should be placed at the top of the module (wrong-import-position)
alphazero/tesnorflow graphs/old/alphazero_agent.py:43:0: C0115: Missing class docstring (missing-class-docstring)
alphazero/tesnorflow graphs/old/alphazero_agent.py:43:0: R0902: Too many instance attributes (26/7) (too-many-instance-attributes)
alphazero/tesnorflow graphs/old/alphazero_agent.py:92:26: R1734: Consider using [] instead of list() (use-list-literal)
alphazero/tesnorflow graphs/old/alphazero_agent.py:95:4: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/tesnorflow graphs/old/alphazero_agent.py:97:19: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
alphazero/tesnorflow graphs/old/alphazero_agent.py:98:43: E1101: Instance of 'AlphaZeroAgent' has no 'start_episode' member (no-member)
alphazero/tesnorflow graphs/old/alphazero_agent.py:101:19: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
alphazero/tesnorflow graphs/old/alphazero_agent.py:108:4: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/tesnorflow graphs/old/alphazero_agent.py:120:4: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/tesnorflow graphs/old/alphazero_agent.py:127:4: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/tesnorflow graphs/old/alphazero_agent.py:138:4: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/tesnorflow graphs/old/alphazero_agent.py:165:4: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/tesnorflow graphs/old/alphazero_agent.py:165:4: R0913: Too many arguments (6/5) (too-many-arguments)
alphazero/tesnorflow graphs/old/alphazero_agent.py:173:11: C0121: Comparison 'game_turn != None' should be 'game_turn is not None' (singleton-comparison)
alphazero/tesnorflow graphs/old/alphazero_agent.py:193:4: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/tesnorflow graphs/old/alphazero_agent.py:193:28: W0613: Unused argument 'game_turn' (unused-argument)
alphazero/tesnorflow graphs/old/alphazero_agent.py:242:4: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/tesnorflow graphs/old/alphazero_agent.py:242:4: R0914: Too many local variables (21/15) (too-many-locals)
alphazero/tesnorflow graphs/old/alphazero_agent.py:243:8: E1101: Super of 'AlphaZeroAgent' has no 'train' member (no-member)
alphazero/tesnorflow graphs/old/alphazero_agent.py:307:30: E1101: Instance of 'AlphaZeroAgent' has no 'steps_per_epoch' member (no-member)
alphazero/tesnorflow graphs/old/alphazero_agent.py:313:4: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/tesnorflow graphs/old/alphazero_agent.py:316:22: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
alphazero/tesnorflow graphs/old/alphazero_agent.py:318:22: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
alphazero/tesnorflow graphs/old/alphazero_agent.py:322:12: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
alphazero/tesnorflow graphs/old/alphazero_agent.py:324:20: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
alphazero/tesnorflow graphs/old/alphazero_agent.py:327:4: R0914: Too many local variables (16/15) (too-many-locals)
alphazero/tesnorflow graphs/old/alphazero_agent.py:356:27: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
alphazero/tesnorflow graphs/old/alphazero_agent.py:331:12: W0612: Unused variable 'trials' (unused-variable)
alphazero/tesnorflow graphs/old/alphazero_agent.py:5:0: W0611: Unused import os (unused-import)
alphazero/tesnorflow graphs/old/alphazero_agent.py:34:0: W0611: Unused tensorflow_probability imported as tfp (unused-import)
alphazero/tesnorflow graphs/old/alphazero_agent.py:39:0: W0611: Unused import random (unused-import)
alphazero/tesnorflow graphs/old/alphazero_agent.py:28:0: C0411: standard import "import datetime" should be placed before "import tensorflow as tf" (wrong-import-order)
alphazero/tesnorflow graphs/old/alphazero_agent.py:29:0: C0411: standard import "import copy" should be placed before "import tensorflow as tf" (wrong-import-order)
alphazero/tesnorflow graphs/old/alphazero_agent.py:34:0: C0411: third party import "import tensorflow_probability as tfp" should be placed before "from alphazero.alphazero_network import Network" (wrong-import-order)
alphazero/tesnorflow graphs/old/alphazero_agent.py:35:0: C0411: third party import "import matplotlib.pyplot as plt" should be placed before "from alphazero.alphazero_network import Network" (wrong-import-order)
alphazero/tesnorflow graphs/old/alphazero_agent.py:36:0: C0411: third party import "import gymnasium as gym" should be placed before "from alphazero.alphazero_network import Network" (wrong-import-order)
alphazero/tesnorflow graphs/old/alphazero_agent.py:39:0: C0411: standard import "import random" should be placed before "import tensorflow as tf" (wrong-import-order)
alphazero/tesnorflow graphs/old/alphazero_agent.py:40:0: C0411: standard import "import gc" should be placed before "import tensorflow as tf" (wrong-import-order)
************* Module MCTS_alphazero
alphazero/tesnorflow graphs/old/MCTS_alphazero.py:1:0: C0103: Module name "MCTS_alphazero" doesn't conform to snake_case naming style (invalid-name)
alphazero/tesnorflow graphs/old/MCTS_alphazero.py:1:0: C0114: Missing module docstring (missing-module-docstring)
alphazero/tesnorflow graphs/old/MCTS_alphazero.py:7:0: C0115: Missing class docstring (missing-class-docstring)
alphazero/tesnorflow graphs/old/MCTS_alphazero.py:7:0: R0902: Too many instance attributes (10/7) (too-many-instance-attributes)
alphazero/tesnorflow graphs/old/MCTS_alphazero.py:8:4: R0913: Too many arguments (8/5) (too-many-arguments)
alphazero/tesnorflow graphs/old/MCTS_alphazero.py:24:4: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/tesnorflow graphs/old/MCTS_alphazero.py:27:4: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/tesnorflow graphs/old/MCTS_alphazero.py:30:4: C0116: Missing function or method docstring (missing-function-docstring)
alphazero/tesnorflow graphs/old/MCTS_alphazero.py:31:8: C0200: Consider using enumerate instead of iterating with range and len (consider-using-enumerate)
alphazero/tesnorflow graphs/old/MCTS_alphazero.py:1:0: W0611: Unused deepcopy imported from copy (unused-import)
alphazero/tesnorflow graphs/old/MCTS_alphazero.py:2:0: W0611: Unused log imported from math (unused-import)
alphazero/tesnorflow graphs/old/MCTS_alphazero.py:2:0: W0611: Unused sqrt imported from math (unused-import)
alphazero/tesnorflow graphs/old/MCTS_alphazero.py:2:0: W0611: Unused inf imported from math (unused-import)
************* Module agent
base_agent/agent.py:34:0: C0301: Line too long (128/100) (line-too-long)
base_agent/agent.py:107:0: C0301: Line too long (123/100) (line-too-long)
base_agent/agent.py:108:0: C0301: Line too long (116/100) (line-too-long)
base_agent/agent.py:113:0: C0301: Line too long (107/100) (line-too-long)
base_agent/agent.py:114:0: C0301: Line too long (122/100) (line-too-long)
base_agent/agent.py:137:0: C0301: Line too long (120/100) (line-too-long)
base_agent/agent.py:148:0: C0301: Line too long (102/100) (line-too-long)
base_agent/agent.py:151:0: C0301: Line too long (102/100) (line-too-long)
base_agent/agent.py:156:0: C0301: Line too long (115/100) (line-too-long)
base_agent/agent.py:171:0: C0301: Line too long (109/100) (line-too-long)
base_agent/agent.py:182:0: C0303: Trailing whitespace (trailing-whitespace)
base_agent/agent.py:188:0: C0303: Trailing whitespace (trailing-whitespace)
base_agent/agent.py:192:0: C0303: Trailing whitespace (trailing-whitespace)
base_agent/agent.py:196:0: C0303: Trailing whitespace (trailing-whitespace)
base_agent/agent.py:200:0: C0303: Trailing whitespace (trailing-whitespace)
base_agent/agent.py:204:0: C0303: Trailing whitespace (trailing-whitespace)
base_agent/agent.py:226:0: C0301: Line too long (121/100) (line-too-long)
base_agent/agent.py:242:0: C0303: Trailing whitespace (trailing-whitespace)
base_agent/agent.py:253:0: C0301: Line too long (104/100) (line-too-long)
base_agent/agent.py:298:0: C0301: Line too long (157/100) (line-too-long)
base_agent/agent.py:315:0: C0303: Trailing whitespace (trailing-whitespace)
base_agent/agent.py:350:0: C0301: Line too long (201/100) (line-too-long)
base_agent/agent.py:1:0: C0114: Missing module docstring (missing-module-docstring)
base_agent/agent.py:5:0: E0401: Unable to import 'torch' (import-error)
base_agent/agent.py:6:0: E0401: Unable to import 'gymnasium' (import-error)
base_agent/agent.py:8:0: E0611: No name 'Config' in module 'agent_configs' (no-name-in-module)
base_agent/agent.py:10:0: E0401: Unable to import 'torch.optim' (import-error)
base_agent/agent.py:11:0: E0401: Unable to import 'torch.nn' (import-error)
base_agent/agent.py:13:0: E0611: No name 'make_stack' in module 'utils' (no-name-in-module)
base_agent/agent.py:13:0: E0611: No name 'plot_graphs' in module 'utils' (no-name-in-module)
base_agent/agent.py:25:0: C0115: Missing class docstring (missing-class-docstring)
base_agent/agent.py:25:0: R0902: Too many instance attributes (18/7) (too-many-instance-attributes)
base_agent/agent.py:26:4: R0913: Too many arguments (6/5) (too-many-arguments)
base_agent/agent.py:73:4: C0116: Missing function or method docstring (missing-function-docstring)
base_agent/agent.py:75:8: R1705: Unnecessary "else" after "return" (no-else-return)
base_agent/agent.py:82:28: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
base_agent/agent.py:90:4: C0116: Missing function or method docstring (missing-function-docstring)
base_agent/agent.py:91:8: R1705: Unnecessary "elif" after "return" (no-else-return)
base_agent/agent.py:90:4: R0201: Method could be a function (no-self-use)
base_agent/agent.py:100:4: C0116: Missing function or method docstring (missing-function-docstring)
base_agent/agent.py:104:8: W0107: Unnecessary pass statement (unnecessary-pass)
base_agent/agent.py:170:4: C0116: Missing function or method docstring (missing-function-docstring)
base_agent/agent.py:174:4: C0116: Missing function or method docstring (missing-function-docstring)
base_agent/agent.py:177:4: C0116: Missing function or method docstring (missing-function-docstring)
base_agent/agent.py:180:4: C0116: Missing function or method docstring (missing-function-docstring)
base_agent/agent.py:183:4: C0116: Missing function or method docstring (missing-function-docstring)
base_agent/agent.py:189:4: C0116: Missing function or method docstring (missing-function-docstring)
base_agent/agent.py:193:4: C0116: Missing function or method docstring (missing-function-docstring)
base_agent/agent.py:197:4: C0116: Missing function or method docstring (missing-function-docstring)
base_agent/agent.py:201:4: C0116: Missing function or method docstring (missing-function-docstring)
base_agent/agent.py:205:4: C0116: Missing function or method docstring (missing-function-docstring)
base_agent/agent.py:205:4: R0201: Method could be a function (no-self-use)
base_agent/agent.py:209:4: C0116: Missing function or method docstring (missing-function-docstring)
base_agent/agent.py:213:4: C0116: Missing function or method docstring (missing-function-docstring)
base_agent/agent.py:213:56: W0622: Redefining built-in 'dir' (redefined-builtin)
base_agent/agent.py:213:4: E0213: Method should have "self" as first argument (no-self-argument)
base_agent/agent.py:217:51: W1309: Using an f-string that does not have any interpolated variables (f-string-without-interpolation)
base_agent/agent.py:224:16: E1102: agent_class is not callable (not-callable)
base_agent/agent.py:238:42: W1309: Using an f-string that does not have any interpolated variables (f-string-without-interpolation)
base_agent/agent.py:238:79: C0103: Variable name "f" doesn't conform to snake_case naming style (invalid-name)
base_agent/agent.py:240:42: W1309: Using an f-string that does not have any interpolated variables (f-string-without-interpolation)
base_agent/agent.py:240:81: C0103: Variable name "f" doesn't conform to snake_case naming style (invalid-name)
base_agent/agent.py:245:4: C0116: Missing function or method docstring (missing-function-docstring)
base_agent/agent.py:266:8: W0622: Redefining built-in 'dir' (redefined-builtin)
base_agent/agent.py:272:55: W1309: Using an f-string that does not have any interpolated variables (f-string-without-interpolation)
base_agent/agent.py:274:25: E1121: Too many positional arguments for method call (too-many-function-args)
base_agent/agent.py:288:8: E1101: Instance of 'BaseAgent' has no 'stats' member (no-member)
base_agent/agent.py:291:36: W1309: Using an f-string that does not have any interpolated variables (f-string-without-interpolation)
base_agent/agent.py:293:42: W1309: Using an f-string that does not have any interpolated variables (f-string-without-interpolation)
base_agent/agent.py:293:79: C0103: Variable name "f" doesn't conform to snake_case naming style (invalid-name)
base_agent/agent.py:294:24: E1101: Instance of 'BaseAgent' has no 'stats' member (no-member)
base_agent/agent.py:295:42: W1309: Using an f-string that does not have any interpolated variables (f-string-without-interpolation)
base_agent/agent.py:295:81: C0103: Variable name "f" doesn't conform to snake_case naming style (invalid-name)
base_agent/agent.py:296:24: E1101: Instance of 'BaseAgent' has no 'targets' member (no-member)
base_agent/agent.py:302:14: E1101: Instance of 'BaseAgent' has no 'stats' member (no-member)
base_agent/agent.py:303:14: E1101: Instance of 'BaseAgent' has no 'targets' member (no-member)
base_agent/agent.py:307:12: E1101: Instance of 'BaseAgent' has no 'stats' member (no-member)
base_agent/agent.py:308:12: E1101: Instance of 'BaseAgent' has no 'targets' member (no-member)
base_agent/agent.py:316:4: C0116: Missing function or method docstring (missing-function-docstring)
base_agent/agent.py:325:4: C0116: Missing function or method docstring (missing-function-docstring)
base_agent/agent.py:325:37: W0622: Redefining built-in 'dir' (redefined-builtin)
base_agent/agent.py:325:4: R0914: Too many local variables (18/15) (too-many-locals)
base_agent/agent.py:329:12: W0105: String statement has no effect (pointless-string-statement)
base_agent/agent.py:336:45: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
base_agent/agent.py:348:33: E1123: Unexpected keyword argument 'env' in method call (unexpected-keyword-arg)
base_agent/agent.py:325:4: R1710: Either all return statements in a function should return an expression, or none of them should. (inconsistent-return-statements)
base_agent/agent.py:341:16: W0612: Unused variable 'trials' (unused-variable)
base_agent/agent.py:377:4: C0116: Missing function or method docstring (missing-function-docstring)
base_agent/agent.py:380:4: C0116: Missing function or method docstring (missing-function-docstring)
base_agent/agent.py:385:4: C0116: Missing function or method docstring (missing-function-docstring)
base_agent/agent.py:386:14: W1309: Using an f-string that does not have any interpolated variables (f-string-without-interpolation)
base_agent/agent.py:385:4: R0201: Method could be a function (no-self-use)
base_agent/agent.py:25:0: R0904: Too many public methods (24/20) (too-many-public-methods)
base_agent/agent.py:178:8: W0201: Attribute 'replay_buffer' defined outside __init__ (attribute-defined-outside-init)
base_agent/agent.py:7:0: C0411: standard import "import copy" should be placed before "import numpy as np" (wrong-import-order)
base_agent/agent.py:9:0: C0411: standard import "import pickle" should be placed before "import numpy as np" (wrong-import-order)
************* Module distributed_agents
base_agent/distributed_agents.py:95:0: C0301: Line too long (105/100) (line-too-long)
base_agent/distributed_agents.py:1:0: C0114: Missing module docstring (missing-module-docstring)
base_agent/distributed_agents.py:2:0: E0401: Unable to import 'torch' (import-error)
base_agent/distributed_agents.py:4:0: E0401: Unable to import 'base_agent.agent' (import-error)
base_agent/distributed_agents.py:5:0: E0611: No name 'Config' in module 'agent_configs' (no-name-in-module)
base_agent/distributed_agents.py:5:0: E0611: No name 'ConfigBase' in module 'agent_configs' (no-name-in-module)
base_agent/distributed_agents.py:6:0: E0401: Unable to import 'gymnasium' (import-error)
base_agent/distributed_agents.py:7:0: E0611: No name 'get_legal_moves' in module 'utils' (no-name-in-module)
base_agent/distributed_agents.py:13:0: C0115: Missing class docstring (missing-class-docstring)
base_agent/distributed_agents.py:32:4: C0116: Missing function or method docstring (missing-function-docstring)
base_agent/distributed_agents.py:35:4: C0116: Missing function or method docstring (missing-function-docstring)
base_agent/distributed_agents.py:42:8: W0107: Unnecessary pass statement (unnecessary-pass)
base_agent/distributed_agents.py:44:4: C0116: Missing function or method docstring (missing-function-docstring)
base_agent/distributed_agents.py:50:8: C0103: Variable name "t" doesn't conform to snake_case naming style (invalid-name)
base_agent/distributed_agents.py:53:38: C0103: Argument name "t" doesn't conform to snake_case naming style (invalid-name)
base_agent/distributed_agents.py:53:4: C0116: Missing function or method docstring (missing-function-docstring)
base_agent/distributed_agents.py:56:4: C0116: Missing function or method docstring (missing-function-docstring)
base_agent/distributed_agents.py:59:4: C0116: Missing function or method docstring (missing-function-docstring)
base_agent/distributed_agents.py:62:4: C0116: Missing function or method docstring (missing-function-docstring)
base_agent/distributed_agents.py:79:19: W0703: Catching too general exception Exception (broad-except)
base_agent/distributed_agents.py:72:20: C0103: Variable name "t" doesn't conform to snake_case naming style (invalid-name)
base_agent/distributed_agents.py:79:12: C0103: Variable name "e" doesn't conform to snake_case naming style (invalid-name)
base_agent/distributed_agents.py:82:16: W0107: Unnecessary pass statement (unnecessary-pass)
base_agent/distributed_agents.py:64:12: W0612: Unused variable 'failed' (unused-variable)
base_agent/distributed_agents.py:89:0: C0115: Missing class docstring (missing-class-docstring)
base_agent/distributed_agents.py:89:0: R0903: Too few public methods (0/2) (too-few-public-methods)
base_agent/distributed_agents.py:96:0: C0115: Missing class docstring (missing-class-docstring)
base_agent/distributed_agents.py:100:4: C0116: Missing function or method docstring (missing-function-docstring)
base_agent/distributed_agents.py:96:0: R0903: Too few public methods (1/2) (too-few-public-methods)
base_agent/distributed_agents.py:110:4: W0235: Useless super delegation in method '__init__' (useless-super-delegation)
base_agent/distributed_agents.py:113:4: C0116: Missing function or method docstring (missing-function-docstring)
base_agent/distributed_agents.py:116:4: C0116: Missing function or method docstring (missing-function-docstring)
base_agent/distributed_agents.py:119:4: C0116: Missing function or method docstring (missing-function-docstring)
base_agent/distributed_agents.py:122:4: C0116: Missing function or method docstring (missing-function-docstring)
base_agent/distributed_agents.py:7:0: W0611: Unused get_legal_moves imported from utils (unused-import)
base_agent/distributed_agents.py:5:0: C0411: third party import "from agent_configs import Config, ConfigBase" should be placed before "from base_agent.agent import BaseAgent" (wrong-import-order)
base_agent/distributed_agents.py:6:0: C0411: third party import "from gymnasium import Env" should be placed before "from base_agent.agent import BaseAgent" (wrong-import-order)
base_agent/distributed_agents.py:7:0: C0411: third party import "from utils import get_legal_moves" should be placed before "from base_agent.agent import BaseAgent" (wrong-import-order)
base_agent/distributed_agents.py:8:0: C0411: standard import "import logging" should be placed before "import torch" (wrong-import-order)
************* Module benchmark
benchmark/benchmark.py:1:0: C0114: Missing module docstring (missing-module-docstring)
benchmark/benchmark.py:3:0: E0401: Unable to import 'torch' (import-error)
benchmark/benchmark.py:4:0: E0401: Unable to import 'torch.utils.benchmark' (import-error)
benchmark/benchmark.py:8:9: C0103: Argument name "m" doesn't conform to snake_case naming style (invalid-name)
benchmark/benchmark.py:8:0: C0116: Missing function or method docstring (missing-function-docstring)
benchmark/benchmark.py:12:10: C0103: Argument name "m" doesn't conform to snake_case naming style (invalid-name)
benchmark/benchmark.py:12:0: C0116: Missing function or method docstring (missing-function-docstring)
benchmark/benchmark.py:15:4: W0621: Redefining name 'mean' from outer scope (line 8) (redefined-outer-name)
benchmark/benchmark.py:16:4: W0622: Redefining built-in 'max' (redefined-builtin)
benchmark/benchmark.py:17:4: W0622: Redefining built-in 'min' (redefined-builtin)
benchmark/benchmark.py:14:4: C0103: Variable name "t" doesn't conform to snake_case naming style (invalid-name)
benchmark/benchmark.py:18:4: C0103: Variable name "n" doesn't conform to snake_case naming style (invalid-name)
benchmark/benchmark.py:20:4: C0103: Variable name "ci" doesn't conform to snake_case naming style (invalid-name)
benchmark/benchmark.py:24:0: C0116: Missing function or method docstring (missing-function-docstring)
benchmark/benchmark.py:25:4: C0103: Variable name "t" doesn't conform to snake_case naming style (invalid-name)
benchmark/benchmark.py:38:0: C0116: Missing function or method docstring (missing-function-docstring)
benchmark/benchmark.py:39:4: C0103: Variable name "t" doesn't conform to snake_case naming style (invalid-name)
benchmark/benchmark.py:52:0: C0116: Missing function or method docstring (missing-function-docstring)
benchmark/benchmark.py:53:4: C0103: Variable name "t" doesn't conform to snake_case naming style (invalid-name)
benchmark/benchmark.py:69:0: C0116: Missing function or method docstring (missing-function-docstring)
benchmark/benchmark.py:84:8: C0103: Variable name "a" doesn't conform to snake_case naming style (invalid-name)
benchmark/benchmark.py:84:11: C0103: Variable name "b" doesn't conform to snake_case naming style (invalid-name)
benchmark/benchmark.py:90:16: C0103: Variable name "t" doesn't conform to snake_case naming style (invalid-name)
benchmark/benchmark.py:5:0: C0411: standard import "from itertools import product" should be placed before "import numpy as np" (wrong-import-order)
************* Module rl-research.custom_gym_envs.custom_gym_envs
custom_gym_envs/custom_gym_envs/__init__.py:1:0: C0114: Missing module docstring (missing-module-docstring)
custom_gym_envs/custom_gym_envs/__init__.py:1:0: E0401: Unable to import 'gymnasium.envs.registration' (import-error)
************* Module rl-research.custom_gym_envs.custom_gym_envs.envs
custom_gym_envs/custom_gym_envs/envs/__init__.py:1:0: C0114: Missing module docstring (missing-module-docstring)
custom_gym_envs/custom_gym_envs/envs/__init__.py:1:0: E0401: Unable to import 'custom_gym_envs.envs.tictactoe' (import-error)
custom_gym_envs/custom_gym_envs/envs/__init__.py:2:0: E0401: Unable to import 'custom_gym_envs.envs.connect4' (import-error)
custom_gym_envs/custom_gym_envs/envs/__init__.py:3:0: E0401: Unable to import 'custom_gym_envs.envs.grid_world' (import-error)
custom_gym_envs/custom_gym_envs/envs/__init__.py:4:0: E0401: Unable to import 'custom_gym_envs.envs.mississippi_marbles' (import-error)
custom_gym_envs/custom_gym_envs/envs/__init__.py:5:0: E0401: Unable to import 'custom_gym_envs.envs.leduc_holdem' (import-error)
custom_gym_envs/custom_gym_envs/envs/__init__.py:6:0: E0401: Unable to import 'custom_gym_envs.envs.armed_bandits' (import-error)
custom_gym_envs/custom_gym_envs/envs/__init__.py:7:0: E0401: Unable to import 'custom_gym_envs.envs.nonstationary_armed_bandits' (import-error)
************* Module rl-research.custom_gym_envs.custom_gym_envs.envs.armed_bandits
custom_gym_envs/custom_gym_envs/envs/armed_bandits.py:1:0: C0114: Missing module docstring (missing-module-docstring)
custom_gym_envs/custom_gym_envs/envs/armed_bandits.py:3:0: E0401: Unable to import 'gymnasium' (import-error)
custom_gym_envs/custom_gym_envs/envs/armed_bandits.py:4:0: E0401: Unable to import 'gymnasium' (import-error)
custom_gym_envs/custom_gym_envs/envs/armed_bandits.py:7:0: C0115: Missing class docstring (missing-class-docstring)
custom_gym_envs/custom_gym_envs/envs/armed_bandits.py:28:4: R0201: Method could be a function (no-self-use)
custom_gym_envs/custom_gym_envs/envs/armed_bandits.py:31:4: R0201: Method could be a function (no-self-use)
custom_gym_envs/custom_gym_envs/envs/armed_bandits.py:34:4: C0116: Missing function or method docstring (missing-function-docstring)
custom_gym_envs/custom_gym_envs/envs/armed_bandits.py:34:31: W0613: Unused argument 'options' (unused-argument)
custom_gym_envs/custom_gym_envs/envs/armed_bandits.py:43:4: C0116: Missing function or method docstring (missing-function-docstring)
custom_gym_envs/custom_gym_envs/envs/armed_bandits.py:50:4: C0116: Missing function or method docstring (missing-function-docstring)
custom_gym_envs/custom_gym_envs/envs/armed_bandits.py:56:4: C0116: Missing function or method docstring (missing-function-docstring)
custom_gym_envs/custom_gym_envs/envs/armed_bandits.py:38:8: W0201: Attribute 'current_step' defined outside __init__ (attribute-defined-outside-init)
************* Module rl-research.custom_gym_envs.custom_gym_envs.envs.checkers
custom_gym_envs/custom_gym_envs/envs/checkers.py:16:0: C0301: Line too long (123/100) (line-too-long)
custom_gym_envs/custom_gym_envs/envs/checkers.py:143:0: C0301: Line too long (134/100) (line-too-long)
custom_gym_envs/custom_gym_envs/envs/checkers.py:1:0: C0114: Missing module docstring (missing-module-docstring)
custom_gym_envs/custom_gym_envs/envs/checkers.py:2:0: E0401: Unable to import 'gymnasium' (import-error)
custom_gym_envs/custom_gym_envs/envs/checkers.py:3:0: E0401: Unable to import 'gymnasium' (import-error)
custom_gym_envs/custom_gym_envs/envs/checkers.py:5:0: E0401: Unable to import 'pygame' (import-error)
custom_gym_envs/custom_gym_envs/envs/checkers.py:9:0: C0115: Missing class docstring (missing-class-docstring)
custom_gym_envs/custom_gym_envs/envs/checkers.py:9:0: R0902: Too many instance attributes (9/7) (too-many-instance-attributes)
custom_gym_envs/custom_gym_envs/envs/checkers.py:64:4: C0116: Missing function or method docstring (missing-function-docstring)
custom_gym_envs/custom_gym_envs/envs/checkers.py:64:31: W0613: Unused argument 'options' (unused-argument)
custom_gym_envs/custom_gym_envs/envs/checkers.py:129:4: C0116: Missing function or method docstring (missing-function-docstring)
custom_gym_envs/custom_gym_envs/envs/checkers.py:129:4: R0914: Too many local variables (19/15) (too-many-locals)
custom_gym_envs/custom_gym_envs/envs/checkers.py:135:16: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
custom_gym_envs/custom_gym_envs/envs/checkers.py:218:20: R0916: Too many boolean expressions in if statement (6/5) (too-many-boolean-expressions)
custom_gym_envs/custom_gym_envs/envs/checkers.py:229:20: R0916: Too many boolean expressions in if statement (6/5) (too-many-boolean-expressions)
custom_gym_envs/custom_gym_envs/envs/checkers.py:240:20: R0916: Too many boolean expressions in if statement (8/5) (too-many-boolean-expressions)
custom_gym_envs/custom_gym_envs/envs/checkers.py:255:20: R0916: Too many boolean expressions in if statement (8/5) (too-many-boolean-expressions)
custom_gym_envs/custom_gym_envs/envs/checkers.py:272:20: R0916: Too many boolean expressions in if statement (6/5) (too-many-boolean-expressions)
custom_gym_envs/custom_gym_envs/envs/checkers.py:283:20: R0916: Too many boolean expressions in if statement (6/5) (too-many-boolean-expressions)
custom_gym_envs/custom_gym_envs/envs/checkers.py:294:20: R0916: Too many boolean expressions in if statement (6/5) (too-many-boolean-expressions)
custom_gym_envs/custom_gym_envs/envs/checkers.py:305:20: R0916: Too many boolean expressions in if statement (6/5) (too-many-boolean-expressions)
custom_gym_envs/custom_gym_envs/envs/checkers.py:316:20: R0916: Too many boolean expressions in if statement (8/5) (too-many-boolean-expressions)
custom_gym_envs/custom_gym_envs/envs/checkers.py:331:20: R0916: Too many boolean expressions in if statement (8/5) (too-many-boolean-expressions)
custom_gym_envs/custom_gym_envs/envs/checkers.py:346:20: R0916: Too many boolean expressions in if statement (8/5) (too-many-boolean-expressions)
custom_gym_envs/custom_gym_envs/envs/checkers.py:361:20: R0916: Too many boolean expressions in if statement (8/5) (too-many-boolean-expressions)
custom_gym_envs/custom_gym_envs/envs/checkers.py:129:4: R0912: Too many branches (32/12) (too-many-branches)
custom_gym_envs/custom_gym_envs/envs/checkers.py:129:4: R0915: Too many statements (102/50) (too-many-statements)
custom_gym_envs/custom_gym_envs/envs/checkers.py:393:4: C0116: Missing function or method docstring (missing-function-docstring)
custom_gym_envs/custom_gym_envs/envs/checkers.py:393:4: R1710: Either all return statements in a function should return an expression, or none of them should. (inconsistent-return-statements)
custom_gym_envs/custom_gym_envs/envs/checkers.py:397:4: R1710: Either all return statements in a function should return an expression, or none of them should. (inconsistent-return-statements)
custom_gym_envs/custom_gym_envs/envs/checkers.py:518:4: C0116: Missing function or method docstring (missing-function-docstring)
custom_gym_envs/custom_gym_envs/envs/checkers.py:523:4: C0116: Missing function or method docstring (missing-function-docstring)
custom_gym_envs/custom_gym_envs/envs/checkers.py:69:8: W0201: Attribute '_grid' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/checkers.py:86:8: W0201: Attribute '_current_player' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/checkers.py:208:8: W0201: Attribute '_current_player' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/checkers.py:98:8: W0201: Attribute '_legal_moves' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/checkers.py:212:8: W0201: Attribute '_legal_moves' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/checkers.py:227:20: W0201: Attribute '_legal_moves' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/checkers.py:238:20: W0201: Attribute '_legal_moves' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/checkers.py:253:20: W0201: Attribute '_legal_moves' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/checkers.py:268:20: W0201: Attribute '_legal_moves' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/checkers.py:281:20: W0201: Attribute '_legal_moves' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/checkers.py:292:20: W0201: Attribute '_legal_moves' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/checkers.py:303:20: W0201: Attribute '_legal_moves' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/checkers.py:314:20: W0201: Attribute '_legal_moves' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/checkers.py:329:20: W0201: Attribute '_legal_moves' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/checkers.py:344:20: W0201: Attribute '_legal_moves' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/checkers.py:359:20: W0201: Attribute '_legal_moves' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/checkers.py:374:20: W0201: Attribute '_legal_moves' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/checkers.py:1:0: W0611: Unused check imported from tabnanny (unused-import)
custom_gym_envs/custom_gym_envs/envs/checkers.py:6:0: C0411: standard import "import copy" should be placed before "import gymnasium as gym" (wrong-import-order)
************* Module rl-research.custom_gym_envs.custom_gym_envs.envs.connect4
custom_gym_envs/custom_gym_envs/envs/connect4.py:20:0: C0301: Line too long (123/100) (line-too-long)
custom_gym_envs/custom_gym_envs/envs/connect4.py:46:0: C0301: Line too long (107/100) (line-too-long)
custom_gym_envs/custom_gym_envs/envs/connect4.py:1:0: C0114: Missing module docstring (missing-module-docstring)
custom_gym_envs/custom_gym_envs/envs/connect4.py:1:0: E0401: Unable to import 'gymnasium' (import-error)
custom_gym_envs/custom_gym_envs/envs/connect4.py:2:0: E0401: Unable to import 'gymnasium' (import-error)
custom_gym_envs/custom_gym_envs/envs/connect4.py:4:0: E0401: Unable to import 'pygame' (import-error)
custom_gym_envs/custom_gym_envs/envs/connect4.py:8:0: C0115: Missing class docstring (missing-class-docstring)
custom_gym_envs/custom_gym_envs/envs/connect4.py:8:0: R0902: Too many instance attributes (12/7) (too-many-instance-attributes)
custom_gym_envs/custom_gym_envs/envs/connect4.py:48:4: C0116: Missing function or method docstring (missing-function-docstring)
custom_gym_envs/custom_gym_envs/envs/connect4.py:48:31: W0613: Unused argument 'options' (unused-argument)
custom_gym_envs/custom_gym_envs/envs/connect4.py:70:4: C0116: Missing function or method docstring (missing-function-docstring)
custom_gym_envs/custom_gym_envs/envs/connect4.py:76:12: W0101: Unreachable code (unreachable)
custom_gym_envs/custom_gym_envs/envs/connect4.py:74:16: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
custom_gym_envs/custom_gym_envs/envs/connect4.py:82:18: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
custom_gym_envs/custom_gym_envs/envs/connect4.py:132:4: C0116: Missing function or method docstring (missing-function-docstring)
custom_gym_envs/custom_gym_envs/envs/connect4.py:132:4: R1710: Either all return statements in a function should return an expression, or none of them should. (inconsistent-return-statements)
custom_gym_envs/custom_gym_envs/envs/connect4.py:136:4: R1710: Either all return statements in a function should return an expression, or none of them should. (inconsistent-return-statements)
custom_gym_envs/custom_gym_envs/envs/connect4.py:207:4: C0116: Missing function or method docstring (missing-function-docstring)
custom_gym_envs/custom_gym_envs/envs/connect4.py:212:4: C0116: Missing function or method docstring (missing-function-docstring)
custom_gym_envs/custom_gym_envs/envs/connect4.py:53:8: W0201: Attribute '_grid' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/connect4.py:55:8: W0201: Attribute '_current_player' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/connect4.py:112:8: W0201: Attribute '_current_player' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/connect4.py:57:8: W0201: Attribute '_step_count' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/connect4.py:60:8: W0201: Attribute '_legal_moves' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/connect4.py:106:12: W0201: Attribute '_legal_moves' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/connect4.py:5:0: C0411: standard import "import copy" should be placed before "import gymnasium as gym" (wrong-import-order)
************* Module rl-research.custom_gym_envs.custom_gym_envs.envs.grid_world
custom_gym_envs/custom_gym_envs/envs/grid_world.py:16:0: C0301: Line too long (105/100) (line-too-long)
custom_gym_envs/custom_gym_envs/envs/grid_world.py:69:0: C0301: Line too long (108/100) (line-too-long)
custom_gym_envs/custom_gym_envs/envs/grid_world.py:1:0: C0114: Missing module docstring (missing-module-docstring)
custom_gym_envs/custom_gym_envs/envs/grid_world.py:2:0: E0401: Unable to import 'pygame' (import-error)
custom_gym_envs/custom_gym_envs/envs/grid_world.py:4:0: E0401: Unable to import 'gymnasium' (import-error)
custom_gym_envs/custom_gym_envs/envs/grid_world.py:5:0: E0401: Unable to import 'gymnasium' (import-error)
custom_gym_envs/custom_gym_envs/envs/grid_world.py:8:0: C0115: Missing class docstring (missing-class-docstring)
custom_gym_envs/custom_gym_envs/envs/grid_world.py:8:0: R0902: Too many instance attributes (10/7) (too-many-instance-attributes)
custom_gym_envs/custom_gym_envs/envs/grid_world.py:62:4: C0116: Missing function or method docstring (missing-function-docstring)
custom_gym_envs/custom_gym_envs/envs/grid_world.py:62:31: W0613: Unused argument 'options' (unused-argument)
custom_gym_envs/custom_gym_envs/envs/grid_world.py:84:4: C0116: Missing function or method docstring (missing-function-docstring)
custom_gym_envs/custom_gym_envs/envs/grid_world.py:102:4: C0116: Missing function or method docstring (missing-function-docstring)
custom_gym_envs/custom_gym_envs/envs/grid_world.py:102:4: R1710: Either all return statements in a function should return an expression, or none of them should. (inconsistent-return-statements)
custom_gym_envs/custom_gym_envs/envs/grid_world.py:138:12: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
custom_gym_envs/custom_gym_envs/envs/grid_world.py:106:4: R1710: Either all return statements in a function should return an expression, or none of them should. (inconsistent-return-statements)
custom_gym_envs/custom_gym_envs/envs/grid_world.py:168:4: C0116: Missing function or method docstring (missing-function-docstring)
custom_gym_envs/custom_gym_envs/envs/grid_world.py:67:8: W0201: Attribute '_agent_location' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/grid_world.py:88:8: W0201: Attribute '_agent_location' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/grid_world.py:70:8: W0201: Attribute '_target_location' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/grid_world.py:72:12: W0201: Attribute '_target_location' defined outside __init__ (attribute-defined-outside-init)
************* Module rl-research.custom_gym_envs.custom_gym_envs.envs.leduc_holdem
custom_gym_envs/custom_gym_envs/envs/leduc_holdem.py:1:0: C0114: Missing module docstring (missing-module-docstring)
custom_gym_envs/custom_gym_envs/envs/leduc_holdem.py:136:0: E0401: Unable to import 'gymnasium' (import-error)
custom_gym_envs/custom_gym_envs/envs/leduc_holdem.py:137:0: E0401: Unable to import 'gymnasium' (import-error)
custom_gym_envs/custom_gym_envs/envs/leduc_holdem.py:139:0: E0401: Unable to import 'pygame' (import-error)
custom_gym_envs/custom_gym_envs/envs/leduc_holdem.py:141:0: E0401: Unable to import 'rlcard' (import-error)
custom_gym_envs/custom_gym_envs/envs/leduc_holdem.py:144:0: C0115: Missing class docstring (missing-class-docstring)
custom_gym_envs/custom_gym_envs/envs/leduc_holdem.py:144:0: R0902: Too many instance attributes (17/7) (too-many-instance-attributes)
custom_gym_envs/custom_gym_envs/envs/leduc_holdem.py:183:4: C0116: Missing function or method docstring (missing-function-docstring)
custom_gym_envs/custom_gym_envs/envs/leduc_holdem.py:187:8: W0622: Redefining built-in 'dict' (redefined-builtin)
custom_gym_envs/custom_gym_envs/envs/leduc_holdem.py:183:31: W0613: Unused argument 'options' (unused-argument)
custom_gym_envs/custom_gym_envs/envs/leduc_holdem.py:214:8: W0612: Unused variable 'move_history' (unused-variable)
custom_gym_envs/custom_gym_envs/envs/leduc_holdem.py:223:4: C0116: Missing function or method docstring (missing-function-docstring)
custom_gym_envs/custom_gym_envs/envs/leduc_holdem.py:250:8: W0622: Redefining built-in 'dict' (redefined-builtin)
custom_gym_envs/custom_gym_envs/envs/leduc_holdem.py:226:16: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
custom_gym_envs/custom_gym_envs/envs/leduc_holdem.py:283:8: W0612: Unused variable 'move_history' (unused-variable)
custom_gym_envs/custom_gym_envs/envs/leduc_holdem.py:187:14: W0201: Attribute '_rlcard_current_player' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/leduc_holdem.py:250:14: W0201: Attribute '_rlcard_current_player' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/leduc_holdem.py:189:8: W0201: Attribute '_current_player' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/leduc_holdem.py:255:8: W0201: Attribute '_current_player' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/leduc_holdem.py:190:8: W0201: Attribute '_player_diff' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/leduc_holdem.py:192:8: W0201: Attribute '_rlcard_legal_moves' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/leduc_holdem.py:259:8: W0201: Attribute '_rlcard_legal_moves' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/leduc_holdem.py:197:12: W0201: Attribute '_legal_moves' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/leduc_holdem.py:200:12: W0201: Attribute '_legal_moves' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/leduc_holdem.py:264:12: W0201: Attribute '_legal_moves' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/leduc_holdem.py:267:12: W0201: Attribute '_legal_moves' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/leduc_holdem.py:202:8: W0201: Attribute '_cards' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/leduc_holdem.py:271:8: W0201: Attribute '_cards' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/leduc_holdem.py:204:8: W0201: Attribute '_betting_history' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/leduc_holdem.py:205:8: W0201: Attribute '_num_raises' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/leduc_holdem.py:240:12: W0201: Attribute '_num_raises' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/leduc_holdem.py:206:8: W0201: Attribute '_prev_round_counter' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/leduc_holdem.py:135:0: W0611: Unused I imported from re (unused-import)
custom_gym_envs/custom_gym_envs/envs/leduc_holdem.py:139:0: W0611: Unused import pygame (unused-import)
custom_gym_envs/custom_gym_envs/envs/leduc_holdem.py:140:0: C0411: standard import "import copy" should be placed before "import gymnasium as gym" (wrong-import-order)
************* Module rl-research.custom_gym_envs.custom_gym_envs.envs.mississippi_marbles
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:13:0: C0301: Line too long (214/100) (line-too-long)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:18:0: C0301: Line too long (102/100) (line-too-long)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:20:0: C0301: Line too long (102/100) (line-too-long)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:21:0: C0301: Line too long (102/100) (line-too-long)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:80:0: C0301: Line too long (122/100) (line-too-long)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:92:0: C0301: Line too long (109/100) (line-too-long)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:93:0: C0301: Line too long (109/100) (line-too-long)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:94:0: C0301: Line too long (109/100) (line-too-long)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:95:0: C0301: Line too long (109/100) (line-too-long)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:96:0: C0301: Line too long (109/100) (line-too-long)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:98:0: C0301: Line too long (109/100) (line-too-long)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:99:0: C0301: Line too long (109/100) (line-too-long)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:100:0: C0301: Line too long (109/100) (line-too-long)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:101:0: C0301: Line too long (109/100) (line-too-long)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:102:0: C0301: Line too long (109/100) (line-too-long)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:137:0: C0301: Line too long (108/100) (line-too-long)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:406:0: C0301: Line too long (128/100) (line-too-long)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:422:0: C0301: Line too long (128/100) (line-too-long)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:1:0: C0114: Missing module docstring (missing-module-docstring)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:1:0: E0401: Unable to import 'gymnasium' (import-error)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:2:0: E0401: Unable to import 'gymnasium' (import-error)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:4:0: E0401: Unable to import 'pygame' (import-error)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:8:0: C0115: Missing class docstring (missing-class-docstring)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:8:0: R0902: Too many instance attributes (16/7) (too-many-instance-attributes)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:197:4: C0116: Missing function or method docstring (missing-function-docstring)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:197:31: W0613: Unused argument 'options' (unused-argument)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:229:4: C0116: Missing function or method docstring (missing-function-docstring)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:232:16: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:237:16: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:247:16: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:259:22: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:396:12: R1705: Unnecessary "elif" after "return" (no-else-return)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:229:4: R0912: Too many branches (53/12) (too-many-branches)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:229:4: R0915: Too many statements (130/50) (too-many-statements)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:435:4: C0116: Missing function or method docstring (missing-function-docstring)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:435:4: R1710: Either all return statements in a function should return an expression, or none of them should. (inconsistent-return-statements)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:674:15: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:686:12: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:697:12: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:707:27: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:439:4: R1710: Either all return statements in a function should return an expression, or none of them should. (inconsistent-return-statements)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:439:4: R0915: Too many statements (53/50) (too-many-statements)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:724:4: C0116: Missing function or method docstring (missing-function-docstring)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:202:8: W0201: Attribute '_dice' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:210:8: W0201: Attribute '_dice' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:261:12: W0201: Attribute '_dice' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:270:12: W0201: Attribute '_dice' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:203:8: W0201: Attribute '_dice_remaining' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:334:12: W0201: Attribute '_dice_remaining' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:345:20: W0201: Attribute '_dice_remaining' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:375:16: W0201: Attribute '_dice_remaining' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:204:8: W0201: Attribute '_score_this_turn' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:376:16: W0201: Attribute '_score_this_turn' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:205:8: W0201: Attribute '_score_piggyback' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:255:12: W0201: Attribute '_score_piggyback' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:377:16: W0201: Attribute '_score_piggyback' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:206:8: W0201: Attribute '_score' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:207:8: W0201: Attribute '_current_player' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:253:12: W0201: Attribute '_current_player' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:374:16: W0201: Attribute '_current_player' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:208:8: W0201: Attribute '_can_pass' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:211:8: W0201: Attribute '_can_pass' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:254:12: W0201: Attribute '_can_pass' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:263:12: W0201: Attribute '_can_pass' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:271:12: W0201: Attribute '_can_pass' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:378:16: W0201: Attribute '_can_pass' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:219:8: W0201: Attribute '_legal_moves' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:340:20: W0201: Attribute '_legal_moves' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:342:20: W0201: Attribute '_legal_moves' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:347:16: W0201: Attribute '_legal_moves' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:379:16: W0201: Attribute '_legal_moves' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:385:16: W0201: Attribute '_legal_moves' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:387:16: W0201: Attribute '_legal_moves' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:5:0: W0611: Unused import copy (unused-import)
custom_gym_envs/custom_gym_envs/envs/mississippi_marbles.py:5:0: C0411: standard import "import copy" should be placed before "import gymnasium as gym" (wrong-import-order)
************* Module rl-research.custom_gym_envs.custom_gym_envs.envs.nonstationary_armed_bandits
custom_gym_envs/custom_gym_envs/envs/nonstationary_armed_bandits.py:1:0: C0114: Missing module docstring (missing-module-docstring)
custom_gym_envs/custom_gym_envs/envs/nonstationary_armed_bandits.py:3:0: E0401: Unable to import 'gymnasium' (import-error)
custom_gym_envs/custom_gym_envs/envs/nonstationary_armed_bandits.py:4:0: E0401: Unable to import 'gymnasium' (import-error)
custom_gym_envs/custom_gym_envs/envs/nonstationary_armed_bandits.py:7:0: C0115: Missing class docstring (missing-class-docstring)
custom_gym_envs/custom_gym_envs/envs/nonstationary_armed_bandits.py:7:0: R0902: Too many instance attributes (8/7) (too-many-instance-attributes)
custom_gym_envs/custom_gym_envs/envs/nonstationary_armed_bandits.py:10:4: R0913: Too many arguments (7/5) (too-many-arguments)
custom_gym_envs/custom_gym_envs/envs/nonstationary_armed_bandits.py:31:4: R0201: Method could be a function (no-self-use)
custom_gym_envs/custom_gym_envs/envs/nonstationary_armed_bandits.py:34:4: R0201: Method could be a function (no-self-use)
custom_gym_envs/custom_gym_envs/envs/nonstationary_armed_bandits.py:37:4: C0116: Missing function or method docstring (missing-function-docstring)
custom_gym_envs/custom_gym_envs/envs/nonstationary_armed_bandits.py:37:31: W0613: Unused argument 'options' (unused-argument)
custom_gym_envs/custom_gym_envs/envs/nonstationary_armed_bandits.py:46:4: C0116: Missing function or method docstring (missing-function-docstring)
custom_gym_envs/custom_gym_envs/envs/nonstationary_armed_bandits.py:60:4: C0116: Missing function or method docstring (missing-function-docstring)
custom_gym_envs/custom_gym_envs/envs/nonstationary_armed_bandits.py:66:4: C0116: Missing function or method docstring (missing-function-docstring)
custom_gym_envs/custom_gym_envs/envs/nonstationary_armed_bandits.py:41:8: W0201: Attribute 'current_step' defined outside __init__ (attribute-defined-outside-init)
************* Module rl-research.custom_gym_envs.custom_gym_envs.envs.tictactoe
custom_gym_envs/custom_gym_envs/envs/tictactoe.py:17:0: C0301: Line too long (155/100) (line-too-long)
custom_gym_envs/custom_gym_envs/envs/tictactoe.py:1:0: C0114: Missing module docstring (missing-module-docstring)
custom_gym_envs/custom_gym_envs/envs/tictactoe.py:1:0: E0401: Unable to import 'gymnasium' (import-error)
custom_gym_envs/custom_gym_envs/envs/tictactoe.py:2:0: E0401: Unable to import 'gymnasium' (import-error)
custom_gym_envs/custom_gym_envs/envs/tictactoe.py:4:0: E0401: Unable to import 'pygame' (import-error)
custom_gym_envs/custom_gym_envs/envs/tictactoe.py:8:0: C0115: Missing class docstring (missing-class-docstring)
custom_gym_envs/custom_gym_envs/envs/tictactoe.py:8:0: R0902: Too many instance attributes (13/7) (too-many-instance-attributes)
custom_gym_envs/custom_gym_envs/envs/tictactoe.py:43:8: R1705: Unnecessary "else" after "return" (no-else-return)
custom_gym_envs/custom_gym_envs/envs/tictactoe.py:55:4: C0116: Missing function or method docstring (missing-function-docstring)
custom_gym_envs/custom_gym_envs/envs/tictactoe.py:55:31: W0613: Unused argument 'options' (unused-argument)
custom_gym_envs/custom_gym_envs/envs/tictactoe.py:77:4: C0116: Missing function or method docstring (missing-function-docstring)
custom_gym_envs/custom_gym_envs/envs/tictactoe.py:81:12: W0101: Unreachable code (unreachable)
custom_gym_envs/custom_gym_envs/envs/tictactoe.py:87:18: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
custom_gym_envs/custom_gym_envs/envs/tictactoe.py:133:4: C0116: Missing function or method docstring (missing-function-docstring)
custom_gym_envs/custom_gym_envs/envs/tictactoe.py:133:4: R1710: Either all return statements in a function should return an expression, or none of them should. (inconsistent-return-statements)
custom_gym_envs/custom_gym_envs/envs/tictactoe.py:183:12: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
custom_gym_envs/custom_gym_envs/envs/tictactoe.py:137:4: R1710: Either all return statements in a function should return an expression, or none of them should. (inconsistent-return-statements)
custom_gym_envs/custom_gym_envs/envs/tictactoe.py:213:4: C0116: Missing function or method docstring (missing-function-docstring)
custom_gym_envs/custom_gym_envs/envs/tictactoe.py:218:4: C0116: Missing function or method docstring (missing-function-docstring)
custom_gym_envs/custom_gym_envs/envs/tictactoe.py:226:4: R0911: Too many return statements (7/6) (too-many-return-statements)
custom_gym_envs/custom_gym_envs/envs/tictactoe.py:60:8: W0201: Attribute '_grid' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/tictactoe.py:62:8: W0201: Attribute '_current_player' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/tictactoe.py:113:8: W0201: Attribute '_current_player' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/tictactoe.py:64:8: W0201: Attribute '_step_count' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/tictactoe.py:67:8: W0201: Attribute '_legal_moves' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/tictactoe.py:111:8: W0201: Attribute '_legal_moves' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/tictactoe.py:5:0: C0411: standard import "import copy" should be placed before "import gymnasium as gym" (wrong-import-order)
************* Module rl-research.custom_gym_envs.custom_gym_envs.envs.wardrobe
custom_gym_envs/custom_gym_envs/envs/wardrobe.py:15:0: C0301: Line too long (123/100) (line-too-long)
custom_gym_envs/custom_gym_envs/envs/wardrobe.py:24:0: C0301: Line too long (722/100) (line-too-long)
custom_gym_envs/custom_gym_envs/envs/wardrobe.py:63:0: C0301: Line too long (122/100) (line-too-long)
custom_gym_envs/custom_gym_envs/envs/wardrobe.py:118:0: C0301: Line too long (104/100) (line-too-long)
custom_gym_envs/custom_gym_envs/envs/wardrobe.py:124:0: C0301: Line too long (115/100) (line-too-long)
custom_gym_envs/custom_gym_envs/envs/wardrobe.py:131:0: C0301: Line too long (103/100) (line-too-long)
custom_gym_envs/custom_gym_envs/envs/wardrobe.py:138:0: C0301: Line too long (101/100) (line-too-long)
custom_gym_envs/custom_gym_envs/envs/wardrobe.py:152:0: C0301: Line too long (101/100) (line-too-long)
custom_gym_envs/custom_gym_envs/envs/wardrobe.py:1:0: C0114: Missing module docstring (missing-module-docstring)
custom_gym_envs/custom_gym_envs/envs/wardrobe.py:3:0: E0401: Unable to import 'gymnasium' (import-error)
custom_gym_envs/custom_gym_envs/envs/wardrobe.py:4:0: E0401: Unable to import 'gymnasium' (import-error)
custom_gym_envs/custom_gym_envs/envs/wardrobe.py:7:0: E0401: Unable to import 'pygame' (import-error)
custom_gym_envs/custom_gym_envs/envs/wardrobe.py:11:0: C0115: Missing class docstring (missing-class-docstring)
custom_gym_envs/custom_gym_envs/envs/wardrobe.py:11:0: R0902: Too many instance attributes (10/7) (too-many-instance-attributes)
custom_gym_envs/custom_gym_envs/envs/wardrobe.py:14:23: W0613: Unused argument 'render_mode' (unused-argument)
custom_gym_envs/custom_gym_envs/envs/wardrobe.py:40:8: W0104: Statement seems to have no effect (pointless-statement)
custom_gym_envs/custom_gym_envs/envs/wardrobe.py:31:4: R1711: Useless return at end of function or method (useless-return)
custom_gym_envs/custom_gym_envs/envs/wardrobe.py:43:4: R0201: Method could be a function (no-self-use)
custom_gym_envs/custom_gym_envs/envs/wardrobe.py:46:4: C0116: Missing function or method docstring (missing-function-docstring)
custom_gym_envs/custom_gym_envs/envs/wardrobe.py:54:29: E1120: No value for argument 'b' in method call (no-value-for-parameter)
custom_gym_envs/custom_gym_envs/envs/wardrobe.py:72:8: E1128: Assigning result of a function call, where the function returns None (assignment-from-none)
custom_gym_envs/custom_gym_envs/envs/wardrobe.py:46:31: W0613: Unused argument 'options' (unused-argument)
custom_gym_envs/custom_gym_envs/envs/wardrobe.py:77:4: C0116: Missing function or method docstring (missing-function-docstring)
custom_gym_envs/custom_gym_envs/envs/wardrobe.py:83:12: E1101: Instance of 'TextFileReader' has no 'drop' member (no-member)
custom_gym_envs/custom_gym_envs/envs/wardrobe.py:84:33: E1101: Instance of 'TextFileReader' has no 'iloc' member (no-member)
custom_gym_envs/custom_gym_envs/envs/wardrobe.py:85:16: E1120: No value for argument 'b' in method call (no-value-for-parameter)
custom_gym_envs/custom_gym_envs/envs/wardrobe.py:88:33: E1101: Instance of 'TextFileReader' has no 'iloc' member (no-member)
custom_gym_envs/custom_gym_envs/envs/wardrobe.py:89:16: E1120: No value for argument 'b' in method call (no-value-for-parameter)
custom_gym_envs/custom_gym_envs/envs/wardrobe.py:91:12: W0107: Unnecessary pass statement (unnecessary-pass)
custom_gym_envs/custom_gym_envs/envs/wardrobe.py:101:8: E1128: Assigning result of a function call, where the function returns None (assignment-from-none)
custom_gym_envs/custom_gym_envs/envs/wardrobe.py:108:4: C0116: Missing function or method docstring (missing-function-docstring)
custom_gym_envs/custom_gym_envs/envs/wardrobe.py:111:8: R1705: Unnecessary "else" after "return" (no-else-return)
custom_gym_envs/custom_gym_envs/envs/wardrobe.py:108:4: R0201: Method could be a function (no-self-use)
custom_gym_envs/custom_gym_envs/envs/wardrobe.py:50:8: W0201: Attribute '_wardrobe' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/wardrobe.py:51:8: W0201: Attribute '_current_outfit' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/wardrobe.py:54:8: W0201: Attribute '_current_item' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/wardrobe.py:84:12: W0201: Attribute '_current_item' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/wardrobe.py:88:12: W0201: Attribute '_current_item' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/wardrobe.py:57:8: W0201: Attribute 'number_of_items' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/wardrobe.py:58:8: W0201: Attribute 'steps' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/wardrobe.py:61:8: W0201: Attribute '_desired_formality' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/wardrobe.py:66:8: W0201: Attribute '_temperature_outside' defined outside __init__ (attribute-defined-outside-init)
custom_gym_envs/custom_gym_envs/envs/wardrobe.py:2:0: W0611: Unused check imported from tabnanny (unused-import)
custom_gym_envs/custom_gym_envs/envs/wardrobe.py:7:0: W0611: Unused import pygame (unused-import)
custom_gym_envs/custom_gym_envs/envs/wardrobe.py:8:0: W0611: Unused import copy (unused-import)
custom_gym_envs/custom_gym_envs/envs/wardrobe.py:8:0: C0411: standard import "import copy" should be placed before "import gymnasium as gym" (wrong-import-order)
************* Module rl-research.custom_gym_envs.setup
custom_gym_envs/setup.py:1:0: C0114: Missing module docstring (missing-module-docstring)
************* Module ape_x
dqn/ape_x/__init__.py:1:0: C0114: Missing module docstring (missing-module-docstring)
dqn/ape_x/__init__.py:1:0: E0401: Unable to import 'actor' (import-error)
dqn/ape_x/__init__.py:2:0: E0401: Unable to import 'learner' (import-error)
************* Module ape_x.actor
dqn/ape_x/actor.py:1:0: C0114: Missing module docstring (missing-module-docstring)
dqn/ape_x/actor.py:3:0: E0401: Unable to import 'torch' (import-error)
dqn/ape_x/actor.py:7:0: E0401: Unable to import 'gymnasium' (import-error)
dqn/ape_x/actor.py:9:0: R0402: Use 'from torch.distributed import rpc' instead (consider-using-from-import)
dqn/ape_x/actor.py:9:0: E0401: Unable to import 'torch.distributed.rpc' (import-error)
dqn/ape_x/actor.py:10:0: E0611: No name 'ApeXActorConfig' in module 'agent_configs' (no-name-in-module)
dqn/ape_x/actor.py:11:0: E0611: No name 'plot_graphs' in module 'utils' (no-name-in-module)
dqn/ape_x/actor.py:11:0: E0611: No name 'epsilon_greedy_policy' in module 'utils' (no-name-in-module)
dqn/ape_x/actor.py:18:24: W1309: Using an f-string that does not have any interpolated variables (f-string-without-interpolation)
dqn/ape_x/actor.py:21:0: W0404: Reimport 'sys' (imported line 1) (reimported)
dqn/ape_x/actor.py:21:0: C0413: Import "import sys" should be placed at the top of the module (wrong-import-position)
dqn/ape_x/actor.py:24:0: E0401: Unable to import 'dqn.rainbow.rainbow_agent' (import-error)
dqn/ape_x/actor.py:24:0: C0413: Import "from dqn.rainbow.rainbow_agent import RainbowAgent" should be placed at the top of the module (wrong-import-position)
dqn/ape_x/actor.py:25:0: E0401: Unable to import 'dqn.rainbow.rainbow_network' (import-error)
dqn/ape_x/actor.py:25:0: C0413: Import "from dqn.rainbow.rainbow_network import RainbowNetwork" should be placed at the top of the module (wrong-import-position)
dqn/ape_x/actor.py:26:0: E0401: Unable to import 'base_agent.distributed_agents' (import-error)
dqn/ape_x/actor.py:26:0: C0413: Import "from base_agent.distributed_agents import ActorAgent, DistreteTransition" should be placed at the top of the module (wrong-import-position)
dqn/ape_x/actor.py:27:0: E0401: Unable to import 'replay_buffers.prioritized_n_step_replay_buffer' (import-error)
dqn/ape_x/actor.py:27:0: C0413: Import "from replay_buffers.prioritized_n_step_replay_buffer import PrioritizedNStepReplayBuffer" should be placed at the top of the module (wrong-import-position)
dqn/ape_x/actor.py:28:0: E0401: Unable to import 'replay_buffers.n_step_replay_buffer' (import-error)
dqn/ape_x/actor.py:28:0: C0413: Import "from replay_buffers.n_step_replay_buffer import NStepReplayBuffer" should be placed at the top of the module (wrong-import-position)
dqn/ape_x/actor.py:31:0: C0115: Missing class docstring (missing-class-docstring)
dqn/ape_x/actor.py:56:8: C0103: Attribute name "rb" doesn't conform to snake_case naming style (invalid-name)
dqn/ape_x/actor.py:66:4: C0116: Missing function or method docstring (missing-function-docstring)
dqn/ape_x/actor.py:69:4: C0116: Missing function or method docstring (missing-function-docstring)
dqn/ape_x/actor.py:70:8: C0103: Variable name "t" doesn't conform to snake_case naming style (invalid-name)
dqn/ape_x/actor.py:72:8: C0103: Variable name "p" doesn't conform to snake_case naming style (invalid-name)
dqn/ape_x/actor.py:84:11: C0121: Comparison 'n_step_t != None' should be 'n_step_t is not None' (singleton-comparison)
dqn/ape_x/actor.py:94:4: C0116: Missing function or method docstring (missing-function-docstring)
dqn/ape_x/actor.py:97:4: C0116: Missing function or method docstring (missing-function-docstring)
dqn/ape_x/actor.py:103:0: C0115: Missing class docstring (missing-class-docstring)
dqn/ape_x/actor.py:103:0: R0902: Too many instance attributes (11/7) (too-many-instance-attributes)
dqn/ape_x/actor.py:104:4: R0913: Too many arguments (8/5) (too-many-arguments)
dqn/ape_x/actor.py:133:8: W0622: Redefining built-in 'input' (redefined-builtin)
dqn/ape_x/actor.py:139:4: R0914: Too many local variables (16/15) (too-many-locals)
dqn/ape_x/actor.py:152:8: C0103: Variable name "t" doesn't conform to snake_case naming style (invalid-name)
dqn/ape_x/actor.py:155:8: C0103: Variable name "p" doesn't conform to snake_case naming style (invalid-name)
dqn/ape_x/actor.py:161:11: C0121: Comparison 'n_step_t != None' should be 'n_step_t is not None' (singleton-comparison)
dqn/ape_x/actor.py:177:4: C0116: Missing function or method docstring (missing-function-docstring)
dqn/ape_x/actor.py:187:12: C0103: Variable name "Gt" doesn't conform to snake_case naming style (invalid-name)
dqn/ape_x/actor.py:211:4: C0116: Missing function or method docstring (missing-function-docstring)
dqn/ape_x/actor.py:237:15: W0703: Catching too general exception Exception (broad-except)
dqn/ape_x/actor.py:237:8: C0103: Variable name "e" doesn't conform to snake_case naming style (invalid-name)
dqn/ape_x/actor.py:238:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/actor.py:242:4: C0116: Missing function or method docstring (missing-function-docstring)
dqn/ape_x/actor.py:243:8: C0103: Variable name "ti" doesn't conform to snake_case naming style (invalid-name)
dqn/ape_x/actor.py:255:15: W0703: Catching too general exception Exception (broad-except)
dqn/ape_x/actor.py:255:8: C0103: Variable name "e" doesn't conform to snake_case naming style (invalid-name)
dqn/ape_x/actor.py:256:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/actor.py:258:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/actor.py:261:4: C0116: Missing function or method docstring (missing-function-docstring)
dqn/ape_x/actor.py:272:24: W0612: Unused variable 'info' (unused-variable)
dqn/ape_x/actor.py:274:4: C0116: Missing function or method docstring (missing-function-docstring)
dqn/ape_x/actor.py:293:4: C0116: Missing function or method docstring (missing-function-docstring)
dqn/ape_x/actor.py:298:8: W0702: No exception type(s) specified (bare-except)
dqn/ape_x/actor.py:302:8: W0702: No exception type(s) specified (bare-except)
dqn/ape_x/actor.py:306:8: W0702: No exception type(s) specified (bare-except)
dqn/ape_x/actor.py:272:8: W0201: Attribute 'env_state' defined outside __init__ (attribute-defined-outside-init)
dqn/ape_x/actor.py:5:0: C0411: standard import "from typing import Any" should be placed before "import torch" (wrong-import-order)
dqn/ape_x/actor.py:6:0: C0411: standard import "from uuid import uuid4" should be placed before "import torch" (wrong-import-order)
dqn/ape_x/actor.py:8:0: C0411: standard import "from typing import NamedTuple" should be placed before "import torch" (wrong-import-order)
dqn/ape_x/actor.py:14:0: C0411: standard import "import logging" should be placed before "import torch" (wrong-import-order)
dqn/ape_x/actor.py:21:0: C0411: standard import "import sys" should be placed before "import torch" (wrong-import-order)
dqn/ape_x/actor.py:8:0: C0412: Imports from package typing are not grouped (ungrouped-imports)
dqn/ape_x/actor.py:21:0: C0412: Imports from package sys are not grouped (ungrouped-imports)
dqn/ape_x/actor.py:9:0: C0412: Imports from package torch are not grouped (ungrouped-imports)
************* Module ape_x.config_generator
dqn/ape_x/config_generator.py:52:0: C0301: Line too long (124/100) (line-too-long)
dqn/ape_x/config_generator.py:1:0: C0114: Missing module docstring (missing-module-docstring)
dqn/ape_x/config_generator.py:8:0: E0611: No name 'ApeXActorConfig' in module 'agent_configs' (no-name-in-module)
dqn/ape_x/config_generator.py:8:0: E0611: No name 'ApeXLearnerConfig' in module 'agent_configs' (no-name-in-module)
dqn/ape_x/config_generator.py:11:0: C0116: Missing function or method docstring (missing-function-docstring)
dqn/ape_x/config_generator.py:7:0: W0611: Unused import numpy (unused-import)
************* Module ape_x.hyperopt_local
dqn/ape_x/hyperopt_local.py:86:0: C0301: Line too long (215/100) (line-too-long)
dqn/ape_x/hyperopt_local.py:95:0: C0301: Line too long (104/100) (line-too-long)
dqn/ape_x/hyperopt_local.py:98:0: C0301: Line too long (107/100) (line-too-long)
dqn/ape_x/hyperopt_local.py:103:0: C0301: Line too long (106/100) (line-too-long)
dqn/ape_x/hyperopt_local.py:126:0: C0301: Line too long (133/100) (line-too-long)
dqn/ape_x/hyperopt_local.py:1:0: C0114: Missing module docstring (missing-module-docstring)
dqn/ape_x/hyperopt_local.py:9:0: E0401: Unable to import 'torch' (import-error)
dqn/ape_x/hyperopt_local.py:12:0: E0401: Unable to import 'gymnasium' (import-error)
dqn/ape_x/hyperopt_local.py:13:0: E0401: Unable to import 'hyperopt' (import-error)
dqn/ape_x/hyperopt_local.py:15:0: E0611: No name 'ApeXActorConfig' in module 'agent_configs' (no-name-in-module)
dqn/ape_x/hyperopt_local.py:15:0: E0611: No name 'ApeXLearnerConfig' in module 'agent_configs' (no-name-in-module)
dqn/ape_x/hyperopt_local.py:16:0: E0611: No name 'cartpole_config' in module 'game_configs' (no-name-in-module)
dqn/ape_x/hyperopt_local.py:16:0: E0401: Unable to import 'game_configs.cartpole_config' (import-error)
dqn/ape_x/hyperopt_local.py:17:0: E0401: Unable to import 'learner' (import-error)
dqn/ape_x/hyperopt_local.py:21:0: C0116: Missing function or method docstring (missing-function-docstring)
dqn/ape_x/hyperopt_local.py:22:4: C0103: Constant name "stop_chan" doesn't conform to UPPER_CASE naming style (invalid-name)
dqn/ape_x/hyperopt_local.py:22:4: W0602: Using global for 'stop_chan' but no assignment is done (global-variable-not-assigned)
dqn/ape_x/hyperopt_local.py:23:4: E0602: Undefined variable 'stop_chan' (undefined-variable)
dqn/ape_x/hyperopt_local.py:26:0: C0413: Import "import logging" should be placed at the top of the module (wrong-import-position)
dqn/ape_x/hyperopt_local.py:44:0: C0116: Missing function or method docstring (missing-function-docstring)
dqn/ape_x/hyperopt_local.py:44:0: R0914: Too many local variables (25/15) (too-many-locals)
dqn/ape_x/hyperopt_local.py:89:10: W1510: Using subprocess.run without explicitly set `check` is not recommended. (subprocess-run-check)
dqn/ape_x/hyperopt_local.py:90:4: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/hyperopt_local.py:91:4: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/hyperopt_local.py:121:11: W0703: Catching too general exception Exception (broad-except)
dqn/ape_x/hyperopt_local.py:104:31: R1732: Consider using 'with' for resource-allocating operations (consider-using-with)
dqn/ape_x/hyperopt_local.py:121:4: C0103: Variable name "e" doesn't conform to snake_case naming style (invalid-name)
dqn/ape_x/hyperopt_local.py:122:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/hyperopt_local.py:96:22: R1732: Consider using 'with' for resource-allocating operations (consider-using-with)
dqn/ape_x/hyperopt_local.py:99:23: R1732: Consider using 'with' for resource-allocating operations (consider-using-with)
dqn/ape_x/hyperopt_local.py:44:0: R0915: Too many statements (54/50) (too-many-statements)
dqn/ape_x/hyperopt_local.py:142:0: C0116: Missing function or method docstring (missing-function-docstring)
dqn/ape_x/hyperopt_local.py:143:4: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/hyperopt_local.py:152:29: R1732: Consider using 'with' for resource-allocating operations (consider-using-with)
dqn/ape_x/hyperopt_local.py:153:15: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
dqn/ape_x/hyperopt_local.py:174:4: C0103: Variable name "e" doesn't conform to snake_case naming style (invalid-name)
dqn/ape_x/hyperopt_local.py:176:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/hyperopt_local.py:180:20: R1734: Consider using [] instead of list() (use-list-literal)
dqn/ape_x/hyperopt_local.py:183:12: R1705: Unnecessary "else" after "return" (no-else-return)
dqn/ape_x/hyperopt_local.py:188:10: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
dqn/ape_x/hyperopt_local.py:192:0: E0401: Unable to import 'hyperopt.pyll.base' (import-error)
dqn/ape_x/hyperopt_local.py:192:0: C0413: Import "from hyperopt.pyll.base import scope" should be placed at the top of the module (wrong-import-position)
dqn/ape_x/hyperopt_local.py:193:0: C0413: Import "import math" should be placed at the top of the module (wrong-import-position)
dqn/ape_x/hyperopt_local.py:196:0: C0116: Missing function or method docstring (missing-function-docstring)
dqn/ape_x/hyperopt_local.py:222:13: E1101: Module 'utils' has no 'CategoricalCrossentropyLoss' member (no-member)
dqn/ape_x/hyperopt_local.py:268:0: C0116: Missing function or method docstring (missing-function-docstring)
dqn/ape_x/hyperopt_local.py:280:4: W0702: No exception type(s) specified (bare-except)
dqn/ape_x/hyperopt_local.py:274:29: R1732: Consider using 'with' for resource-allocating operations (consider-using-with)
dqn/ape_x/hyperopt_local.py:277:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/hyperopt_local.py:297:4: W0612: Unused variable 'best_trial' (unused-variable)
dqn/ape_x/hyperopt_local.py:6:0: W0611: Unused import time (unused-import)
dqn/ape_x/hyperopt_local.py:9:0: W0611: Unused import torch (unused-import)
dqn/ape_x/hyperopt_local.py:26:0: C0411: standard import "import logging" should be placed before "import torch" (wrong-import-order)
dqn/ape_x/hyperopt_local.py:193:0: C0411: standard import "import math" should be placed before "import torch" (wrong-import-order)
dqn/ape_x/hyperopt_local.py:192:0: C0412: Imports from package hyperopt are not grouped (ungrouped-imports)
************* Module ape_x.hyperparameter_optimization
dqn/ape_x/hyperparameter_optimization.py:100:0: C0301: Line too long (131/100) (line-too-long)
dqn/ape_x/hyperparameter_optimization.py:108:0: C0301: Line too long (281/100) (line-too-long)
dqn/ape_x/hyperparameter_optimization.py:114:0: C0301: Line too long (127/100) (line-too-long)
dqn/ape_x/hyperparameter_optimization.py:135:0: C0301: Line too long (133/100) (line-too-long)
dqn/ape_x/hyperparameter_optimization.py:1:0: C0114: Missing module docstring (missing-module-docstring)
dqn/ape_x/hyperparameter_optimization.py:11:0: E0401: Unable to import 'gymnasium' (import-error)
dqn/ape_x/hyperparameter_optimization.py:12:0: E0401: Unable to import 'hyperopt' (import-error)
dqn/ape_x/hyperparameter_optimization.py:14:0: E0611: No name 'ApeXActorConfig' in module 'agent_configs' (no-name-in-module)
dqn/ape_x/hyperparameter_optimization.py:14:0: E0611: No name 'ApeXLearnerConfig' in module 'agent_configs' (no-name-in-module)
dqn/ape_x/hyperparameter_optimization.py:15:0: E0611: No name 'cartpole_config' in module 'game_configs' (no-name-in-module)
dqn/ape_x/hyperparameter_optimization.py:15:0: E0401: Unable to import 'game_configs.cartpole_config' (import-error)
dqn/ape_x/hyperparameter_optimization.py:16:0: E0401: Unable to import 'learner' (import-error)
dqn/ape_x/hyperparameter_optimization.py:21:0: C0116: Missing function or method docstring (missing-function-docstring)
dqn/ape_x/hyperparameter_optimization.py:22:4: C0103: Constant name "stop_chan" doesn't conform to UPPER_CASE naming style (invalid-name)
dqn/ape_x/hyperparameter_optimization.py:22:4: W0602: Using global for 'stop_chan' but no assignment is done (global-variable-not-assigned)
dqn/ape_x/hyperparameter_optimization.py:23:4: E0602: Undefined variable 'stop_chan' (undefined-variable)
dqn/ape_x/hyperparameter_optimization.py:26:0: C0413: Import "import logging" should be placed at the top of the module (wrong-import-position)
dqn/ape_x/hyperparameter_optimization.py:44:0: C0116: Missing function or method docstring (missing-function-docstring)
dqn/ape_x/hyperparameter_optimization.py:46:4: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/hyperparameter_optimization.py:55:0: C0116: Missing function or method docstring (missing-function-docstring)
dqn/ape_x/hyperparameter_optimization.py:55:0: R0914: Too many local variables (24/15) (too-many-locals)
dqn/ape_x/hyperparameter_optimization.py:56:4: W0602: Using global for 'SSH_USERNAME' but no assignment is done (global-variable-not-assigned)
dqn/ape_x/hyperparameter_optimization.py:102:11: W1510: Using subprocess.run without explicitly set `check` is not recommended. (subprocess-run-check)
dqn/ape_x/hyperparameter_optimization.py:110:10: W1510: Using subprocess.run without explicitly set `check` is not recommended. (subprocess-run-check)
dqn/ape_x/hyperparameter_optimization.py:111:4: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/hyperparameter_optimization.py:112:4: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/hyperparameter_optimization.py:130:11: W0703: Catching too general exception Exception (broad-except)
dqn/ape_x/hyperparameter_optimization.py:130:4: C0103: Variable name "e" doesn't conform to snake_case naming style (invalid-name)
dqn/ape_x/hyperparameter_optimization.py:131:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/hyperparameter_optimization.py:138:14: C0121: Comparison 'go_proc.poll() == None' should be 'go_proc.poll() is None' (singleton-comparison)
dqn/ape_x/hyperparameter_optimization.py:116:18: R1732: Consider using 'with' for resource-allocating operations (consider-using-with)
dqn/ape_x/hyperparameter_optimization.py:55:0: R0915: Too many statements (52/50) (too-many-statements)
dqn/ape_x/hyperparameter_optimization.py:144:0: C0116: Missing function or method docstring (missing-function-docstring)
dqn/ape_x/hyperparameter_optimization.py:145:4: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/hyperparameter_optimization.py:154:29: R1732: Consider using 'with' for resource-allocating operations (consider-using-with)
dqn/ape_x/hyperparameter_optimization.py:155:15: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
dqn/ape_x/hyperparameter_optimization.py:176:4: C0103: Variable name "e" doesn't conform to snake_case naming style (invalid-name)
dqn/ape_x/hyperparameter_optimization.py:178:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/hyperparameter_optimization.py:182:20: R1734: Consider using [] instead of list() (use-list-literal)
dqn/ape_x/hyperparameter_optimization.py:185:12: R1705: Unnecessary "else" after "return" (no-else-return)
dqn/ape_x/hyperparameter_optimization.py:190:10: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
dqn/ape_x/hyperparameter_optimization.py:194:0: E0401: Unable to import 'hyperopt.pyll.base' (import-error)
dqn/ape_x/hyperparameter_optimization.py:194:0: C0413: Import "from hyperopt.pyll.base import scope" should be placed at the top of the module (wrong-import-position)
dqn/ape_x/hyperparameter_optimization.py:195:0: C0413: Import "import math" should be placed at the top of the module (wrong-import-position)
dqn/ape_x/hyperparameter_optimization.py:198:0: C0116: Missing function or method docstring (missing-function-docstring)
dqn/ape_x/hyperparameter_optimization.py:224:13: E1101: Module 'utils' has no 'CategoricalCrossentropyLoss' member (no-member)
dqn/ape_x/hyperparameter_optimization.py:271:0: C0116: Missing function or method docstring (missing-function-docstring)
dqn/ape_x/hyperparameter_optimization.py:272:4: W0603: Using the global statement (global-statement)
dqn/ape_x/hyperparameter_optimization.py:290:4: W0702: No exception type(s) specified (bare-except)
dqn/ape_x/hyperparameter_optimization.py:284:29: R1732: Consider using 'with' for resource-allocating operations (consider-using-with)
dqn/ape_x/hyperparameter_optimization.py:287:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/hyperparameter_optimization.py:307:4: W0612: Unused variable 'best_trial' (unused-variable)
dqn/ape_x/hyperparameter_optimization.py:26:0: C0411: standard import "import logging" should be placed before "import numpy as np" (wrong-import-order)
dqn/ape_x/hyperparameter_optimization.py:195:0: C0411: standard import "import math" should be placed before "import numpy as np" (wrong-import-order)
dqn/ape_x/hyperparameter_optimization.py:194:0: C0412: Imports from package hyperopt are not grouped (ungrouped-imports)
************* Module ape_x.learner
dqn/ape_x/learner.py:322:9: W0511: TODO - send a copy of the replay buffer state to the remote replay server (fixme)
dqn/ape_x/learner.py:326:9: W0511: TODO - async (fixme)
dqn/ape_x/learner.py:185:0: C0301: Line too long (138/100) (line-too-long)
dqn/ape_x/learner.py:189:0: C0301: Line too long (145/100) (line-too-long)
dqn/ape_x/learner.py:241:0: C0301: Line too long (113/100) (line-too-long)
dqn/ape_x/learner.py:1:0: C0114: Missing module docstring (missing-module-docstring)
dqn/ape_x/learner.py:5:0: E0401: Unable to import 'torch' (import-error)
dqn/ape_x/learner.py:12:0: E0401: Unable to import 'torch.distributed' (import-error)
dqn/ape_x/learner.py:13:0: E0401: Unable to import 'actor' (import-error)
dqn/ape_x/learner.py:15:0: E0611: No name 'update_per_beta' in module 'utils' (no-name-in-module)
dqn/ape_x/learner.py:16:0: R0402: Use 'from torch.distributed import rpc' instead (consider-using-from-import)
dqn/ape_x/learner.py:16:0: E0401: Unable to import 'torch.distributed.rpc' (import-error)
dqn/ape_x/learner.py:17:0: E0401: Unable to import 'torch.nn.utils' (import-error)
dqn/ape_x/learner.py:18:0: E0611: No name 'ApeXLearnerConfig' in module 'agent_configs' (no-name-in-module)
dqn/ape_x/learner.py:19:0: E0611: No name 'ApexLearnerStoppingCriteria' in module 'utils' (no-name-in-module)
dqn/ape_x/learner.py:25:0: C0116: Missing function or method docstring (missing-function-docstring)
dqn/ape_x/learner.py:26:4: C0103: Constant name "stop_chan" doesn't conform to UPPER_CASE naming style (invalid-name)
dqn/ape_x/learner.py:26:4: W0602: Using global for 'stop_chan' but no assignment is done (global-variable-not-assigned)
dqn/ape_x/learner.py:27:4: E0602: Undefined variable 'stop_chan' (undefined-variable)
dqn/ape_x/learner.py:31:0: E0401: Unable to import 'dqn.rainbow.rainbow_agent' (import-error)
dqn/ape_x/learner.py:31:0: C0413: Import "from dqn.rainbow.rainbow_agent import RainbowAgent" should be placed at the top of the module (wrong-import-position)
dqn/ape_x/learner.py:32:0: E0401: Unable to import 'replay_buffers.prioritized_n_step_replay_buffer' (import-error)
dqn/ape_x/learner.py:32:0: C0413: Import "from replay_buffers.prioritized_n_step_replay_buffer import PrioritizedNStepReplayBuffer" should be placed at the top of the module (wrong-import-position)
dqn/ape_x/learner.py:33:0: E0401: Unable to import 'dqn.rainbow.rainbow_network' (import-error)
dqn/ape_x/learner.py:33:0: C0413: Import "from dqn.rainbow.rainbow_network import RainbowNetwork" should be placed at the top of the module (wrong-import-position)
dqn/ape_x/learner.py:39:0: C0115: Missing class docstring (missing-class-docstring)
dqn/ape_x/learner.py:45:0: C0115: Missing class docstring (missing-class-docstring)
dqn/ape_x/learner.py:45:0: R0902: Too many instance attributes (8/7) (too-many-instance-attributes)
dqn/ape_x/learner.py:73:4: C0116: Missing function or method docstring (missing-function-docstring)
dqn/ape_x/learner.py:76:4: C0116: Missing function or method docstring (missing-function-docstring)
dqn/ape_x/learner.py:80:4: C0116: Missing function or method docstring (missing-function-docstring)
dqn/ape_x/learner.py:83:4: C0116: Missing function or method docstring (missing-function-docstring)
dqn/ape_x/learner.py:86:4: C0116: Missing function or method docstring (missing-function-docstring)
dqn/ape_x/learner.py:89:4: C0116: Missing function or method docstring (missing-function-docstring)
dqn/ape_x/learner.py:90:8: C0103: Variable name "ti" doesn't conform to snake_case naming style (invalid-name)
dqn/ape_x/learner.py:93:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/learner.py:96:4: C0116: Missing function or method docstring (missing-function-docstring)
dqn/ape_x/learner.py:136:15: W0703: Catching too general exception Exception (broad-except)
dqn/ape_x/learner.py:103:12: E1101: Instance of 'ApeXLearnerBase' has no 'training_steps' member (no-member)
dqn/ape_x/learner.py:104:65: E1101: Instance of 'ApeXLearnerBase' has no 'training_steps' member (no-member)
dqn/ape_x/learner.py:105:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/learner.py:106:62: E1101: Instance of 'ApeXLearnerBase' has no 'training_steps' member (no-member)
dqn/ape_x/learner.py:114:20: E1120: No value for argument 'weights' in method call (no-value-for-parameter)
dqn/ape_x/learner.py:136:8: C0103: Variable name "e" doesn't conform to snake_case naming style (invalid-name)
dqn/ape_x/learner.py:137:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/learner.py:144:0: C0115: Missing class docstring (missing-class-docstring)
dqn/ape_x/learner.py:144:0: R0902: Too many instance attributes (17/7) (too-many-instance-attributes)
dqn/ape_x/learner.py:235:15: W0703: Catching too general exception Exception (broad-except)
dqn/ape_x/learner.py:235:8: C0103: Variable name "e" doesn't conform to snake_case naming style (invalid-name)
dqn/ape_x/learner.py:237:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/learner.py:244:12: E0702: Raising str while only classes or instances are allowed (raising-bad-type)
dqn/ape_x/learner.py:281:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/learner.py:291:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/learner.py:299:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/learner.py:303:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/learner.py:306:22: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/learner.py:314:15: W0703: Catching too general exception Exception (broad-except)
dqn/ape_x/learner.py:313:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/learner.py:314:8: C0103: Variable name "e" doesn't conform to snake_case naming style (invalid-name)
dqn/ape_x/learner.py:315:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/learner.py:310:4: R0201: Method could be a function (no-self-use)
dqn/ape_x/learner.py:317:4: C0116: Missing function or method docstring (missing-function-docstring)
dqn/ape_x/learner.py:320:4: C0116: Missing function or method docstring (missing-function-docstring)
dqn/ape_x/learner.py:325:4: W0221: Number of parameters was 2 in 'ApeXLearnerBase.store_weights' and is now 1 in overridden 'ApeXLearner.store_weights' method (arguments-differ)
dqn/ape_x/learner.py:329:8: C0103: Variable name "t" doesn't conform to snake_case naming style (invalid-name)
dqn/ape_x/learner.py:347:19: W0703: Catching too general exception Exception (broad-except)
dqn/ape_x/learner.py:335:30: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/learner.py:342:30: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/learner.py:347:12: C0103: Variable name "e" doesn't conform to snake_case naming style (invalid-name)
dqn/ape_x/learner.py:348:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/learner.py:352:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/learner.py:355:8: C0103: Variable name "t" doesn't conform to snake_case naming style (invalid-name)
dqn/ape_x/learner.py:356:8: C0103: Variable name "u" doesn't conform to snake_case naming style (invalid-name)
dqn/ape_x/learner.py:367:15: W0703: Catching too general exception Exception (broad-except)
dqn/ape_x/learner.py:363:26: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/learner.py:367:8: C0103: Variable name "e" doesn't conform to snake_case naming style (invalid-name)
dqn/ape_x/learner.py:368:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/learner.py:381:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/learner.py:383:26: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/learner.py:383:41: W0640: Cell variable actor defined in loop (cell-var-from-loop)
dqn/ape_x/learner.py:390:12: W0702: No exception type(s) specified (bare-except)
dqn/ape_x/learner.py:424:8: W0212: Access to a protected member _barrier of a client class (protected-access)
dqn/ape_x/learner.py:429:15: W0703: Catching too general exception Exception (broad-except)
dqn/ape_x/learner.py:429:8: C0103: Variable name "e" doesn't conform to snake_case naming style (invalid-name)
dqn/ape_x/learner.py:430:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/learner.py:434:15: W0703: Catching too general exception Exception (broad-except)
dqn/ape_x/learner.py:434:8: C0103: Variable name "e" doesn't conform to snake_case naming style (invalid-name)
dqn/ape_x/learner.py:435:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/learner.py:438:8: C0103: Variable name "t" doesn't conform to snake_case naming style (invalid-name)
dqn/ape_x/learner.py:445:12: E1101: Instance of 'ApeXLearner' has no 'training_steps' member (no-member)
dqn/ape_x/learner.py:449:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/learner.py:454:15: W0703: Catching too general exception Exception (broad-except)
dqn/ape_x/learner.py:454:8: C0103: Variable name "e" doesn't conform to snake_case naming style (invalid-name)
dqn/ape_x/learner.py:455:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/learner.py:465:15: C0121: Comparison 'sample == None' should be 'sample is None' (singleton-comparison)
dqn/ape_x/learner.py:483:19: W0703: Catching too general exception Exception (broad-except)
dqn/ape_x/learner.py:483:12: C0103: Variable name "e" doesn't conform to snake_case naming style (invalid-name)
dqn/ape_x/learner.py:484:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/learner.py:460:12: W0612: Unused variable 'i' (unused-variable)
dqn/ape_x/learner.py:488:4: C0116: Missing function or method docstring (missing-function-docstring)
dqn/ape_x/learner.py:510:8: C0103: Variable name "Gt" doesn't conform to snake_case naming style (invalid-name)
dqn/ape_x/learner.py:318:8: W0201: Attribute 'replay_buffer' defined outside __init__ (attribute-defined-outside-init)
dqn/ape_x/learner.py:371:8: W0201: Attribute 'flag' defined outside __init__ (attribute-defined-outside-init)
dqn/ape_x/learner.py:373:8: W0201: Attribute 'replay_thread' defined outside __init__ (attribute-defined-outside-init)
dqn/ape_x/learner.py:6:0: C0411: standard import "import queue" should be placed before "import torch" (wrong-import-order)
dqn/ape_x/learner.py:7:0: C0411: standard import "import socket" should be placed before "import torch" (wrong-import-order)
dqn/ape_x/learner.py:8:0: C0411: standard import "import logging" should be placed before "import torch" (wrong-import-order)
dqn/ape_x/learner.py:9:0: C0411: standard import "import threading" should be placed before "import torch" (wrong-import-order)
dqn/ape_x/learner.py:14:0: C0411: standard import "from typing import NamedTuple" should be placed before "import torch" (wrong-import-order)
dqn/ape_x/learner.py:12:0: C0412: Imports from package torch are not grouped (ungrouped-imports)
dqn/ape_x/learner.py:16:0: C0412: Imports from package torch are not grouped (ungrouped-imports)
dqn/ape_x/learner.py:19:0: C0412: Imports from package utils are not grouped (ungrouped-imports)
dqn/ape_x/learner.py:33:0: C0412: Imports from package dqn are not grouped (ungrouped-imports)
************* Module ape_x.main_learner
dqn/ape_x/main_learner.py:1:0: C0114: Missing module docstring (missing-module-docstring)
dqn/ape_x/main_learner.py:1:0: E0611: No name 'ApeXLearnerConfig' in module 'agent_configs' (no-name-in-module)
dqn/ape_x/main_learner.py:2:0: E0401: Unable to import 'learner' (import-error)
dqn/ape_x/main_learner.py:3:0: E0401: Unable to import 'gymnasium' (import-error)
dqn/ape_x/main_learner.py:24:0: C0116: Missing function or method docstring (missing-function-docstring)
dqn/ape_x/main_learner.py:29:0: C0116: Missing function or method docstring (missing-function-docstring)
dqn/ape_x/main_learner.py:30:4: C0103: Constant name "stop_chan" doesn't conform to UPPER_CASE naming style (invalid-name)
dqn/ape_x/main_learner.py:30:4: W0602: Using global for 'stop_chan' but no assignment is done (global-variable-not-assigned)
dqn/ape_x/main_learner.py:31:4: E0602: Undefined variable 'stop_chan' (undefined-variable)
dqn/ape_x/main_learner.py:34:0: C0116: Missing function or method docstring (missing-function-docstring)
dqn/ape_x/main_learner.py:4:0: C0411: standard import "import argparse" should be placed before "from agent_configs import ApeXLearnerConfig" (wrong-import-order)
dqn/ape_x/main_learner.py:6:0: C0411: standard import "import logging" should be placed before "from agent_configs import ApeXLearnerConfig" (wrong-import-order)
************* Module ape_x.remote_worker
dqn/ape_x/remote_worker.py:62:0: C0301: Line too long (183/100) (line-too-long)
dqn/ape_x/remote_worker.py:105:0: C0303: Trailing whitespace (trailing-whitespace)
dqn/ape_x/remote_worker.py:111:0: C0303: Trailing whitespace (trailing-whitespace)
dqn/ape_x/remote_worker.py:113:0: C0303: Trailing whitespace (trailing-whitespace)
dqn/ape_x/remote_worker.py:1:0: C0114: Missing module docstring (missing-module-docstring)
dqn/ape_x/remote_worker.py:5:0: E0401: Unable to import 'torch' (import-error)
dqn/ape_x/remote_worker.py:9:0: E0401: Unable to import 'torch.distributed' (import-error)
dqn/ape_x/remote_worker.py:10:0: R0402: Use 'from torch.distributed import rpc' instead (consider-using-from-import)
dqn/ape_x/remote_worker.py:10:0: E0401: Unable to import 'torch.distributed.rpc' (import-error)
dqn/ape_x/remote_worker.py:16:0: C0116: Missing function or method docstring (missing-function-docstring)
dqn/ape_x/remote_worker.py:17:4: C0103: Constant name "stop_chan" doesn't conform to UPPER_CASE naming style (invalid-name)
dqn/ape_x/remote_worker.py:17:4: W0602: Using global for 'stop_chan' but no assignment is done (global-variable-not-assigned)
dqn/ape_x/remote_worker.py:22:0: E0401: Unable to import 'dqn' (import-error)
dqn/ape_x/remote_worker.py:22:0: C0413: Import "import dqn" should be placed at the top of the module (wrong-import-position)
dqn/ape_x/remote_worker.py:23:0: E0401: Unable to import 'dqn.rainbow' (import-error)
dqn/ape_x/remote_worker.py:23:0: C0413: Import "import dqn.rainbow" should be placed at the top of the module (wrong-import-position)
dqn/ape_x/remote_worker.py:24:0: E0401: Unable to import 'dqn.ape_x' (import-error)
dqn/ape_x/remote_worker.py:24:0: C0413: Import "import dqn.ape_x" should be placed at the top of the module (wrong-import-position)
dqn/ape_x/remote_worker.py:25:0: E0401: Unable to import 'replay_buffers' (import-error)
dqn/ape_x/remote_worker.py:25:0: C0413: Import "import replay_buffers" should be placed at the top of the module (wrong-import-position)
dqn/ape_x/remote_worker.py:26:0: E0401: Unable to import 'replay_buffers.prioritized_n_step_replay_buffer' (import-error)
dqn/ape_x/remote_worker.py:26:0: C0413: Import "import replay_buffers.prioritized_n_step_replay_buffer" should be placed at the top of the module (wrong-import-position)
dqn/ape_x/remote_worker.py:39:0: C0116: Missing function or method docstring (missing-function-docstring)
dqn/ape_x/remote_worker.py:61:4: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/remote_worker.py:65:4: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/remote_worker.py:79:4: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/remote_worker.py:87:11: W0703: Catching too general exception Exception (broad-except)
dqn/ape_x/remote_worker.py:87:4: C0103: Variable name "e" doesn't conform to snake_case naming style (invalid-name)
dqn/ape_x/remote_worker.py:88:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/remote_worker.py:89:4: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/remote_worker.py:97:4: W0212: Access to a protected member _barrier of a client class (protected-access)
dqn/ape_x/remote_worker.py:99:4: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/remote_worker.py:103:11: W0703: Catching too general exception Exception (broad-except)
dqn/ape_x/remote_worker.py:103:4: C0103: Variable name "e" doesn't conform to snake_case naming style (invalid-name)
dqn/ape_x/remote_worker.py:104:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/remote_worker.py:109:11: W0703: Catching too general exception Exception (broad-except)
dqn/ape_x/remote_worker.py:107:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/remote_worker.py:109:4: C0103: Variable name "e" doesn't conform to snake_case naming style (invalid-name)
dqn/ape_x/remote_worker.py:110:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/remote_worker.py:22:0: W0611: Unused import dqn (unused-import)
dqn/ape_x/remote_worker.py:23:0: W0611: Unused import dqn.rainbow (unused-import)
dqn/ape_x/remote_worker.py:24:0: W0611: Unused import dqn.ape_x (unused-import)
dqn/ape_x/remote_worker.py:25:0: W0611: Unused import replay_buffers (unused-import)
dqn/ape_x/remote_worker.py:26:0: W0611: Unused import replay_buffers.prioritized_n_step_replay_buffer (unused-import)
dqn/ape_x/remote_worker.py:6:0: C0411: standard import "import queue" should be placed before "import torch" (wrong-import-order)
dqn/ape_x/remote_worker.py:7:0: C0411: standard import "import logging" should be placed before "import torch" (wrong-import-order)
dqn/ape_x/remote_worker.py:8:0: C0411: standard import "import argparse" should be placed before "import torch" (wrong-import-order)
************* Module A
dqn/ape_x/rpc_testing/A.py:1:0: C0103: Module name "A" doesn't conform to snake_case naming style (invalid-name)
dqn/ape_x/rpc_testing/A.py:1:0: C0114: Missing module docstring (missing-module-docstring)
dqn/ape_x/rpc_testing/A.py:5:0: R0402: Use 'from torch.distributed import rpc' instead (consider-using-from-import)
dqn/ape_x/rpc_testing/A.py:5:0: E0401: Unable to import 'torch.distributed.rpc' (import-error)
dqn/ape_x/rpc_testing/A.py:18:0: C0116: Missing function or method docstring (missing-function-docstring)
dqn/ape_x/rpc_testing/A.py:19:4: C0103: Constant name "stop_chan" doesn't conform to UPPER_CASE naming style (invalid-name)
dqn/ape_x/rpc_testing/A.py:19:4: W0602: Using global for 'stop_chan' but no assignment is done (global-variable-not-assigned)
dqn/ape_x/rpc_testing/A.py:20:4: E0602: Undefined variable 'stop_chan' (undefined-variable)
dqn/ape_x/rpc_testing/A.py:23:0: C0116: Missing function or method docstring (missing-function-docstring)
dqn/ape_x/rpc_testing/A.py:24:4: C0103: Variable name "l" doesn't conform to snake_case naming style (invalid-name)
dqn/ape_x/rpc_testing/A.py:33:11: W0703: Catching too general exception Exception (broad-except)
dqn/ape_x/rpc_testing/A.py:33:4: C0103: Variable name "e" doesn't conform to snake_case naming style (invalid-name)
dqn/ape_x/rpc_testing/A.py:34:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/rpc_testing/A.py:1:0: W0611: Unused import time (unused-import)
dqn/ape_x/rpc_testing/A.py:3:0: W0611: Unused import pathlib (unused-import)
dqn/ape_x/rpc_testing/A.py:4:0: W0611: Unused import argparse (unused-import)
************* Module B
dqn/ape_x/rpc_testing/B.py:1:0: C0103: Module name "B" doesn't conform to snake_case naming style (invalid-name)
dqn/ape_x/rpc_testing/B.py:1:0: C0114: Missing module docstring (missing-module-docstring)
dqn/ape_x/rpc_testing/B.py:6:0: E0401: Unable to import 'torch' (import-error)
dqn/ape_x/rpc_testing/B.py:11:0: E0401: Unable to import 'torch.distributed' (import-error)
dqn/ape_x/rpc_testing/B.py:12:0: R0402: Use 'from torch.distributed import rpc' instead (consider-using-from-import)
dqn/ape_x/rpc_testing/B.py:12:0: E0401: Unable to import 'torch.distributed.rpc' (import-error)
dqn/ape_x/rpc_testing/B.py:18:0: C0116: Missing function or method docstring (missing-function-docstring)
dqn/ape_x/rpc_testing/B.py:19:4: C0103: Constant name "stop_chan" doesn't conform to UPPER_CASE naming style (invalid-name)
dqn/ape_x/rpc_testing/B.py:19:4: W0602: Using global for 'stop_chan' but no assignment is done (global-variable-not-assigned)
dqn/ape_x/rpc_testing/B.py:39:0: C0116: Missing function or method docstring (missing-function-docstring)
dqn/ape_x/rpc_testing/B.py:49:4: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/rpc_testing/B.py:67:11: W0703: Catching too general exception Exception (broad-except)
dqn/ape_x/rpc_testing/B.py:67:4: C0103: Variable name "e" doesn't conform to snake_case naming style (invalid-name)
dqn/ape_x/rpc_testing/B.py:68:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/rpc_testing/B.py:69:4: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/rpc_testing/B.py:78:4: C0415: Import outside toplevel (gc) (import-outside-toplevel)
dqn/ape_x/rpc_testing/B.py:81:4: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/rpc_testing/B.py:85:11: W0703: Catching too general exception Exception (broad-except)
dqn/ape_x/rpc_testing/B.py:85:4: C0103: Variable name "e" doesn't conform to snake_case naming style (invalid-name)
dqn/ape_x/rpc_testing/B.py:86:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/rpc_testing/B.py:2:0: W0611: Unused import os (unused-import)
dqn/ape_x/rpc_testing/B.py:3:0: W0611: Unused import sys (unused-import)
dqn/ape_x/rpc_testing/B.py:4:0: W0611: Unused import classes (unused-import)
dqn/ape_x/rpc_testing/B.py:6:0: W0611: Unused import torch (unused-import)
dqn/ape_x/rpc_testing/B.py:11:0: W0611: Unused import torch.distributed (unused-import)
dqn/ape_x/rpc_testing/B.py:5:0: C0411: standard import "import time" should be placed before "import classes" (wrong-import-order)
dqn/ape_x/rpc_testing/B.py:7:0: C0411: standard import "import queue" should be placed before "import classes" (wrong-import-order)
dqn/ape_x/rpc_testing/B.py:8:0: C0411: standard import "import pathlib" should be placed before "import classes" (wrong-import-order)
dqn/ape_x/rpc_testing/B.py:9:0: C0411: standard import "import logging" should be placed before "import classes" (wrong-import-order)
dqn/ape_x/rpc_testing/B.py:10:0: C0411: standard import "import argparse" should be placed before "import classes" (wrong-import-order)
************* Module classes
dqn/ape_x/rpc_testing/classes.py:186:9: W0511: TODO - async (fixme)
dqn/ape_x/rpc_testing/classes.py:313:0: C0303: Trailing whitespace (trailing-whitespace)
dqn/ape_x/rpc_testing/classes.py:350:0: C0304: Final newline missing (missing-final-newline)
dqn/ape_x/rpc_testing/classes.py:1:0: C0114: Missing module docstring (missing-module-docstring)
dqn/ape_x/rpc_testing/classes.py:1:0: R0402: Use 'from torch.distributed import rpc' instead (consider-using-from-import)
dqn/ape_x/rpc_testing/classes.py:1:0: E0401: Unable to import 'torch.distributed.rpc' (import-error)
dqn/ape_x/rpc_testing/classes.py:2:0: E0401: Unable to import 'torch.nn' (import-error)
dqn/ape_x/rpc_testing/classes.py:7:0: E0401: Unable to import 'gymnasium' (import-error)
dqn/ape_x/rpc_testing/classes.py:16:0: E0401: Unable to import 'replay_buffers.prioritized_n_step_replay_buffer' (import-error)
dqn/ape_x/rpc_testing/classes.py:16:0: C0413: Import "from replay_buffers.prioritized_n_step_replay_buffer import PrioritizedNStepReplayBuffer" should be placed at the top of the module (wrong-import-position)
dqn/ape_x/rpc_testing/classes.py:21:0: C0413: Import "import os" should be placed at the top of the module (wrong-import-position)
dqn/ape_x/rpc_testing/classes.py:24:0: C0115: Missing class docstring (missing-class-docstring)
dqn/ape_x/rpc_testing/classes.py:24:0: R0902: Too many instance attributes (11/7) (too-many-instance-attributes)
dqn/ape_x/rpc_testing/classes.py:51:15: W0703: Catching too general exception Exception (broad-except)
dqn/ape_x/rpc_testing/classes.py:44:18: W1309: Using an f-string that does not have any interpolated variables (f-string-without-interpolation)
dqn/ape_x/rpc_testing/classes.py:51:8: C0103: Variable name "e" doesn't conform to snake_case naming style (invalid-name)
dqn/ape_x/rpc_testing/classes.py:52:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/rpc_testing/classes.py:91:8: C0103: Variable name "a" doesn't conform to snake_case naming style (invalid-name)
dqn/ape_x/rpc_testing/classes.py:110:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/rpc_testing/classes.py:97:4: R0201: Method could be a function (no-self-use)
dqn/ape_x/rpc_testing/classes.py:113:4: C0116: Missing function or method docstring (missing-function-docstring)
dqn/ape_x/rpc_testing/classes.py:126:12: W0612: Unused variable 'i' (unused-variable)
dqn/ape_x/rpc_testing/classes.py:144:15: C0121: Comparison 'sample == None' should be 'sample is None' (singleton-comparison)
dqn/ape_x/rpc_testing/classes.py:164:19: W0703: Catching too general exception Exception (broad-except)
dqn/ape_x/rpc_testing/classes.py:164:12: C0103: Variable name "e" doesn't conform to snake_case naming style (invalid-name)
dqn/ape_x/rpc_testing/classes.py:165:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/rpc_testing/classes.py:139:12: W0612: Unused variable 'i' (unused-variable)
dqn/ape_x/rpc_testing/classes.py:169:4: C0116: Missing function or method docstring (missing-function-docstring)
dqn/ape_x/rpc_testing/classes.py:181:4: C0116: Missing function or method docstring (missing-function-docstring)
dqn/ape_x/rpc_testing/classes.py:185:4: C0116: Missing function or method docstring (missing-function-docstring)
dqn/ape_x/rpc_testing/classes.py:189:8: C0103: Variable name "t" doesn't conform to snake_case naming style (invalid-name)
dqn/ape_x/rpc_testing/classes.py:215:19: W0703: Catching too general exception Exception (broad-except)
dqn/ape_x/rpc_testing/classes.py:203:30: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/rpc_testing/classes.py:210:30: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/rpc_testing/classes.py:215:12: C0103: Variable name "e" doesn't conform to snake_case naming style (invalid-name)
dqn/ape_x/rpc_testing/classes.py:216:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/rpc_testing/classes.py:220:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/rpc_testing/classes.py:114:8: W0201: Attribute 'flag' defined outside __init__ (attribute-defined-outside-init)
dqn/ape_x/rpc_testing/classes.py:116:8: W0201: Attribute 'replay_thread' defined outside __init__ (attribute-defined-outside-init)
dqn/ape_x/rpc_testing/classes.py:223:0: E0401: Unable to import 'replay_buffers.n_step_replay_buffer' (import-error)
dqn/ape_x/rpc_testing/classes.py:223:0: C0413: Import "from replay_buffers.n_step_replay_buffer import NStepReplayBuffer" should be placed at the top of the module (wrong-import-position)
dqn/ape_x/rpc_testing/classes.py:226:0: C0115: Missing class docstring (missing-class-docstring)
dqn/ape_x/rpc_testing/classes.py:246:8: C0103: Attribute name "rb" doesn't conform to snake_case naming style (invalid-name)
dqn/ape_x/rpc_testing/classes.py:238:0: C0115: Missing class docstring (missing-class-docstring)
dqn/ape_x/rpc_testing/classes.py:238:0: R0902: Too many instance attributes (8/7) (too-many-instance-attributes)
dqn/ape_x/rpc_testing/classes.py:262:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/rpc_testing/classes.py:270:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/rpc_testing/classes.py:257:4: R0201: Method could be a function (no-self-use)
dqn/ape_x/rpc_testing/classes.py:273:4: C0116: Missing function or method docstring (missing-function-docstring)
dqn/ape_x/rpc_testing/classes.py:311:27: W0703: Catching too general exception Exception (broad-except)
dqn/ape_x/rpc_testing/classes.py:311:20: C0103: Variable name "e" doesn't conform to snake_case naming style (invalid-name)
dqn/ape_x/rpc_testing/classes.py:281:16: W0612: Unused variable 'i' (unused-variable)
dqn/ape_x/rpc_testing/classes.py:318:4: C0116: Missing function or method docstring (missing-function-docstring)
dqn/ape_x/rpc_testing/classes.py:320:8: W0107: Unnecessary pass statement (unnecessary-pass)
dqn/ape_x/rpc_testing/classes.py:322:4: C0116: Missing function or method docstring (missing-function-docstring)
dqn/ape_x/rpc_testing/classes.py:325:4: C0116: Missing function or method docstring (missing-function-docstring)
dqn/ape_x/rpc_testing/classes.py:337:4: C0116: Missing function or method docstring (missing-function-docstring)
dqn/ape_x/rpc_testing/classes.py:338:8: C0103: Variable name "ti" doesn't conform to snake_case naming style (invalid-name)
dqn/ape_x/rpc_testing/classes.py:347:15: W0703: Catching too general exception Exception (broad-except)
dqn/ape_x/rpc_testing/classes.py:346:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/rpc_testing/classes.py:347:8: C0103: Variable name "e" doesn't conform to snake_case naming style (invalid-name)
dqn/ape_x/rpc_testing/classes.py:348:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
dqn/ape_x/rpc_testing/classes.py:4:0: C0411: standard import "import time" should be placed before "import torch.distributed.rpc as rpc" (wrong-import-order)
dqn/ape_x/rpc_testing/classes.py:5:0: C0411: standard import "import pathlib" should be placed before "import torch.distributed.rpc as rpc" (wrong-import-order)
dqn/ape_x/rpc_testing/classes.py:6:0: C0411: standard import "import logging" should be placed before "import torch.distributed.rpc as rpc" (wrong-import-order)
dqn/ape_x/rpc_testing/classes.py:8:0: C0411: standard import "import threading" should be placed before "import torch.distributed.rpc as rpc" (wrong-import-order)
dqn/ape_x/rpc_testing/classes.py:9:0: C0411: standard import "import queue" should be placed before "import torch.distributed.rpc as rpc" (wrong-import-order)
dqn/ape_x/rpc_testing/classes.py:10:0: C0411: standard import "from typing import NamedTuple" should be placed before "import torch.distributed.rpc as rpc" (wrong-import-order)
dqn/ape_x/rpc_testing/classes.py:13:0: C0411: standard import "import sys" should be placed before "import torch.distributed.rpc as rpc" (wrong-import-order)
dqn/ape_x/rpc_testing/classes.py:21:0: C0411: standard import "import os" should be placed before "import torch.distributed.rpc as rpc" (wrong-import-order)
************* Module ape_x.sol
dqn/ape_x/sol.py:8:79: C0303: Trailing whitespace (trailing-whitespace)
dqn/ape_x/sol.py:10:85: C0303: Trailing whitespace (trailing-whitespace)
dqn/ape_x/sol.py:11:86: C0303: Trailing whitespace (trailing-whitespace)
dqn/ape_x/sol.py:16:0: W0311: Bad indentation. Found 2 spaces, expected 4 (bad-indentation)
dqn/ape_x/sol.py:19:0: W0311: Bad indentation. Found 2 spaces, expected 4 (bad-indentation)
dqn/ape_x/sol.py:20:0: W0311: Bad indentation. Found 2 spaces, expected 4 (bad-indentation)
dqn/ape_x/sol.py:21:0: W0311: Bad indentation. Found 2 spaces, expected 4 (bad-indentation)
dqn/ape_x/sol.py:22:0: W0311: Bad indentation. Found 4 spaces, expected 8 (bad-indentation)
dqn/ape_x/sol.py:23:0: W0311: Bad indentation. Found 6 spaces, expected 12 (bad-indentation)
dqn/ape_x/sol.py:24:0: W0311: Bad indentation. Found 6 spaces, expected 12 (bad-indentation)
dqn/ape_x/sol.py:25:0: W0311: Bad indentation. Found 6 spaces, expected 12 (bad-indentation)
dqn/ape_x/sol.py:26:0: W0311: Bad indentation. Found 6 spaces, expected 12 (bad-indentation)
dqn/ape_x/sol.py:27:0: W0311: Bad indentation. Found 6 spaces, expected 12 (bad-indentation)
dqn/ape_x/sol.py:28:0: C0303: Trailing whitespace (trailing-whitespace)
dqn/ape_x/sol.py:29:0: W0311: Bad indentation. Found 2 spaces, expected 4 (bad-indentation)
dqn/ape_x/sol.py:30:0: W0311: Bad indentation. Found 2 spaces, expected 4 (bad-indentation)
dqn/ape_x/sol.py:31:0: W0311: Bad indentation. Found 2 spaces, expected 4 (bad-indentation)
dqn/ape_x/sol.py:32:0: W0311: Bad indentation. Found 2 spaces, expected 4 (bad-indentation)
dqn/ape_x/sol.py:32:0: C0325: Unnecessary parens after 'while' keyword (superfluous-parens)
dqn/ape_x/sol.py:33:0: W0311: Bad indentation. Found 4 spaces, expected 8 (bad-indentation)
dqn/ape_x/sol.py:34:0: W0311: Bad indentation. Found 4 spaces, expected 8 (bad-indentation)
dqn/ape_x/sol.py:35:0: W0311: Bad indentation. Found 4 spaces, expected 8 (bad-indentation)
dqn/ape_x/sol.py:36:0: C0303: Trailing whitespace (trailing-whitespace)
dqn/ape_x/sol.py:37:0: W0311: Bad indentation. Found 2 spaces, expected 4 (bad-indentation)
dqn/ape_x/sol.py:1:0: C0114: Missing module docstring (missing-module-docstring)
dqn/ape_x/sol.py:7:17: C0103: Argument name "n" doesn't conform to snake_case naming style (invalid-name)
dqn/ape_x/sol.py:7:0: C0116: Missing function or method docstring (missing-function-docstring)
dqn/ape_x/sol.py:18:0: C0116: Missing function or method docstring (missing-function-docstring)
dqn/ape_x/sol.py:20:14: R1735: Consider using {} instead of dict() (use-dict-literal)
dqn/ape_x/sol.py:21:7: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
dqn/ape_x/sol.py:21:35: C0103: Variable name "f" doesn't conform to snake_case naming style (invalid-name)
************* Module NFSP
dqn/NFSP/__init__.py:1:0: C0103: Module name "NFSP" doesn't conform to snake_case naming style (invalid-name)
************* Module NFSP.nfsp_agent_clean
dqn/NFSP/nfsp_agent_clean.py:65:0: C0301: Line too long (128/100) (line-too-long)
dqn/NFSP/nfsp_agent_clean.py:311:0: C0301: Line too long (105/100) (line-too-long)
dqn/NFSP/nfsp_agent_clean.py:1:0: C0114: Missing module docstring (missing-module-docstring)
dqn/NFSP/nfsp_agent_clean.py:39:0: E0611: No name 'NFSPDQNConfig' in module 'agent_configs' (no-name-in-module)
dqn/NFSP/nfsp_agent_clean.py:41:0: E0401: Unable to import 'torch' (import-error)
dqn/NFSP/nfsp_agent_clean.py:42:0: E0611: No name 'get_legal_moves' in module 'utils' (no-name-in-module)
dqn/NFSP/nfsp_agent_clean.py:42:0: E0611: No name 'current_timestamp' in module 'utils' (no-name-in-module)
dqn/NFSP/nfsp_agent_clean.py:42:0: E0611: No name 'update_per_beta' in module 'utils' (no-name-in-module)
dqn/NFSP/nfsp_agent_clean.py:42:0: E0611: No name 'plot_graphs' in module 'utils' (no-name-in-module)
dqn/NFSP/nfsp_agent_clean.py:47:0: E0401: Unable to import 'dqn.rainbow.rainbow_agent' (import-error)
dqn/NFSP/nfsp_agent_clean.py:47:0: C0413: Import "from dqn.rainbow.rainbow_agent import RainbowAgent" should be placed at the top of the module (wrong-import-position)
dqn/NFSP/nfsp_agent_clean.py:50:0: C0413: Import "import random" should be placed at the top of the module (wrong-import-position)
dqn/NFSP/nfsp_agent_clean.py:51:0: E0401: Unable to import 'base_agent.agent' (import-error)
dqn/NFSP/nfsp_agent_clean.py:51:0: C0413: Import "from base_agent.agent import BaseAgent" should be placed at the top of the module (wrong-import-position)
dqn/NFSP/nfsp_agent_clean.py:52:0: E0611: No name 'dqn' in module 'agent_configs' (no-name-in-module)
dqn/NFSP/nfsp_agent_clean.py:52:0: E0401: Unable to import 'agent_configs.dqn.nfsp_config' (import-error)
dqn/NFSP/nfsp_agent_clean.py:52:0: W0404: Reimport 'NFSPDQNConfig' (imported line 39) (reimported)
dqn/NFSP/nfsp_agent_clean.py:52:0: C0413: Import "from agent_configs.dqn.nfsp_config import NFSPDQNConfig" should be placed at the top of the module (wrong-import-position)
dqn/NFSP/nfsp_agent_clean.py:53:0: E0401: Unable to import 'imitation_learning.policy_imitation_agent' (import-error)
dqn/NFSP/nfsp_agent_clean.py:53:0: C0413: Import "from imitation_learning.policy_imitation_agent import PolicyImitationAgent" should be placed at the top of the module (wrong-import-position)
dqn/NFSP/nfsp_agent_clean.py:56:0: C0115: Missing class docstring (missing-class-docstring)
dqn/NFSP/nfsp_agent_clean.py:56:0: R0902: Too many instance attributes (15/7) (too-many-instance-attributes)
dqn/NFSP/nfsp_agent_clean.py:57:4: R0913: Too many arguments (6/5) (too-many-arguments)
dqn/NFSP/nfsp_agent_clean.py:128:4: C0116: Missing function or method docstring (missing-function-docstring)
dqn/NFSP/nfsp_agent_clean.py:129:12: C0103: Variable name "p" doesn't conform to snake_case naming style (invalid-name)
dqn/NFSP/nfsp_agent_clean.py:138:4: C0116: Missing function or method docstring (missing-function-docstring)
dqn/NFSP/nfsp_agent_clean.py:145:4: C0116: Missing function or method docstring (missing-function-docstring)
dqn/NFSP/nfsp_agent_clean.py:154:4: C0116: Missing function or method docstring (missing-function-docstring)
dqn/NFSP/nfsp_agent_clean.py:157:12: C0103: Variable name "p" doesn't conform to snake_case naming style (invalid-name)
dqn/NFSP/nfsp_agent_clean.py:181:4: C0116: Missing function or method docstring (missing-function-docstring)
dqn/NFSP/nfsp_agent_clean.py:181:4: R0913: Too many arguments (7/5) (too-many-arguments)
dqn/NFSP/nfsp_agent_clean.py:192:75: C0121: Comparison 'done == True' should be 'done is True' if checking for the singleton value True, or 'bool(done)' if testing for truthiness (singleton-comparison)
dqn/NFSP/nfsp_agent_clean.py:193:15: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
dqn/NFSP/nfsp_agent_clean.py:226:4: C0116: Missing function or method docstring (missing-function-docstring)
dqn/NFSP/nfsp_agent_clean.py:229:4: C0116: Missing function or method docstring (missing-function-docstring)
dqn/NFSP/nfsp_agent_clean.py:229:4: R0914: Too many local variables (19/15) (too-many-locals)
dqn/NFSP/nfsp_agent_clean.py:238:14: E1101: Instance of 'NFSPDQN' has no 'training_step' member (no-member)
dqn/NFSP/nfsp_agent_clean.py:301:28: C0103: Variable name "p" doesn't conform to snake_case naming style (invalid-name)
dqn/NFSP/nfsp_agent_clean.py:313:16: C0103: Variable name "p" doesn't conform to snake_case naming style (invalid-name)
dqn/NFSP/nfsp_agent_clean.py:319:52: E1101: Instance of 'NFSPDQN' has no 'training_step' member (no-member)
dqn/NFSP/nfsp_agent_clean.py:338:15: E1101: Instance of 'NFSPDQN' has no 'training_step' member (no-member)
dqn/NFSP/nfsp_agent_clean.py:342:16: E1101: Instance of 'NFSPDQN' has no 'training_step' member (no-member)
dqn/NFSP/nfsp_agent_clean.py:351:16: E1120: No value for argument 'training_step' in method call (no-value-for-parameter)
dqn/NFSP/nfsp_agent_clean.py:351:16: E1120: No value for argument 'frames_seen' in method call (no-value-for-parameter)
dqn/NFSP/nfsp_agent_clean.py:351:16: E1120: No value for argument 'time_taken' in method call (no-value-for-parameter)
dqn/NFSP/nfsp_agent_clean.py:353:12: E1101: Instance of 'NFSPDQN' has no 'training_step' member (no-member)
dqn/NFSP/nfsp_agent_clean.py:357:8: E1120: No value for argument 'training_step' in method call (no-value-for-parameter)
dqn/NFSP/nfsp_agent_clean.py:357:8: E1120: No value for argument 'frames_seen' in method call (no-value-for-parameter)
dqn/NFSP/nfsp_agent_clean.py:357:8: E1120: No value for argument 'time_taken' in method call (no-value-for-parameter)
dqn/NFSP/nfsp_agent_clean.py:330:16: W0612: Unused variable 'minibatch' (unused-variable)
dqn/NFSP/nfsp_agent_clean.py:229:4: R0912: Too many branches (13/12) (too-many-branches)
dqn/NFSP/nfsp_agent_clean.py:360:4: C0116: Missing function or method docstring (missing-function-docstring)
dqn/NFSP/nfsp_agent_clean.py:368:8: W0622: Redefining built-in 'dir' (redefined-builtin)
dqn/NFSP/nfsp_agent_clean.py:374:12: C0103: Variable name "p" doesn't conform to snake_case naming style (invalid-name)
dqn/NFSP/nfsp_agent_clean.py:380:59: W1309: Using an f-string that does not have any interpolated variables (f-string-without-interpolation)
dqn/NFSP/nfsp_agent_clean.py:400:16: C0103: Variable name "p" doesn't conform to snake_case naming style (invalid-name)
dqn/NFSP/nfsp_agent_clean.py:412:25: E1130: bad operand type for unary -: NoneType (invalid-unary-operand-type)
dqn/NFSP/nfsp_agent_clean.py:419:42: W1309: Using an f-string that does not have any interpolated variables (f-string-without-interpolation)
dqn/NFSP/nfsp_agent_clean.py:419:79: C0103: Variable name "f" doesn't conform to snake_case naming style (invalid-name)
dqn/NFSP/nfsp_agent_clean.py:421:42: W1309: Using an f-string that does not have any interpolated variables (f-string-without-interpolation)
dqn/NFSP/nfsp_agent_clean.py:421:81: C0103: Variable name "f" doesn't conform to snake_case naming style (invalid-name)
dqn/NFSP/nfsp_agent_clean.py:438:4: C0116: Missing function or method docstring (missing-function-docstring)
dqn/NFSP/nfsp_agent_clean.py:438:45: W0622: Redefining built-in 'dir' (redefined-builtin)
dqn/NFSP/nfsp_agent_clean.py:438:4: R0914: Too many local variables (20/15) (too-many-locals)
dqn/NFSP/nfsp_agent_clean.py:449:16: C0103: Variable name "p" doesn't conform to snake_case naming style (invalid-name)
dqn/NFSP/nfsp_agent_clean.py:458:45: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
dqn/NFSP/nfsp_agent_clean.py:502:16: C0103: Variable name "p" doesn't conform to snake_case naming style (invalid-name)
dqn/NFSP/nfsp_agent_clean.py:438:4: R1710: Either all return statements in a function should return an expression, or none of them should. (inconsistent-return-statements)
dqn/NFSP/nfsp_agent_clean.py:511:4: C0116: Missing function or method docstring (missing-function-docstring)
dqn/NFSP/nfsp_agent_clean.py:511:35: W0622: Redefining built-in 'dir' (redefined-builtin)
dqn/NFSP/nfsp_agent_clean.py:517:51: W1309: Using an f-string that does not have any interpolated variables (f-string-without-interpolation)
dqn/NFSP/nfsp_agent_clean.py:518:12: C0103: Variable name "p" doesn't conform to snake_case naming style (invalid-name)
dqn/NFSP/nfsp_agent_clean.py:546:42: W1309: Using an f-string that does not have any interpolated variables (f-string-without-interpolation)
dqn/NFSP/nfsp_agent_clean.py:546:79: C0103: Variable name "f" doesn't conform to snake_case naming style (invalid-name)
dqn/NFSP/nfsp_agent_clean.py:548:42: W1309: Using an f-string that does not have any interpolated variables (f-string-without-interpolation)
dqn/NFSP/nfsp_agent_clean.py:548:81: C0103: Variable name "f" doesn't conform to snake_case naming style (invalid-name)
dqn/NFSP/nfsp_agent_clean.py:232:30: E0203: Access to member 'training_time' before its definition line 349 (access-member-before-definition)
dqn/NFSP/nfsp_agent_clean.py:350:16: E0203: Access to member 'total_environment_steps' before its definition line 356 (access-member-before-definition)
dqn/NFSP/nfsp_agent_clean.py:349:16: W0201: Attribute 'training_time' defined outside __init__ (attribute-defined-outside-init)
dqn/NFSP/nfsp_agent_clean.py:355:8: W0201: Attribute 'training_time' defined outside __init__ (attribute-defined-outside-init)
dqn/NFSP/nfsp_agent_clean.py:356:8: W0201: Attribute 'total_environment_steps' defined outside __init__ (attribute-defined-outside-init)
dqn/NFSP/nfsp_agent_clean.py:513:8: W0201: Attribute 'config' defined outside __init__ (attribute-defined-outside-init)
dqn/NFSP/nfsp_agent_clean.py:514:8: W0201: Attribute 'rl_config' defined outside __init__ (attribute-defined-outside-init)
dqn/NFSP/nfsp_agent_clean.py:516:12: W0201: Attribute 'sl_config' defined outside __init__ (attribute-defined-outside-init)
dqn/NFSP/nfsp_agent_clean.py:551:8: W0201: Attribute 'start_training_step' defined outside __init__ (attribute-defined-outside-init)
dqn/NFSP/nfsp_agent_clean.py:42:0: W0611: Unused get_legal_moves imported from utils (unused-import)
dqn/NFSP/nfsp_agent_clean.py:50:0: C0411: standard import "import random" should be placed before "from agent_configs import NFSPDQNConfig" (wrong-import-order)
dqn/NFSP/nfsp_agent_clean.py:52:0: C0411: third party import "from agent_configs.dqn.nfsp_config import NFSPDQNConfig" should be placed before "from dqn.rainbow.rainbow_agent import RainbowAgent" (wrong-import-order)
dqn/NFSP/nfsp_agent_clean.py:52:0: C0412: Imports from package agent_configs are not grouped (ungrouped-imports)
************* Module rainbow.hyperparameter_optimization
dqn/rainbow/hyperparameter_optimization.py:1:0: C0114: Missing module docstring (missing-module-docstring)
dqn/rainbow/hyperparameter_optimization.py:5:0: E0401: Unable to import 'gymnasium' (import-error)
dqn/rainbow/hyperparameter_optimization.py:6:0: E0401: Unable to import 'hyperopt' (import-error)
dqn/rainbow/hyperparameter_optimization.py:7:0: E0611: No name 'RainbowConfig' in module 'agent_configs' (no-name-in-module)
dqn/rainbow/hyperparameter_optimization.py:13:0: E0401: Unable to import 'dqn.rainbow.rainbow_agent' (import-error)
dqn/rainbow/hyperparameter_optimization.py:13:0: C0413: Import "from dqn.rainbow.rainbow_agent import RainbowAgent" should be placed at the top of the module (wrong-import-position)
dqn/rainbow/hyperparameter_optimization.py:16:0: E0611: No name 'CartPoleConfig' in module 'game_configs' (no-name-in-module)
dqn/rainbow/hyperparameter_optimization.py:16:0: C0413: Import "from game_configs import CartPoleConfig" should be placed at the top of the module (wrong-import-position)
dqn/rainbow/hyperparameter_optimization.py:18:0: C0103: Constant name "file_name" doesn't conform to UPPER_CASE naming style (invalid-name)
dqn/rainbow/hyperparameter_optimization.py:18:0: W0604: Using the global statement at the module level (global-at-module-level)
dqn/rainbow/hyperparameter_optimization.py:19:0: C0103: Constant name "eval_method" doesn't conform to UPPER_CASE naming style (invalid-name)
dqn/rainbow/hyperparameter_optimization.py:19:0: W0604: Using the global statement at the module level (global-at-module-level)
dqn/rainbow/hyperparameter_optimization.py:22:0: C0116: Missing function or method docstring (missing-function-docstring)
dqn/rainbow/hyperparameter_optimization.py:23:4: C0103: Variable name "m" doesn't conform to snake_case naming style (invalid-name)
dqn/rainbow/hyperparameter_optimization.py:26:13: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
dqn/rainbow/hyperparameter_optimization.py:30:4: R1705: Unnecessary "elif" after "return" (no-else-return)
dqn/rainbow/hyperparameter_optimization.py:31:53: W1309: Using an f-string that does not have any interpolated variables (f-string-without-interpolation)
dqn/rainbow/hyperparameter_optimization.py:39:50: W1309: Using an f-string that does not have any interpolated variables (f-string-without-interpolation)
dqn/rainbow/hyperparameter_optimization.py:22:0: R1710: Either all return statements in a function should return an expression, or none of them should. (inconsistent-return-statements)
dqn/rainbow/hyperparameter_optimization.py:49:0: C0116: Missing function or method docstring (missing-function-docstring)
dqn/rainbow/hyperparameter_optimization.py:55:8: W0621: Redefining name 'trials' from outer scope (line 118) (redefined-outer-name)
dqn/rainbow/hyperparameter_optimization.py:55:29: R1732: Consider using 'with' for resource-allocating operations (consider-using-with)
dqn/rainbow/hyperparameter_optimization.py:56:15: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
dqn/rainbow/hyperparameter_optimization.py:78:4: C0103: Variable name "e" doesn't conform to snake_case naming style (invalid-name)
dqn/rainbow/hyperparameter_optimization.py:105:31: R1732: Consider using 'with' for resource-allocating operations (consider-using-with)
dqn/rainbow/hyperparameter_optimization.py:106:38: R1732: Consider using 'with' for resource-allocating operations (consider-using-with)
dqn/rainbow/hyperparameter_optimization.py:110:8: R1714: Consider merging these comparisons with "in" to "eval_method in ('final_score', 'rolling_average', 'final_score_rolling_average')" (consider-using-in)
dqn/rainbow/hyperparameter_optimization.py:114:4: C0103: Constant name "max_trials" doesn't conform to UPPER_CASE naming style (invalid-name)
dqn/rainbow/hyperparameter_optimization.py:115:4: C0103: Constant name "trials_step" doesn't conform to UPPER_CASE naming style (invalid-name)
dqn/rainbow/hyperparameter_optimization.py:126:4: W0702: No exception type(s) specified (bare-except)
dqn/rainbow/hyperparameter_optimization.py:118:29: R1732: Consider using 'with' for resource-allocating operations (consider-using-with)
dqn/rainbow/hyperparameter_optimization.py:122:12: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
dqn/rainbow/hyperparameter_optimization.py:127:8: C0103: Constant name "trials" doesn't conform to UPPER_CASE naming style (invalid-name)
dqn/rainbow/hyperparameter_optimization.py:8:0: C0411: standard import "import gc" should be placed before "import numpy as np" (wrong-import-order)
dqn/rainbow/hyperparameter_optimization.py:10:0: C0411: standard import "import sys" should be placed before "import numpy as np" (wrong-import-order)
dqn/rainbow/hyperparameter_optimization.py:16:0: C0411: third party import "from game_configs import CartPoleConfig" should be placed before "from dqn.rainbow.rainbow_agent import RainbowAgent" (wrong-import-order)
************* Module rainbow.rainbow_agent
dqn/rainbow/rainbow_agent.py:42:0: C0301: Line too long (128/100) (line-too-long)
dqn/rainbow/rainbow_agent.py:104:0: C0301: Line too long (116/100) (line-too-long)
dqn/rainbow/rainbow_agent.py:128:0: C0303: Trailing whitespace (trailing-whitespace)
dqn/rainbow/rainbow_agent.py:204:0: C0301: Line too long (123/100) (line-too-long)
dqn/rainbow/rainbow_agent.py:1:0: C0114: Missing module docstring (missing-module-docstring)
dqn/rainbow/rainbow_agent.py:2:0: E0401: Unable to import 'torch' (import-error)
dqn/rainbow/rainbow_agent.py:3:0: E0401: Unable to import 'torch.nn.utils' (import-error)
dqn/rainbow/rainbow_agent.py:4:0: E0401: Unable to import 'torch.optim.sgd' (import-error)
dqn/rainbow/rainbow_agent.py:5:0: E0401: Unable to import 'torch.optim.adam' (import-error)
dqn/rainbow/rainbow_agent.py:7:0: E0611: No name 'RainbowConfig' in module 'agent_configs' (no-name-in-module)
dqn/rainbow/rainbow_agent.py:8:0: E0611: No name 'update_per_beta' in module 'utils' (no-name-in-module)
dqn/rainbow/rainbow_agent.py:8:0: E0611: No name 'get_legal_moves' in module 'utils' (no-name-in-module)
dqn/rainbow/rainbow_agent.py:8:0: E0611: No name 'current_timestamp' in module 'utils' (no-name-in-module)
dqn/rainbow/rainbow_agent.py:8:0: E0611: No name 'action_mask' in module 'utils' (no-name-in-module)
dqn/rainbow/rainbow_agent.py:8:0: E0611: No name 'epsilon_greedy_policy' in module 'utils' (no-name-in-module)
dqn/rainbow/rainbow_agent.py:8:0: E0611: No name 'CategoricalCrossentropyLoss' in module 'utils' (no-name-in-module)
dqn/rainbow/rainbow_agent.py:8:0: E0611: No name 'HuberLoss' in module 'utils' (no-name-in-module)
dqn/rainbow/rainbow_agent.py:8:0: E0611: No name 'KLDivergenceLoss' in module 'utils' (no-name-in-module)
dqn/rainbow/rainbow_agent.py:8:0: E0611: No name 'MSELoss' in module 'utils' (no-name-in-module)
dqn/rainbow/rainbow_agent.py:8:0: E0611: No name 'update_inverse_sqrt_schedule' in module 'utils' (no-name-in-module)
dqn/rainbow/rainbow_agent.py:8:0: E0611: No name 'update_linear_schedule' in module 'utils' (no-name-in-module)
dqn/rainbow/rainbow_agent.py:24:0: W0404: Reimport 'epsilon_greedy_policy' (imported line 8) (reimported)
dqn/rainbow/rainbow_agent.py:28:0: E0401: Unable to import 'base_agent.agent' (import-error)
dqn/rainbow/rainbow_agent.py:28:0: C0413: Import "from base_agent.agent import BaseAgent" should be placed at the top of the module (wrong-import-position)
dqn/rainbow/rainbow_agent.py:29:0: E0401: Unable to import 'replay_buffers.prioritized_n_step_replay_buffer' (import-error)
dqn/rainbow/rainbow_agent.py:29:0: C0413: Import "from replay_buffers.prioritized_n_step_replay_buffer import PrioritizedNStepReplayBuffer" should be placed at the top of the module (wrong-import-position)
dqn/rainbow/rainbow_agent.py:30:0: E0401: Unable to import 'dqn.rainbow.rainbow_network' (import-error)
dqn/rainbow/rainbow_agent.py:30:0: C0413: Import "from dqn.rainbow.rainbow_network import RainbowNetwork" should be placed at the top of the module (wrong-import-position)
dqn/rainbow/rainbow_agent.py:33:0: C0115: Missing class docstring (missing-class-docstring)
dqn/rainbow/rainbow_agent.py:33:0: R0902: Too many instance attributes (11/7) (too-many-instance-attributes)
dqn/rainbow/rainbow_agent.py:34:4: R0913: Too many arguments (6/5) (too-many-arguments)
dqn/rainbow/rainbow_agent.py:51:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
dqn/rainbow/rainbow_agent.py:63:15: C0121: Comparison 'self.config.kernel_initializer == None' should be 'self.config.kernel_initializer is None' (singleton-comparison)
dqn/rainbow/rainbow_agent.py:49:8: W0613: Unused argument 'from_checkpoint' (unused-argument)
dqn/rainbow/rainbow_agent.py:129:4: C0116: Missing function or method docstring (missing-function-docstring)
dqn/rainbow/rainbow_agent.py:133:4: C0116: Missing function or method docstring (missing-function-docstring)
dqn/rainbow/rainbow_agent.py:138:4: C0116: Missing function or method docstring (missing-function-docstring)
dqn/rainbow/rainbow_agent.py:138:0: W0613: Unused argument 'args' (unused-argument)
dqn/rainbow/rainbow_agent.py:138:0: W0613: Unused argument 'kwargs' (unused-argument)
dqn/rainbow/rainbow_agent.py:144:4: C0116: Missing function or method docstring (missing-function-docstring)
dqn/rainbow/rainbow_agent.py:150:4: C0116: Missing function or method docstring (missing-function-docstring)
dqn/rainbow/rainbow_agent.py:175:4: C0116: Missing function or method docstring (missing-function-docstring)
dqn/rainbow/rainbow_agent.py:183:4: C0116: Missing function or method docstring (missing-function-docstring)
dqn/rainbow/rainbow_agent.py:202:19: R1701: Consider merging these isinstance calls to isinstance(self.config.loss_function, (CategoricalCrossentropyLoss, KLDivergenceLoss)) (consider-merging-isinstance)
dqn/rainbow/rainbow_agent.py:204:15: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
dqn/rainbow/rainbow_agent.py:210:19: R1701: Consider merging these isinstance calls to isinstance(self.config.loss_function, (HuberLoss, MSELoss)) (consider-merging-isinstance)
dqn/rainbow/rainbow_agent.py:212:15: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
dqn/rainbow/rainbow_agent.py:249:49: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
dqn/rainbow/rainbow_agent.py:254:11: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
dqn/rainbow/rainbow_agent.py:274:4: C0116: Missing function or method docstring (missing-function-docstring)
dqn/rainbow/rainbow_agent.py:277:4: C0116: Missing function or method docstring (missing-function-docstring)
dqn/rainbow/rainbow_agent.py:277:4: R0914: Too many local variables (16/15) (too-many-locals)
dqn/rainbow/rainbow_agent.py:305:12: C0103: Variable name "Tz" doesn't conform to snake_case naming style (invalid-name)
dqn/rainbow/rainbow_agent.py:311:12: C0103: Variable name "b" doesn't conform to snake_case naming style (invalid-name)
dqn/rainbow/rainbow_agent.py:312:12: C0103: Variable name "l" doesn't conform to snake_case naming style (invalid-name)
dqn/rainbow/rainbow_agent.py:312:15: C0103: Variable name "u" doesn't conform to snake_case naming style (invalid-name)
dqn/rainbow/rainbow_agent.py:329:12: C0103: Variable name "m" doesn't conform to snake_case naming style (invalid-name)
dqn/rainbow/rainbow_agent.py:344:4: C0116: Missing function or method docstring (missing-function-docstring)
dqn/rainbow/rainbow_agent.py:372:4: C0116: Missing function or method docstring (missing-function-docstring)
dqn/rainbow/rainbow_agent.py:374:16: C0103: Variable name "wt" doesn't conform to snake_case naming style (invalid-name)
dqn/rainbow/rainbow_agent.py:374:20: C0103: Variable name "wp" doesn't conform to snake_case naming style (invalid-name)
dqn/rainbow/rainbow_agent.py:379:4: C0116: Missing function or method docstring (missing-function-docstring)
dqn/rainbow/rainbow_agent.py:395:16: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
dqn/rainbow/rainbow_agent.py:398:4: C0116: Missing function or method docstring (missing-function-docstring)
dqn/rainbow/rainbow_agent.py:398:4: R0914: Too many local variables (19/15) (too-many-locals)
dqn/rainbow/rainbow_agent.py:407:14: E1101: Instance of 'RainbowAgent' has no 'training_step' member (no-member)
dqn/rainbow/rainbow_agent.py:408:15: E1101: Instance of 'RainbowAgent' has no 'training_step' member (no-member)
dqn/rainbow/rainbow_agent.py:455:35: E1101: Instance of 'RainbowAgent' has no 'training_step' member (no-member)
dqn/rainbow/rainbow_agent.py:469:15: E1101: Instance of 'RainbowAgent' has no 'training_step' member (no-member)
dqn/rainbow/rainbow_agent.py:476:15: E1101: Instance of 'RainbowAgent' has no 'training_step' member (no-member)
dqn/rainbow/rainbow_agent.py:480:47: E1101: Instance of 'RainbowAgent' has no 'training_step' member (no-member)
dqn/rainbow/rainbow_agent.py:483:12: E1101: Instance of 'RainbowAgent' has no 'training_step' member (no-member)
dqn/rainbow/rainbow_agent.py:486:39: E1101: Instance of 'RainbowAgent' has no 'training_step' member (no-member)
dqn/rainbow/rainbow_agent.py:457:16: W0612: Unused variable 'minibatch' (unused-variable)
dqn/rainbow/rainbow_agent.py:400:30: E0203: Access to member 'training_time' before its definition line 479 (access-member-before-definition)
dqn/rainbow/rainbow_agent.py:479:16: W0201: Attribute 'training_time' defined outside __init__ (attribute-defined-outside-init)
dqn/rainbow/rainbow_agent.py:485:8: W0201: Attribute 'training_time' defined outside __init__ (attribute-defined-outside-init)
dqn/rainbow/rainbow_agent.py:480:16: W0201: Attribute 'total_environment_steps' defined outside __init__ (attribute-defined-outside-init)
dqn/rainbow/rainbow_agent.py:486:8: W0201: Attribute 'total_environment_steps' defined outside __init__ (attribute-defined-outside-init)
dqn/rainbow/rainbow_agent.py:22:0: C0411: standard import "import sys" should be placed before "import torch" (wrong-import-order)
************* Module rainbow.rainbow_network
dqn/rainbow/rainbow_network.py:208:0: C0301: Line too long (118/100) (line-too-long)
dqn/rainbow/rainbow_network.py:224:0: C0301: Line too long (111/100) (line-too-long)
dqn/rainbow/rainbow_network.py:1:0: C0114: Missing module docstring (missing-module-docstring)
dqn/rainbow/rainbow_network.py:3:0: E0401: Unable to import 'torch' (import-error)
dqn/rainbow/rainbow_network.py:5:0: E0611: No name 'RainbowConfig' in module 'agent_configs' (no-name-in-module)
dqn/rainbow/rainbow_network.py:6:0: E0401: Unable to import 'modules.conv' (import-error)
dqn/rainbow/rainbow_network.py:7:0: E0401: Unable to import 'modules.dense' (import-error)
dqn/rainbow/rainbow_network.py:8:0: E0611: No name 'to_lists' in module 'utils' (no-name-in-module)
dqn/rainbow/rainbow_network.py:9:0: E0401: Unable to import 'modules.residual' (import-error)
dqn/rainbow/rainbow_network.py:12:0: C0115: Missing class docstring (missing-class-docstring)
dqn/rainbow/rainbow_network.py:12:0: R0902: Too many instance attributes (15/7) (too-many-instance-attributes)
dqn/rainbow/rainbow_network.py:40:8: C0103: Variable name "B" doesn't conform to snake_case naming style (invalid-name)
dqn/rainbow/rainbow_network.py:45:15: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
dqn/rainbow/rainbow_network.py:67:15: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
dqn/rainbow/rainbow_network.py:110:15: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
dqn/rainbow/rainbow_network.py:13:4: R0912: Too many branches (14/12) (too-many-branches)
dqn/rainbow/rainbow_network.py:13:4: R0915: Too many statements (52/50) (too-many-statements)
dqn/rainbow/rainbow_network.py:156:4: C0116: Missing function or method docstring (missing-function-docstring)
dqn/rainbow/rainbow_network.py:171:4: C0116: Missing function or method docstring (missing-function-docstring)
dqn/rainbow/rainbow_network.py:176:8: C0103: Variable name "S" doesn't conform to snake_case naming style (invalid-name)
dqn/rainbow/rainbow_network.py:179:12: C0103: Variable name "S" doesn't conform to snake_case naming style (invalid-name)
dqn/rainbow/rainbow_network.py:183:12: C0103: Variable name "S" doesn't conform to snake_case naming style (invalid-name)
dqn/rainbow/rainbow_network.py:186:8: C0103: Variable name "S" doesn't conform to snake_case naming style (invalid-name)
dqn/rainbow/rainbow_network.py:190:12: C0103: Variable name "S" doesn't conform to snake_case naming style (invalid-name)
dqn/rainbow/rainbow_network.py:195:16: C0103: Variable name "v" doesn't conform to snake_case naming style (invalid-name)
dqn/rainbow/rainbow_network.py:197:16: C0103: Variable name "v" doesn't conform to snake_case naming style (invalid-name)
dqn/rainbow/rainbow_network.py:200:12: C0103: Variable name "v" doesn't conform to snake_case naming style (invalid-name)
dqn/rainbow/rainbow_network.py:204:16: C0103: Variable name "A" doesn't conform to snake_case naming style (invalid-name)
dqn/rainbow/rainbow_network.py:206:16: C0103: Variable name "A" doesn't conform to snake_case naming style (invalid-name)
dqn/rainbow/rainbow_network.py:209:12: C0103: Variable name "A" doesn't conform to snake_case naming style (invalid-name)
dqn/rainbow/rainbow_network.py:220:12: C0103: Variable name "Q" doesn't conform to snake_case naming style (invalid-name)
dqn/rainbow/rainbow_network.py:228:12: C0103: Variable name "Q" doesn't conform to snake_case naming style (invalid-name)
dqn/rainbow/rainbow_network.py:232:8: R1705: Unnecessary "else" after "return" (no-else-return)
dqn/rainbow/rainbow_network.py:237:4: C0116: Missing function or method docstring (missing-function-docstring)
dqn/rainbow/rainbow_network.py:253:4: C0116: Missing function or method docstring (missing-function-docstring)
dqn/rainbow/rainbow_network.py:8:0: C0411: third party import "from utils import to_lists" should be placed before "from modules.conv import Conv2dStack" (wrong-import-order)
dqn/rainbow/rainbow_network.py:9:0: C0412: Imports from package modules are not grouped (ungrouped-imports)
************* Module acm_memory
experiments/actor_critic_memory/acm_memory.py:2:0: C0304: Final newline missing (missing-final-newline)
************* Module pacman
experiments/rainbow_and_ape-x/pacman.py:591:5: W0511: TODO (fixme)
experiments/rainbow_and_ape-x/pacman.py:1985:9: W0511: TODO: Check assert case and fix bug (fixme)
experiments/rainbow_and_ape-x/pacman.py:151:0: C0301: Line too long (101/100) (line-too-long)
experiments/rainbow_and_ape-x/pacman.py:491:0: C0301: Line too long (112/100) (line-too-long)
experiments/rainbow_and_ape-x/pacman.py:934:0: C0301: Line too long (105/100) (line-too-long)
experiments/rainbow_and_ape-x/pacman.py:1005:0: C0301: Line too long (111/100) (line-too-long)
experiments/rainbow_and_ape-x/pacman.py:1009:0: C0301: Line too long (114/100) (line-too-long)
experiments/rainbow_and_ape-x/pacman.py:1160:0: C0301: Line too long (108/100) (line-too-long)
experiments/rainbow_and_ape-x/pacman.py:1317:0: C0301: Line too long (175/100) (line-too-long)
experiments/rainbow_and_ape-x/pacman.py:1322:0: C0301: Line too long (189/100) (line-too-long)
experiments/rainbow_and_ape-x/pacman.py:1492:0: C0301: Line too long (128/100) (line-too-long)
experiments/rainbow_and_ape-x/pacman.py:1551:0: C0301: Line too long (123/100) (line-too-long)
experiments/rainbow_and_ape-x/pacman.py:1552:0: C0301: Line too long (116/100) (line-too-long)
experiments/rainbow_and_ape-x/pacman.py:1557:0: C0301: Line too long (107/100) (line-too-long)
experiments/rainbow_and_ape-x/pacman.py:1558:0: C0301: Line too long (122/100) (line-too-long)
experiments/rainbow_and_ape-x/pacman.py:1581:0: C0301: Line too long (120/100) (line-too-long)
experiments/rainbow_and_ape-x/pacman.py:1592:0: C0301: Line too long (102/100) (line-too-long)
experiments/rainbow_and_ape-x/pacman.py:1595:0: C0301: Line too long (102/100) (line-too-long)
experiments/rainbow_and_ape-x/pacman.py:1600:0: C0301: Line too long (115/100) (line-too-long)
experiments/rainbow_and_ape-x/pacman.py:1615:0: C0301: Line too long (109/100) (line-too-long)
experiments/rainbow_and_ape-x/pacman.py:1619:0: C0301: Line too long (158/100) (line-too-long)
experiments/rainbow_and_ape-x/pacman.py:1733:0: C0301: Line too long (157/100) (line-too-long)
experiments/rainbow_and_ape-x/pacman.py:1774:0: C0301: Line too long (201/100) (line-too-long)
experiments/rainbow_and_ape-x/pacman.py:1811:0: C0301: Line too long (137/100) (line-too-long)
experiments/rainbow_and_ape-x/pacman.py:1859:0: C0301: Line too long (127/100) (line-too-long)
experiments/rainbow_and_ape-x/pacman.py:1870:0: C0301: Line too long (225/100) (line-too-long)
experiments/rainbow_and_ape-x/pacman.py:1872:0: C0301: Line too long (185/100) (line-too-long)
experiments/rainbow_and_ape-x/pacman.py:2421:0: C0301: Line too long (102/100) (line-too-long)
experiments/rainbow_and_ape-x/pacman.py:2504:0: C0301: Line too long (140/100) (line-too-long)
experiments/rainbow_and_ape-x/pacman.py:2693:0: C0301: Line too long (140/100) (line-too-long)
experiments/rainbow_and_ape-x/pacman.py:2801:0: C0301: Line too long (201/100) (line-too-long)
experiments/rainbow_and_ape-x/pacman.py:2827:0: C0301: Line too long (106/100) (line-too-long)
experiments/rainbow_and_ape-x/pacman.py:3022:0: C0301: Line too long (186/100) (line-too-long)
experiments/rainbow_and_ape-x/pacman.py:3085:0: C0301: Line too long (101/100) (line-too-long)
experiments/rainbow_and_ape-x/pacman.py:3103:0: C0301: Line too long (106/100) (line-too-long)
experiments/rainbow_and_ape-x/pacman.py:3438:0: C0301: Line too long (118/100) (line-too-long)
experiments/rainbow_and_ape-x/pacman.py:3454:0: C0301: Line too long (111/100) (line-too-long)
experiments/rainbow_and_ape-x/pacman.py:3509:0: C0301: Line too long (128/100) (line-too-long)
experiments/rainbow_and_ape-x/pacman.py:3571:0: C0301: Line too long (116/100) (line-too-long)
experiments/rainbow_and_ape-x/pacman.py:3666:0: C0301: Line too long (123/100) (line-too-long)
experiments/rainbow_and_ape-x/pacman.py:4006:0: C0301: Line too long (124/100) (line-too-long)
experiments/rainbow_and_ape-x/pacman.py:1:0: C0302: Too many lines in module (4010/1000) (too-many-lines)
experiments/rainbow_and_ape-x/pacman.py:1:0: C0114: Missing module docstring (missing-module-docstring)
experiments/rainbow_and_ape-x/pacman.py:1:0: E0401: Unable to import 'gymnasium' (import-error)
experiments/rainbow_and_ape-x/pacman.py:2:0: E0401: Unable to import 'gymnasium.wrappers' (import-error)
experiments/rainbow_and_ape-x/pacman.py:30:0: C0413: Import "import scipy" should be placed at the top of the module (wrong-import-position)
experiments/rainbow_and_ape-x/pacman.py:32:0: C0413: Import "import pickle" should be placed at the top of the module (wrong-import-position)
experiments/rainbow_and_ape-x/pacman.py:33:0: C0413: Import "from datetime import datetime" should be placed at the top of the module (wrong-import-position)
experiments/rainbow_and_ape-x/pacman.py:34:0: C0413: Import "import itertools" should be placed at the top of the module (wrong-import-position)
experiments/rainbow_and_ape-x/pacman.py:35:0: E0401: Unable to import 'hyperopt' (import-error)
experiments/rainbow_and_ape-x/pacman.py:35:0: C0413: Import "from hyperopt import space_eval" should be placed at the top of the module (wrong-import-position)
experiments/rainbow_and_ape-x/pacman.py:36:0: C0413: Import "import pandas as pd" should be placed at the top of the module (wrong-import-position)
experiments/rainbow_and_ape-x/pacman.py:38:0: C0413: Import "from typing import Callable, Tuple, Iterable" should be placed at the top of the module (wrong-import-position)
experiments/rainbow_and_ape-x/pacman.py:41:0: E0401: Unable to import 'torch' (import-error)
experiments/rainbow_and_ape-x/pacman.py:41:0: C0413: Import "import torch" should be placed at the top of the module (wrong-import-position)
experiments/rainbow_and_ape-x/pacman.py:42:0: E0401: Unable to import 'torch' (import-error)
experiments/rainbow_and_ape-x/pacman.py:42:0: C0413: Import "from torch import nn, Tensor, functional" should be placed at the top of the module (wrong-import-position)
experiments/rainbow_and_ape-x/pacman.py:43:0: E0401: Unable to import 'torch.nn.utils' (import-error)
experiments/rainbow_and_ape-x/pacman.py:43:0: C0413: Import "from torch.nn.utils import clip_grad_norm_" should be placed at the top of the module (wrong-import-position)
experiments/rainbow_and_ape-x/pacman.py:44:0: E0401: Unable to import 'torch.optim.sgd' (import-error)
experiments/rainbow_and_ape-x/pacman.py:44:0: C0413: Import "from torch.optim.sgd import SGD" should be placed at the top of the module (wrong-import-position)
experiments/rainbow_and_ape-x/pacman.py:45:0: E0401: Unable to import 'torch.optim.adam' (import-error)
experiments/rainbow_and_ape-x/pacman.py:45:0: C0413: Import "from torch.optim.adam import Adam" should be placed at the top of the module (wrong-import-position)
experiments/rainbow_and_ape-x/pacman.py:47:0: W0404: Reimport 'deque' (imported line 20) (reimported)
experiments/rainbow_and_ape-x/pacman.py:47:0: C0413: Import "from collections import deque" should be placed at the top of the module (wrong-import-position)
experiments/rainbow_and_ape-x/pacman.py:49:0: C0413: Import "import yaml" should be placed at the top of the module (wrong-import-position)
experiments/rainbow_and_ape-x/pacman.py:51:0: C0413: Import "import gc" should be placed at the top of the module (wrong-import-position)
experiments/rainbow_and_ape-x/pacman.py:52:0: C0413: Import "from pathlib import Path" should be placed at the top of the module (wrong-import-position)
experiments/rainbow_and_ape-x/pacman.py:53:0: C0413: Import "import copy" should be placed at the top of the module (wrong-import-position)
experiments/rainbow_and_ape-x/pacman.py:54:0: E0401: Unable to import 'dill' (import-error)
experiments/rainbow_and_ape-x/pacman.py:54:0: C0413: Import "import dill" should be placed at the top of the module (wrong-import-position)
experiments/rainbow_and_ape-x/pacman.py:57:0: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:74:7: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
experiments/rainbow_and_ape-x/pacman.py:111:0: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:113:4: R1705: Unnecessary "else" after "return" (no-else-return)
experiments/rainbow_and_ape-x/pacman.py:148:0: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:164:0: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:182:0: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:189:0: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:189:0: R0913: Too many arguments (6/5) (too-many-arguments)
experiments/rainbow_and_ape-x/pacman.py:193:8: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
experiments/rainbow_and_ape-x/pacman.py:195:4: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:201:0: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:201:0: R0913: Too many arguments (6/5) (too-many-arguments)
experiments/rainbow_and_ape-x/pacman.py:201:0: R0914: Too many local variables (19/15) (too-many-locals)
experiments/rainbow_and_ape-x/pacman.py:206:4: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:269:18: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
experiments/rainbow_and_ape-x/pacman.py:275:0: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:275:0: R0913: Too many arguments (6/5) (too-many-arguments)
experiments/rainbow_and_ape-x/pacman.py:277:4: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:319:18: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
experiments/rainbow_and_ape-x/pacman.py:325:0: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:325:0: R0913: Too many arguments (6/5) (too-many-arguments)
experiments/rainbow_and_ape-x/pacman.py:325:0: R0914: Too many local variables (16/15) (too-many-locals)
experiments/rainbow_and_ape-x/pacman.py:337:4: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:419:18: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
experiments/rainbow_and_ape-x/pacman.py:425:0: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:433:8: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:436:8: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:468:0: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:475:4: W0622: Redefining built-in 'dir' (redefined-builtin)
experiments/rainbow_and_ape-x/pacman.py:468:0: R0913: Too many arguments (7/5) (too-many-arguments)
experiments/rainbow_and_ape-x/pacman.py:468:0: R0914: Too many local variables (19/15) (too-many-locals)
experiments/rainbow_and_ape-x/pacman.py:491:8: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
experiments/rainbow_and_ape-x/pacman.py:512:16: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
experiments/rainbow_and_ape-x/pacman.py:517:0: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:520:4: W0622: Redefining built-in 'dir' (redefined-builtin)
experiments/rainbow_and_ape-x/pacman.py:539:12: C0103: Variable name "s" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:561:16: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
experiments/rainbow_and_ape-x/pacman.py:566:0: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:569:4: R1705: Unnecessary "elif" after "return" (no-else-return)
experiments/rainbow_and_ape-x/pacman.py:566:57: W0613: Unused argument 'output_layer' (unused-argument)
experiments/rainbow_and_ape-x/pacman.py:566:0: R0911: Too many return statements (13/6) (too-many-return-statements)
experiments/rainbow_and_ape-x/pacman.py:566:0: R0912: Too many branches (13/12) (too-many-branches)
experiments/rainbow_and_ape-x/pacman.py:602:0: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:604:4: R1705: Unnecessary "elif" after "return" (no-else-return)
experiments/rainbow_and_ape-x/pacman.py:616:9: R1714: Consider merging these comparisons with "in" to "activation in ('silu', 'swish')" (consider-using-in)
experiments/rainbow_and_ape-x/pacman.py:602:0: R0911: Too many return statements (12/6) (too-many-return-statements)
experiments/rainbow_and_ape-x/pacman.py:642:0: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:647:8: R1705: Unnecessary "else" after "return" (no-else-return)
experiments/rainbow_and_ape-x/pacman.py:661:0: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:667:11: C0103: Variable name "n" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:672:0: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:684:8: C0200: Consider using enumerate instead of iterating with range and len (consider-using-enumerate)
experiments/rainbow_and_ape-x/pacman.py:749:0: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:823:8: C0103: Variable name "l" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:824:8: C0103: Variable name "h" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:832:0: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:833:4: R1705: Unnecessary "elif" after "return" (no-else-return)
experiments/rainbow_and_ape-x/pacman.py:840:31: C0103: Argument name "x" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:840:0: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:845:13: C0103: Argument name "l" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:858:0: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:862:0: C0103: Constant name "_epsilon" doesn't conform to UPPER_CASE naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:865:0: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:875:0: C0115: Missing class docstring (missing-class-docstring)
experiments/rainbow_and_ape-x/pacman.py:875:0: R0903: Too few public methods (1/2) (too-few-public-methods)
experiments/rainbow_and_ape-x/pacman.py:884:0: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:891:0: C0115: Missing class docstring (missing-class-docstring)
experiments/rainbow_and_ape-x/pacman.py:891:0: R0903: Too few public methods (1/2) (too-few-public-methods)
experiments/rainbow_and_ape-x/pacman.py:900:0: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:900:57: W0613: Unused argument 'axis' (unused-argument)
experiments/rainbow_and_ape-x/pacman.py:907:0: C0115: Missing class docstring (missing-class-docstring)
experiments/rainbow_and_ape-x/pacman.py:907:0: R0903: Too few public methods (1/2) (too-few-public-methods)
experiments/rainbow_and_ape-x/pacman.py:916:0: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:922:0: C0115: Missing class docstring (missing-class-docstring)
experiments/rainbow_and_ape-x/pacman.py:922:0: R0903: Too few public methods (1/2) (too-few-public-methods)
experiments/rainbow_and_ape-x/pacman.py:933:38: C0103: Argument name "s" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:945:4: C0103: Variable name "p" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:961:0: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:961:0: R0913: Too many arguments (6/5) (too-many-arguments)
experiments/rainbow_and_ape-x/pacman.py:961:0: R0914: Too many local variables (24/15) (too-many-locals)
experiments/rainbow_and_ape-x/pacman.py:969:25: R1732: Consider using 'with' for resource-allocating operations (consider-using-with)
experiments/rainbow_and_ape-x/pacman.py:971:14: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
experiments/rainbow_and_ape-x/pacman.py:973:14: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
experiments/rainbow_and_ape-x/pacman.py:979:4: W0106: Expression "checkpoints.remove('videos') if 'videos' in checkpoints else None" is assigned to nothing (expression-not-assigned)
experiments/rainbow_and_ape-x/pacman.py:980:4: W0106: Expression "checkpoints.remove('.DS_Store') if '.DS_Store' in checkpoints else None" is assigned to nothing (expression-not-assigned)
experiments/rainbow_and_ape-x/pacman.py:993:11: R1716: Simplify chained comparison between the operands (chained-comparison)
experiments/rainbow_and_ape-x/pacman.py:1008:16: R1732: Consider using 'with' for resource-allocating operations (consider-using-with)
experiments/rainbow_and_ape-x/pacman.py:1044:16: R1714: Consider merging these comparisons with "in" to "eval_method in ('rolling_average', 'final_score_rolling_average')" (consider-using-in)
experiments/rainbow_and_ape-x/pacman.py:1071:10: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
experiments/rainbow_and_ape-x/pacman.py:1074:8: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
experiments/rainbow_and_ape-x/pacman.py:1079:8: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
experiments/rainbow_and_ape-x/pacman.py:1084:10: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
experiments/rainbow_and_ape-x/pacman.py:1085:10: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
experiments/rainbow_and_ape-x/pacman.py:1086:10: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
experiments/rainbow_and_ape-x/pacman.py:1087:10: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
experiments/rainbow_and_ape-x/pacman.py:1089:10: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
experiments/rainbow_and_ape-x/pacman.py:1090:10: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
experiments/rainbow_and_ape-x/pacman.py:1091:10: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
experiments/rainbow_and_ape-x/pacman.py:1092:10: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
experiments/rainbow_and_ape-x/pacman.py:1094:10: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
experiments/rainbow_and_ape-x/pacman.py:1095:10: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
experiments/rainbow_and_ape-x/pacman.py:1096:10: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
experiments/rainbow_and_ape-x/pacman.py:1097:10: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
experiments/rainbow_and_ape-x/pacman.py:1112:8: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
experiments/rainbow_and_ape-x/pacman.py:1117:8: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
experiments/rainbow_and_ape-x/pacman.py:1122:8: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
experiments/rainbow_and_ape-x/pacman.py:961:0: R0915: Too many statements (67/50) (too-many-statements)
experiments/rainbow_and_ape-x/pacman.py:1128:0: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:1153:8: W0621: Redefining name 'plt' from outer scope (line 26) (redefined-outer-name)
experiments/rainbow_and_ape-x/pacman.py:1128:0: R0914: Too many local variables (20/15) (too-many-locals)
experiments/rainbow_and_ape-x/pacman.py:1131:52: C0103: Variable name "f" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:1135:31: R1732: Consider using 'with' for resource-allocating operations (consider-using-with)
experiments/rainbow_and_ape-x/pacman.py:1144:4: C0103: Variable name "df" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:1148:4: C0103: Variable name "df" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:1159:16: R1714: Consider merging these comparisons with "in" to "col in ('kernel_initializer', 'activation')" (consider-using-in)
experiments/rainbow_and_ape-x/pacman.py:1155:8: W0612: Unused variable 'medians' (unused-variable)
experiments/rainbow_and_ape-x/pacman.py:1157:8: W0612: Unused variable 'stddev' (unused-variable)
experiments/rainbow_and_ape-x/pacman.py:1167:0: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:1171:4: R1705: Unnecessary "else" after "return" (no-else-return)
experiments/rainbow_and_ape-x/pacman.py:1179:8: C0103: Variable name "c" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:1181:12: C0103: Variable name "c" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:1185:0: C0115: Missing class docstring (missing-class-docstring)
experiments/rainbow_and_ape-x/pacman.py:1191:15: R1714: Consider merging these comparisons with "in" to "mode in ('fan_in', 'fan_out', 'fan_avg')" (consider-using-in)
experiments/rainbow_and_ape-x/pacman.py:1185:0: R0903: Too few public methods (1/2) (too-few-public-methods)
experiments/rainbow_and_ape-x/pacman.py:1210:15: C0103: Argument name "o" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:1210:0: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:1212:8: C0103: Variable name "it" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:1212:8: W0612: Unused variable 'it' (unused-variable)
experiments/rainbow_and_ape-x/pacman.py:1218:0: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:1218:15: W0622: Redefining built-in 'list' (redefined-builtin)
experiments/rainbow_and_ape-x/pacman.py:1220:8: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:1228:0: C0115: Missing class docstring (missing-class-docstring)
experiments/rainbow_and_ape-x/pacman.py:1232:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:1232:26: W0613: Unused argument 'details' (unused-argument)
experiments/rainbow_and_ape-x/pacman.py:1232:4: R0201: Method could be a function (no-self-use)
experiments/rainbow_and_ape-x/pacman.py:1228:0: R0903: Too few public methods (1/2) (too-few-public-methods)
experiments/rainbow_and_ape-x/pacman.py:1236:0: C0115: Missing class docstring (missing-class-docstring)
experiments/rainbow_and_ape-x/pacman.py:1237:4: W0231: __init__ method from base class 'StoppingCriteria' is not called (super-init-not-called)
experiments/rainbow_and_ape-x/pacman.py:1236:0: R0903: Too few public methods (1/2) (too-few-public-methods)
experiments/rainbow_and_ape-x/pacman.py:1244:0: C0115: Missing class docstring (missing-class-docstring)
experiments/rainbow_and_ape-x/pacman.py:1245:4: W0231: __init__ method from base class 'StoppingCriteria' is not called (super-init-not-called)
experiments/rainbow_and_ape-x/pacman.py:1244:0: R0903: Too few public methods (1/2) (too-few-public-methods)
experiments/rainbow_and_ape-x/pacman.py:1252:0: C0115: Missing class docstring (missing-class-docstring)
experiments/rainbow_and_ape-x/pacman.py:1253:4: W0231: __init__ method from base class 'StoppingCriteria' is not called (super-init-not-called)
experiments/rainbow_and_ape-x/pacman.py:1252:0: R0903: Too few public methods (1/2) (too-few-public-methods)
experiments/rainbow_and_ape-x/pacman.py:1260:0: C0115: Missing class docstring (missing-class-docstring)
experiments/rainbow_and_ape-x/pacman.py:1261:4: W0231: __init__ method from base class 'StoppingCriteria' is not called (super-init-not-called)
experiments/rainbow_and_ape-x/pacman.py:1266:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:1276:0: C0115: Missing class docstring (missing-class-docstring)
experiments/rainbow_and_ape-x/pacman.py:1277:4: W0231: __init__ method from base class 'StoppingCriteria' is not called (super-init-not-called)
experiments/rainbow_and_ape-x/pacman.py:1297:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:1298:8: C0103: Variable name "tc" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:1302:0: C0115: Missing class docstring (missing-class-docstring)
experiments/rainbow_and_ape-x/pacman.py:1302:0: R0902: Too many instance attributes (9/7) (too-many-instance-attributes)
experiments/rainbow_and_ape-x/pacman.py:1303:4: R0913: Too many arguments (10/5) (too-many-arguments)
experiments/rainbow_and_ape-x/pacman.py:1328:21: C0103: Argument name "o" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:1302:0: R0903: Too few public methods (1/2) (too-few-public-methods)
experiments/rainbow_and_ape-x/pacman.py:1345:0: C0115: Missing class docstring (missing-class-docstring)
experiments/rainbow_and_ape-x/pacman.py:1346:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:1346:4: R0913: Too many arguments (6/5) (too-many-arguments)
experiments/rainbow_and_ape-x/pacman.py:1363:8: R1720: Unnecessary "else" after "raise" (no-else-raise)
experiments/rainbow_and_ape-x/pacman.py:1346:4: R1710: Either all return statements in a function should return an expression, or none of them should. (inconsistent-return-statements)
experiments/rainbow_and_ape-x/pacman.py:1347:69: W0613: Unused argument 'dtype' (unused-argument)
experiments/rainbow_and_ape-x/pacman.py:1374:23: W0621: Redefining name 'config_dict' from outer scope (line 3959) (redefined-outer-name)
experiments/rainbow_and_ape-x/pacman.py:1379:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:1380:13: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
experiments/rainbow_and_ape-x/pacman.py:1380:36: C0103: Variable name "f" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:1381:12: C0103: Variable name "o" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:1383:12: C0103: Variable name "a" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:1387:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:1390:13: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
experiments/rainbow_and_ape-x/pacman.py:1390:36: C0103: Variable name "f" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:1394:0: C0115: Missing class docstring (missing-class-docstring)
experiments/rainbow_and_ape-x/pacman.py:1394:0: R0902: Too many instance attributes (17/7) (too-many-instance-attributes)
experiments/rainbow_and_ape-x/pacman.py:1397:13: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
experiments/rainbow_and_ape-x/pacman.py:1397:36: C0103: Variable name "f" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:1398:12: C0103: Variable name "o" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:1400:12: C0103: Variable name "a" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:1407:13: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
experiments/rainbow_and_ape-x/pacman.py:1407:36: C0103: Variable name "f" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:1410:23: W0621: Redefining name 'config_dict' from outer scope (line 3959) (redefined-outer-name)
experiments/rainbow_and_ape-x/pacman.py:1410:42: W0621: Redefining name 'game_config' from outer scope (line 3986) (redefined-outer-name)
experiments/rainbow_and_ape-x/pacman.py:1463:31: C0103: Argument name "x" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:1463:0: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:1464:4: R1705: Unnecessary "elif" after "return" (no-else-return)
experiments/rainbow_and_ape-x/pacman.py:1483:0: C0115: Missing class docstring (missing-class-docstring)
experiments/rainbow_and_ape-x/pacman.py:1483:0: R0902: Too many instance attributes (16/7) (too-many-instance-attributes)
experiments/rainbow_and_ape-x/pacman.py:1486:8: W0621: Redefining name 'env' from outer scope (line 4001) (redefined-outer-name)
experiments/rainbow_and_ape-x/pacman.py:1487:8: W0621: Redefining name 'config' from outer scope (line 3987) (redefined-outer-name)
experiments/rainbow_and_ape-x/pacman.py:1513:28: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
experiments/rainbow_and_ape-x/pacman.py:1547:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:1614:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:1618:19: W0622: Redefining built-in 'dir' (redefined-builtin)
experiments/rainbow_and_ape-x/pacman.py:1631:43: C0103: Variable name "f" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:1634:8: E1101: Instance of 'BaseAgent' has no 'mode' member (no-member)
experiments/rainbow_and_ape-x/pacman.py:1636:8: E1101: Instance of 'BaseAgent' has no 'on_load' member (no-member)
experiments/rainbow_and_ape-x/pacman.py:1625:8: W0612: Unused variable 'name' (unused-variable)
experiments/rainbow_and_ape-x/pacman.py:1638:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:1638:34: W0622: Redefining built-in 'dir' (redefined-builtin)
experiments/rainbow_and_ape-x/pacman.py:1645:13: C0103: Variable name "f" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:1649:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:1652:8: E1101: Instance of 'BaseAgent' has no 'model' member (no-member)
experiments/rainbow_and_ape-x/pacman.py:1654:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:1654:35: W0622: Redefining built-in 'dir' (redefined-builtin)
experiments/rainbow_and_ape-x/pacman.py:1657:51: W1309: Using an f-string that does not have any interpolated variables (f-string-without-interpolation)
experiments/rainbow_and_ape-x/pacman.py:1664:42: W1309: Using an f-string that does not have any interpolated variables (f-string-without-interpolation)
experiments/rainbow_and_ape-x/pacman.py:1664:82: C0103: Variable name "f" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:1671:42: W1309: Using an f-string that does not have any interpolated variables (f-string-without-interpolation)
experiments/rainbow_and_ape-x/pacman.py:1671:79: C0103: Variable name "f" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:1673:42: W1309: Using an f-string that does not have any interpolated variables (f-string-without-interpolation)
experiments/rainbow_and_ape-x/pacman.py:1673:81: C0103: Variable name "f" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:1678:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:1678:34: W0622: Redefining built-in 'dir' (redefined-builtin)
experiments/rainbow_and_ape-x/pacman.py:1685:13: C0103: Variable name "f" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:1688:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:1696:8: W0622: Redefining built-in 'dir' (redefined-builtin)
experiments/rainbow_and_ape-x/pacman.py:1702:55: W1309: Using an f-string that does not have any interpolated variables (f-string-without-interpolation)
experiments/rainbow_and_ape-x/pacman.py:1711:23: E1101: Instance of 'BaseAgent' has no 'model' member (no-member)
experiments/rainbow_and_ape-x/pacman.py:1714:46: W1309: Using an f-string that does not have any interpolated variables (f-string-without-interpolation)
experiments/rainbow_and_ape-x/pacman.py:1714:86: C0103: Variable name "f" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:1726:45: W1309: Using an f-string that does not have any interpolated variables (f-string-without-interpolation)
experiments/rainbow_and_ape-x/pacman.py:1728:42: W1309: Using an f-string that does not have any interpolated variables (f-string-without-interpolation)
experiments/rainbow_and_ape-x/pacman.py:1728:79: C0103: Variable name "f" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:1730:42: W1309: Using an f-string that does not have any interpolated variables (f-string-without-interpolation)
experiments/rainbow_and_ape-x/pacman.py:1730:81: C0103: Variable name "f" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:1749:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:1749:37: W0622: Redefining built-in 'dir' (redefined-builtin)
experiments/rainbow_and_ape-x/pacman.py:1749:4: R0914: Too many local variables (18/15) (too-many-locals)
experiments/rainbow_and_ape-x/pacman.py:1753:12: W0105: String statement has no effect (pointless-string-statement)
experiments/rainbow_and_ape-x/pacman.py:1760:45: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
experiments/rainbow_and_ape-x/pacman.py:1772:33: E1123: Unexpected keyword argument 'env' in method call (unexpected-keyword-arg)
experiments/rainbow_and_ape-x/pacman.py:1749:4: R1710: Either all return statements in a function should return an expression, or none of them should. (inconsistent-return-statements)
experiments/rainbow_and_ape-x/pacman.py:1765:16: W0612: Unused variable 'trials' (unused-variable)
experiments/rainbow_and_ape-x/pacman.py:1647:12: W0201: Attribute 'replay_buffer' defined outside __init__ (attribute-defined-outside-init)
experiments/rainbow_and_ape-x/pacman.py:1665:12: W0201: Attribute 'optimizer' defined outside __init__ (attribute-defined-outside-init)
experiments/rainbow_and_ape-x/pacman.py:1672:12: W0201: Attribute 'stats' defined outside __init__ (attribute-defined-outside-init)
experiments/rainbow_and_ape-x/pacman.py:1674:12: W0201: Attribute 'targets' defined outside __init__ (attribute-defined-outside-init)
experiments/rainbow_and_ape-x/pacman.py:1802:0: C0115: Missing class docstring (missing-class-docstring)
experiments/rainbow_and_ape-x/pacman.py:1804:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
experiments/rainbow_and_ape-x/pacman.py:1802:0: R0903: Too few public methods (0/2) (too-few-public-methods)
experiments/rainbow_and_ape-x/pacman.py:1817:0: C0115: Missing class docstring (missing-class-docstring)
experiments/rainbow_and_ape-x/pacman.py:1817:0: R0902: Too many instance attributes (24/7) (too-many-instance-attributes)
experiments/rainbow_and_ape-x/pacman.py:1818:23: W0621: Redefining name 'config_dict' from outer scope (line 3959) (redefined-outer-name)
experiments/rainbow_and_ape-x/pacman.py:1818:42: W0621: Redefining name 'game_config' from outer scope (line 3986) (redefined-outer-name)
experiments/rainbow_and_ape-x/pacman.py:1819:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
experiments/rainbow_and_ape-x/pacman.py:1878:19: C0121: Comparison 'self.v_min != None' should be 'self.v_min is not None' (singleton-comparison)
experiments/rainbow_and_ape-x/pacman.py:1878:42: C0121: Comparison 'self.v_max != None' should be 'self.v_max is not None' (singleton-comparison)
experiments/rainbow_and_ape-x/pacman.py:1885:0: W0105: String statement has no effect (pointless-string-statement)
experiments/rainbow_and_ape-x/pacman.py:1917:4: R0913: Too many arguments (6/5) (too-many-arguments)
experiments/rainbow_and_ape-x/pacman.py:1924:8: R1705: Unnecessary "else" after "return" (no-else-return)
experiments/rainbow_and_ape-x/pacman.py:1927:12: R1705: Unnecessary "else" after "return" (no-else-return)
experiments/rainbow_and_ape-x/pacman.py:1975:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
experiments/rainbow_and_ape-x/pacman.py:1981:15: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
experiments/rainbow_and_ape-x/pacman.py:1986:53: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
experiments/rainbow_and_ape-x/pacman.py:2016:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
experiments/rainbow_and_ape-x/pacman.py:2022:15: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
experiments/rainbow_and_ape-x/pacman.py:2025:0: C0115: Missing class docstring (missing-class-docstring)
experiments/rainbow_and_ape-x/pacman.py:2025:0: R0205: Class 'FastSumTree' inherits from object, can be safely removed from bases in python3 (useless-object-inheritance)
experiments/rainbow_and_ape-x/pacman.py:2048:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:2057:23: C0103: Argument name "v" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:2057:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:2062:12: R1723: Unnecessary "else" after "break" (no-else-break)
experiments/rainbow_and_ape-x/pacman.py:2075:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:2079:0: C0115: Missing class docstring (missing-class-docstring)
experiments/rainbow_and_ape-x/pacman.py:2091:15: E1101: Instance of 'BaseReplayBuffer' has no 'size' member (no-member)
experiments/rainbow_and_ape-x/pacman.py:2095:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:2098:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:2101:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:2104:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:2107:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:2111:15: E1101: Instance of 'BaseReplayBuffer' has no 'size' member (no-member)
experiments/rainbow_and_ape-x/pacman.py:2114:0: C0115: Missing class docstring (missing-class-docstring)
experiments/rainbow_and_ape-x/pacman.py:2114:0: R0902: Too many instance attributes (8/7) (too-many-instance-attributes)
experiments/rainbow_and_ape-x/pacman.py:2128:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:2128:4: R0913: Too many arguments (7/5) (too-many-arguments)
experiments/rainbow_and_ape-x/pacman.py:2145:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:2160:0: C0115: Missing class docstring (missing-class-docstring)
experiments/rainbow_and_ape-x/pacman.py:2160:0: W0223: Method 'load' is abstract in class 'BaseReplayBuffer' but is not overridden (abstract-method)
experiments/rainbow_and_ape-x/pacman.py:2160:0: W0223: Method 'sample_from_indices' is abstract in class 'BaseReplayBuffer' but is not overridden (abstract-method)
experiments/rainbow_and_ape-x/pacman.py:2168:4: W0221: Number of parameters was 3 in 'BaseReplayBuffer.store' and is now 2 in overridden 'BaseGameReplayBuffer.store' method (arguments-differ)
experiments/rainbow_and_ape-x/pacman.py:2168:4: W0221: Variadics removed in overridden 'BaseGameReplayBuffer.store' method (arguments-differ)
experiments/rainbow_and_ape-x/pacman.py:2174:4: W0221: Variadics removed in overridden 'BaseGameReplayBuffer.sample' method (arguments-differ)
experiments/rainbow_and_ape-x/pacman.py:2189:0: C0115: Missing class docstring (missing-class-docstring)
experiments/rainbow_and_ape-x/pacman.py:2189:0: R0902: Too many instance attributes (12/7) (too-many-instance-attributes)
experiments/rainbow_and_ape-x/pacman.py:2189:0: W0223: Method 'load' is abstract in class 'BaseReplayBuffer' but is not overridden (abstract-method)
experiments/rainbow_and_ape-x/pacman.py:2190:4: R0913: Too many arguments (6/5) (too-many-arguments)
experiments/rainbow_and_ape-x/pacman.py:2216:8: W0622: Redefining built-in 'id' (redefined-builtin)
experiments/rainbow_and_ape-x/pacman.py:2207:4: R0913: Too many arguments (9/5) (too-many-arguments)
experiments/rainbow_and_ape-x/pacman.py:2207:4: W0221: Number of parameters was 3 in 'BaseReplayBuffer.store' and is now 9 in overridden 'BaseDQNReplayBuffer.store' method (arguments-differ)
experiments/rainbow_and_ape-x/pacman.py:2207:4: W0221: Variadics removed in overridden 'BaseDQNReplayBuffer.store' method (arguments-differ)
experiments/rainbow_and_ape-x/pacman.py:2253:4: W0221: Variadics removed in overridden 'BaseDQNReplayBuffer.sample' method (arguments-differ)
experiments/rainbow_and_ape-x/pacman.py:2279:39: C0103: Argument name "id" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:2279:39: W0622: Redefining built-in 'id' (redefined-builtin)
experiments/rainbow_and_ape-x/pacman.py:2228:8: W0201: Attribute 'pointer' defined outside __init__ (attribute-defined-outside-init)
experiments/rainbow_and_ape-x/pacman.py:2229:8: W0201: Attribute 'size' defined outside __init__ (attribute-defined-outside-init)
experiments/rainbow_and_ape-x/pacman.py:2283:0: C0115: Missing class docstring (missing-class-docstring)
experiments/rainbow_and_ape-x/pacman.py:2283:0: R0902: Too many instance attributes (16/7) (too-many-instance-attributes)
experiments/rainbow_and_ape-x/pacman.py:2283:0: W0223: Method 'load' is abstract in class 'BaseReplayBuffer' but is not overridden (abstract-method)
experiments/rainbow_and_ape-x/pacman.py:2283:0: W0223: Method 'sample_from_indices' is abstract in class 'BaseReplayBuffer' but is not overridden (abstract-method)
experiments/rainbow_and_ape-x/pacman.py:2284:4: R0913: Too many arguments (7/5) (too-many-arguments)
experiments/rainbow_and_ape-x/pacman.py:2309:8: W0622: Redefining built-in 'id' (redefined-builtin)
experiments/rainbow_and_ape-x/pacman.py:2301:4: R0913: Too many arguments (8/5) (too-many-arguments)
experiments/rainbow_and_ape-x/pacman.py:2301:4: W0221: Number of parameters was 3 in 'BaseReplayBuffer.store' and is now 8 in overridden 'BasePPOReplayBuffer.store' method (arguments-differ)
experiments/rainbow_and_ape-x/pacman.py:2301:4: W0221: Variadics removed in overridden 'BasePPOReplayBuffer.store' method (arguments-differ)
experiments/rainbow_and_ape-x/pacman.py:2309:8: W0613: Unused argument 'id' (unused-argument)
experiments/rainbow_and_ape-x/pacman.py:2321:4: W0221: Variadics removed in overridden 'BasePPOReplayBuffer.sample' method (arguments-differ)
experiments/rainbow_and_ape-x/pacman.py:2361:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:2318:8: W0201: Attribute 'pointer' defined outside __init__ (attribute-defined-outside-init)
experiments/rainbow_and_ape-x/pacman.py:2322:8: W0201: Attribute 'pointer' defined outside __init__ (attribute-defined-outside-init)
experiments/rainbow_and_ape-x/pacman.py:2319:8: W0201: Attribute 'size' defined outside __init__ (attribute-defined-outside-init)
experiments/rainbow_and_ape-x/pacman.py:2322:22: W0201: Attribute 'trajectory_start_index' defined outside __init__ (attribute-defined-outside-init)
experiments/rainbow_and_ape-x/pacman.py:2378:8: W0201: Attribute 'trajectory_start_index' defined outside __init__ (attribute-defined-outside-init)
experiments/rainbow_and_ape-x/pacman.py:2325:8: W0201: Attribute 'advantage_buffer' defined outside __init__ (attribute-defined-outside-init)
experiments/rainbow_and_ape-x/pacman.py:2381:0: C0115: Missing class docstring (missing-class-docstring)
experiments/rainbow_and_ape-x/pacman.py:2381:0: W0223: Method 'load' is abstract in class 'BaseReplayBuffer' but is not overridden (abstract-method)
experiments/rainbow_and_ape-x/pacman.py:2382:4: R0913: Too many arguments (9/5) (too-many-arguments)
experiments/rainbow_and_ape-x/pacman.py:2413:8: W0622: Redefining built-in 'id' (redefined-builtin)
experiments/rainbow_and_ape-x/pacman.py:2404:4: R0913: Too many arguments (10/5) (too-many-arguments)
experiments/rainbow_and_ape-x/pacman.py:2404:4: W0221: Number of parameters was 9 in 'BaseDQNReplayBuffer.store' and is now 10 in overridden 'NStepReplayBuffer.store' method (arguments-differ)
experiments/rainbow_and_ape-x/pacman.py:2462:12: C0103: Variable name "r" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:2462:25: C0103: Variable name "d" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:2471:0: C0115: Missing class docstring (missing-class-docstring)
experiments/rainbow_and_ape-x/pacman.py:2471:0: W0223: Method 'load' is abstract in class 'BaseReplayBuffer' but is not overridden (abstract-method)
experiments/rainbow_and_ape-x/pacman.py:2472:4: R0913: Too many arguments (12/5) (too-many-arguments)
experiments/rainbow_and_ape-x/pacman.py:2487:15: R1716: Simplify chained comparison between the operands (chained-comparison)
experiments/rainbow_and_ape-x/pacman.py:2488:15: R1716: Simplify chained comparison between the operands (chained-comparison)
experiments/rainbow_and_ape-x/pacman.py:2490:15: R1716: Simplify chained comparison between the operands (chained-comparison)
experiments/rainbow_and_ape-x/pacman.py:2493:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
experiments/rainbow_and_ape-x/pacman.py:2517:8: W0622: Redefining built-in 'id' (redefined-builtin)
experiments/rainbow_and_ape-x/pacman.py:2508:4: R0913: Too many arguments (11/5) (too-many-arguments)
experiments/rainbow_and_ape-x/pacman.py:2508:4: W0221: Number of parameters was 10 in 'NStepReplayBuffer.store' and is now 11 in overridden 'PrioritizedNStepReplayBuffer.store' method (arguments-differ)
experiments/rainbow_and_ape-x/pacman.py:2546:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:2549:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:2561:8: C0200: Consider using enumerate instead of iterating with range and len (consider-using-enumerate)
experiments/rainbow_and_ape-x/pacman.py:2574:4: W0221: Number of parameters was 1 in 'BaseDQNReplayBuffer.sample' and is now 2 in overridden 'PrioritizedNStepReplayBuffer.sample' method (arguments-differ)
experiments/rainbow_and_ape-x/pacman.py:2576:12: R1720: Unnecessary "else" after "raise" (no-else-raise)
experiments/rainbow_and_ape-x/pacman.py:2577:16: E0702: Raising str while only classes or instances are allowed (raising-bad-type)
experiments/rainbow_and_ape-x/pacman.py:2577:22: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
experiments/rainbow_and_ape-x/pacman.py:2609:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:2615:23: W0622: Redefining built-in 'id' (redefined-builtin)
experiments/rainbow_and_ape-x/pacman.py:2615:23: C0103: Variable name "id" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:2618:19: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
experiments/rainbow_and_ape-x/pacman.py:2632:37: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
experiments/rainbow_and_ape-x/pacman.py:2649:12: C0103: Variable name "a" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:2650:12: C0103: Variable name "b" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:2535:12: W0201: Attribute 'max_priority' defined outside __init__ (attribute-defined-outside-init)
experiments/rainbow_and_ape-x/pacman.py:2628:16: W0201: Attribute 'max_priority' defined outside __init__ (attribute-defined-outside-init)
experiments/rainbow_and_ape-x/pacman.py:2637:16: W0201: Attribute 'max_priority' defined outside __init__ (attribute-defined-outside-init)
experiments/rainbow_and_ape-x/pacman.py:2542:12: W0201: Attribute 'tree_pointer' defined outside __init__ (attribute-defined-outside-init)
experiments/rainbow_and_ape-x/pacman.py:2667:0: C0115: Missing class docstring (missing-class-docstring)
experiments/rainbow_and_ape-x/pacman.py:2667:0: W0223: Method 'load' is abstract in class 'BaseReplayBuffer' but is not overridden (abstract-method)
experiments/rainbow_and_ape-x/pacman.py:2668:4: R0913: Too many arguments (9/5) (too-many-arguments)
experiments/rainbow_and_ape-x/pacman.py:2680:15: R1716: Simplify chained comparison between the operands (chained-comparison)
experiments/rainbow_and_ape-x/pacman.py:2681:15: R1716: Simplify chained comparison between the operands (chained-comparison)
experiments/rainbow_and_ape-x/pacman.py:2683:15: R1716: Simplify chained comparison between the operands (chained-comparison)
experiments/rainbow_and_ape-x/pacman.py:2685:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
experiments/rainbow_and_ape-x/pacman.py:2699:4: R0913: Too many arguments (6/5) (too-many-arguments)
experiments/rainbow_and_ape-x/pacman.py:2699:4: W0221: Number of parameters was 10 in 'NStepReplayBuffer.store' and is now 6 in overridden 'FastPrioritizedReplayBuffer.store' method (arguments-differ)
experiments/rainbow_and_ape-x/pacman.py:2707:21: E1120: No value for argument 'next_info' in method call (no-value-for-parameter)
experiments/rainbow_and_ape-x/pacman.py:2707:21: E1120: No value for argument 'done' in method call (no-value-for-parameter)
experiments/rainbow_and_ape-x/pacman.py:2719:4: R0914: Too many local variables (17/15) (too-many-locals)
experiments/rainbow_and_ape-x/pacman.py:2727:12: C0103: Variable name "a" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:2727:15: C0103: Variable name "b" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:2766:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:2771:33: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
experiments/rainbow_and_ape-x/pacman.py:2780:11: C0103: Argument name "x" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:2780:0: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:2788:8: W0621: Redefining name 'e' from outer scope (line 8) (redefined-outer-name)
experiments/rainbow_and_ape-x/pacman.py:2781:4: R1705: Unnecessary "else" after "return" (no-else-return)
experiments/rainbow_and_ape-x/pacman.py:2788:15: W0703: Catching too general exception Exception (broad-except)
experiments/rainbow_and_ape-x/pacman.py:2788:8: C0103: Variable name "e" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:2780:0: R1710: Either all return statements in a function should return an expression, or none of them should. (inconsistent-return-statements)
experiments/rainbow_and_ape-x/pacman.py:2792:0: C0115: Missing class docstring (missing-class-docstring)
experiments/rainbow_and_ape-x/pacman.py:2794:37: C0103: Argument name "s" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:2806:8: C0103: Variable name "h" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:2806:11: C0103: Variable name "w" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:2811:8: R1705: Unnecessary "else" after "return" (no-else-return)
experiments/rainbow_and_ape-x/pacman.py:2817:4: R0913: Too many arguments (7/5) (too-many-arguments)
experiments/rainbow_and_ape-x/pacman.py:2830:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
experiments/rainbow_and_ape-x/pacman.py:2846:8: C0200: Consider using enumerate instead of iterating with range and len (consider-using-enumerate)
experiments/rainbow_and_ape-x/pacman.py:2848:12: C0103: Variable name "h" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:2848:15: C0103: Variable name "w" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:2877:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:2878:31: C0103: Argument name "m" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:2884:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:2885:8: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:2887:12: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:2890:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:2899:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:2909:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:2913:0: C0115: Missing class docstring (missing-class-docstring)
experiments/rainbow_and_ape-x/pacman.py:2914:4: W1113: Keyword argument before variable positional arguments list in the definition of __init__ function (keyword-arg-before-vararg)
experiments/rainbow_and_ape-x/pacman.py:2917:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
experiments/rainbow_and_ape-x/pacman.py:2922:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:2925:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:2928:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:2932:0: R0902: Too many instance attributes (11/7) (too-many-instance-attributes)
experiments/rainbow_and_ape-x/pacman.py:2936:4: C0103: Method name "f" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:2936:10: C0103: Argument name "x" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:2936:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:2939:4: R0913: Too many arguments (6/5) (too-many-arguments)
experiments/rainbow_and_ape-x/pacman.py:2971:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:2984:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:2989:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:2990:8: C0103: Variable name "p" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:3005:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:3009:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:3010:8: R1705: Unnecessary "else" after "return" (no-else-return)
experiments/rainbow_and_ape-x/pacman.py:3015:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:3018:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:3018:22: W0622: Redefining built-in 'input' (redefined-builtin)
experiments/rainbow_and_ape-x/pacman.py:3021:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:3025:0: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:3026:4: R1705: Unnecessary "else" after "return" (no-else-return)
experiments/rainbow_and_ape-x/pacman.py:3032:0: C0115: Missing class docstring (missing-class-docstring)
experiments/rainbow_and_ape-x/pacman.py:3040:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
experiments/rainbow_and_ape-x/pacman.py:3048:8: C0200: Consider using enumerate instead of iterating with range and len (consider-using-enumerate)
experiments/rainbow_and_ape-x/pacman.py:3060:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:3064:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:3065:8: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:3067:12: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:3070:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:3070:4: R1711: Useless return at end of function or method (useless-return)
experiments/rainbow_and_ape-x/pacman.py:3077:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:3077:4: R1711: Useless return at end of function or method (useless-return)
experiments/rainbow_and_ape-x/pacman.py:3084:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:3088:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:3092:0: C0115: Missing class docstring (missing-class-docstring)
experiments/rainbow_and_ape-x/pacman.py:3093:4: R0913: Too many arguments (7/5) (too-many-arguments)
experiments/rainbow_and_ape-x/pacman.py:3106:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
experiments/rainbow_and_ape-x/pacman.py:3125:8: C0200: Consider using enumerate instead of iterating with range and len (consider-using-enumerate)
experiments/rainbow_and_ape-x/pacman.py:3138:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:3139:31: C0103: Argument name "m" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:3145:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:3146:8: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:3148:12: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:3151:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:3160:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:3170:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:3174:0: C0115: Missing class docstring (missing-class-docstring)
experiments/rainbow_and_ape-x/pacman.py:3182:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
experiments/rainbow_and_ape-x/pacman.py:3223:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:3224:31: C0103: Argument name "m" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:3230:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:3233:8: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:3234:8: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:3235:8: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:3236:8: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:3237:8: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:3238:8: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:3242:0: C0115: Missing class docstring (missing-class-docstring)
experiments/rainbow_and_ape-x/pacman.py:3242:0: R0902: Too many instance attributes (15/7) (too-many-instance-attributes)
experiments/rainbow_and_ape-x/pacman.py:3245:8: W0621: Redefining name 'config' from outer scope (line 3987) (redefined-outer-name)
experiments/rainbow_and_ape-x/pacman.py:3270:8: C0103: Variable name "B" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:3275:15: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
experiments/rainbow_and_ape-x/pacman.py:3297:15: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
experiments/rainbow_and_ape-x/pacman.py:3340:15: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
experiments/rainbow_and_ape-x/pacman.py:3243:4: R0912: Too many branches (14/12) (too-many-branches)
experiments/rainbow_and_ape-x/pacman.py:3243:4: R0915: Too many statements (52/50) (too-many-statements)
experiments/rainbow_and_ape-x/pacman.py:3386:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:3401:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:3406:8: C0103: Variable name "S" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:3409:12: C0103: Variable name "S" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:3413:12: C0103: Variable name "S" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:3416:8: C0103: Variable name "S" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:3420:12: C0103: Variable name "S" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:3425:16: C0103: Variable name "v" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:3427:16: C0103: Variable name "v" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:3430:12: C0103: Variable name "v" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:3434:16: C0103: Variable name "A" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:3436:16: C0103: Variable name "A" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:3439:12: C0103: Variable name "A" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:3450:12: C0103: Variable name "Q" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:3458:12: C0103: Variable name "Q" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:3462:8: R1705: Unnecessary "else" after "return" (no-else-return)
experiments/rainbow_and_ape-x/pacman.py:3467:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:3483:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:3500:0: C0115: Missing class docstring (missing-class-docstring)
experiments/rainbow_and_ape-x/pacman.py:3500:0: R0902: Too many instance attributes (9/7) (too-many-instance-attributes)
experiments/rainbow_and_ape-x/pacman.py:3503:8: W0621: Redefining name 'env' from outer scope (line 4001) (redefined-outer-name)
experiments/rainbow_and_ape-x/pacman.py:3504:8: W0621: Redefining name 'config' from outer scope (line 3987) (redefined-outer-name)
experiments/rainbow_and_ape-x/pacman.py:3501:4: R0913: Too many arguments (6/5) (too-many-arguments)
experiments/rainbow_and_ape-x/pacman.py:3518:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
experiments/rainbow_and_ape-x/pacman.py:3530:15: C0121: Comparison 'self.config.kernel_initializer == None' should be 'self.config.kernel_initializer is None' (singleton-comparison)
experiments/rainbow_and_ape-x/pacman.py:3596:4: W0221: Number of parameters was 3 in 'BaseAgent.predict' and is now 4 in overridden 'RainbowAgent.predict' method (arguments-differ)
experiments/rainbow_and_ape-x/pacman.py:3596:0: W0613: Unused argument 'kwargs' (unused-argument)
experiments/rainbow_and_ape-x/pacman.py:3602:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:3608:4: W0237: Parameter 'predicted' has been renamed to 'distribution' in overridden 'RainbowAgent.select_actions' method (arguments-renamed)
experiments/rainbow_and_ape-x/pacman.py:3643:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:3662:19: R1701: Consider merging these isinstance calls to isinstance(self.config.loss_function, (CategoricalCrossentropyLoss, KLDivergenceLoss)) (consider-merging-isinstance)
experiments/rainbow_and_ape-x/pacman.py:3666:15: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
experiments/rainbow_and_ape-x/pacman.py:3672:19: R1701: Consider merging these isinstance calls to isinstance(self.config.loss_function, (HuberLoss, MSELoss)) (consider-merging-isinstance)
experiments/rainbow_and_ape-x/pacman.py:3674:15: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
experiments/rainbow_and_ape-x/pacman.py:3711:49: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
experiments/rainbow_and_ape-x/pacman.py:3716:11: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
experiments/rainbow_and_ape-x/pacman.py:3736:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:3739:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:3739:4: R0914: Too many local variables (16/15) (too-many-locals)
experiments/rainbow_and_ape-x/pacman.py:3767:12: C0103: Variable name "Tz" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:3773:12: C0103: Variable name "b" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:3774:12: C0103: Variable name "l" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:3774:15: C0103: Variable name "u" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:3791:12: C0103: Variable name "m" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:3806:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:3829:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:3831:16: C0103: Variable name "wt" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:3831:20: C0103: Variable name "wp" doesn't conform to snake_case naming style (invalid-name)
experiments/rainbow_and_ape-x/pacman.py:3836:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:3852:16: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
experiments/rainbow_and_ape-x/pacman.py:3857:4: R0914: Too many local variables (20/15) (too-many-locals)
experiments/rainbow_and_ape-x/pacman.py:3914:16: W0612: Unused variable 'minibatch' (unused-variable)
experiments/rainbow_and_ape-x/pacman.py:3990:0: C0115: Missing class docstring (missing-class-docstring)
experiments/rainbow_and_ape-x/pacman.py:3991:23: W0621: Redefining name 'env' from outer scope (line 4001) (redefined-outer-name)
experiments/rainbow_and_ape-x/pacman.py:3997:4: C0116: Missing function or method docstring (missing-function-docstring)
experiments/rainbow_and_ape-x/pacman.py:3990:0: R0903: Too few public methods (1/2) (too-few-public-methods)
experiments/rainbow_and_ape-x/pacman.py:8:0: W0611: Unused e imported from math (unused-import)
experiments/rainbow_and_ape-x/pacman.py:12:0: W0611: Unused get_distribution imported from pkg_resources (unused-import)
experiments/rainbow_and_ape-x/pacman.py:14:0: W0611: Unused import sys (unused-import)
experiments/rainbow_and_ape-x/pacman.py:7:0: C0411: standard import "import math" should be placed before "import gymnasium as gym" (wrong-import-order)
experiments/rainbow_and_ape-x/pacman.py:8:0: C0411: standard import "from math import e" should be placed before "import gymnasium as gym" (wrong-import-order)
experiments/rainbow_and_ape-x/pacman.py:10:0: C0411: standard import "from time import time" should be placed before "import gymnasium as gym" (wrong-import-order)
experiments/rainbow_and_ape-x/pacman.py:14:0: C0411: standard import "import sys" should be placed before "import gymnasium as gym" (wrong-import-order)
experiments/rainbow_and_ape-x/pacman.py:15:0: C0411: standard import "import os" should be placed before "import gymnasium as gym" (wrong-import-order)
experiments/rainbow_and_ape-x/pacman.py:17:0: C0411: standard import "import random" should be placed before "import gymnasium as gym" (wrong-import-order)
experiments/rainbow_and_ape-x/pacman.py:19:0: C0411: standard import "from collections import defaultdict" should be placed before "import gymnasium as gym" (wrong-import-order)
experiments/rainbow_and_ape-x/pacman.py:20:0: C0411: standard import "from collections import deque" should be placed before "import gymnasium as gym" (wrong-import-order)
experiments/rainbow_and_ape-x/pacman.py:22:0: C0411: standard import "import operator" should be placed before "import gymnasium as gym" (wrong-import-order)
experiments/rainbow_and_ape-x/pacman.py:23:0: C0411: standard import "from operator import itemgetter" should be placed before "import gymnasium as gym" (wrong-import-order)
experiments/rainbow_and_ape-x/pacman.py:32:0: C0411: standard import "import pickle" should be placed before "import gymnasium as gym" (wrong-import-order)
experiments/rainbow_and_ape-x/pacman.py:33:0: C0411: standard import "from datetime import datetime" should be placed before "import gymnasium as gym" (wrong-import-order)
experiments/rainbow_and_ape-x/pacman.py:34:0: C0411: standard import "import itertools" should be placed before "import gymnasium as gym" (wrong-import-order)
experiments/rainbow_and_ape-x/pacman.py:38:0: C0411: standard import "from typing import Callable, Tuple, Iterable" should be placed before "import gymnasium as gym" (wrong-import-order)
experiments/rainbow_and_ape-x/pacman.py:47:0: C0411: standard import "from collections import deque" should be placed before "import gymnasium as gym" (wrong-import-order)
experiments/rainbow_and_ape-x/pacman.py:51:0: C0411: standard import "import gc" should be placed before "import gymnasium as gym" (wrong-import-order)
experiments/rainbow_and_ape-x/pacman.py:52:0: C0411: standard import "from pathlib import Path" should be placed before "import gymnasium as gym" (wrong-import-order)
experiments/rainbow_and_ape-x/pacman.py:53:0: C0411: standard import "import copy" should be placed before "import gymnasium as gym" (wrong-import-order)
experiments/rainbow_and_ape-x/pacman.py:47:0: C0412: Imports from package collections are not grouped (ungrouped-imports)
************* Module rl-research.imitation_learning.policy_imitation_agent
imitation_learning/policy_imitation_agent.py:21:0: C0301: Line too long (128/100) (line-too-long)
imitation_learning/policy_imitation_agent.py:1:0: C0114: Missing module docstring (missing-module-docstring)
imitation_learning/policy_imitation_agent.py:1:0: E0401: Unable to import 'torch' (import-error)
imitation_learning/policy_imitation_agent.py:2:0: E0611: No name 'action_mask' in module 'utils' (no-name-in-module)
imitation_learning/policy_imitation_agent.py:2:0: E0611: No name 'normalize_policies' in module 'utils' (no-name-in-module)
imitation_learning/policy_imitation_agent.py:2:0: E0611: No name 'current_timestamp' in module 'utils' (no-name-in-module)
imitation_learning/policy_imitation_agent.py:2:0: E0611: No name 'get_legal_moves' in module 'utils' (no-name-in-module)
imitation_learning/policy_imitation_agent.py:4:0: E0401: Unable to import 'base_agent.agent' (import-error)
imitation_learning/policy_imitation_agent.py:5:0: E0401: Unable to import 'torch.nn.utils' (import-error)
imitation_learning/policy_imitation_agent.py:6:0: E0401: Unable to import 'torch.optim' (import-error)
imitation_learning/policy_imitation_agent.py:8:0: E0401: Unable to import 'imitation_learning.supervised_network' (import-error)
imitation_learning/policy_imitation_agent.py:9:0: E0401: Unable to import 'replay_buffers.nfsp_reservoir_buffer' (import-error)
imitation_learning/policy_imitation_agent.py:12:0: C0115: Missing class docstring (missing-class-docstring)
imitation_learning/policy_imitation_agent.py:13:4: R0913: Too many arguments (6/5) (too-many-arguments)
imitation_learning/policy_imitation_agent.py:60:4: C0116: Missing function or method docstring (missing-function-docstring)
imitation_learning/policy_imitation_agent.py:60:4: R0201: Method could be a function (no-self-use)
imitation_learning/policy_imitation_agent.py:66:4: C0116: Missing function or method docstring (missing-function-docstring)
imitation_learning/policy_imitation_agent.py:80:4: C0116: Missing function or method docstring (missing-function-docstring)
imitation_learning/policy_imitation_agent.py:81:12: W0612: Unused variable 'training_iteration' (unused-variable)
imitation_learning/policy_imitation_agent.py:5:0: C0411: third party import "from torch.nn.utils import clip_grad_norm_" should be placed before "from base_agent.agent import BaseAgent" (wrong-import-order)
imitation_learning/policy_imitation_agent.py:6:0: C0411: third party import "from torch.optim import Adam, SGD" should be placed before "from base_agent.agent import BaseAgent" (wrong-import-order)
************* Module rl-research.imitation_learning.supervised_network
imitation_learning/supervised_network.py:1:0: C0114: Missing module docstring (missing-module-docstring)
imitation_learning/supervised_network.py:2:0: E0401: Unable to import 'torch' (import-error)
imitation_learning/supervised_network.py:4:0: E0401: Unable to import 'modules.conv' (import-error)
imitation_learning/supervised_network.py:6:0: E0401: Unable to import 'modules.dense' (import-error)
imitation_learning/supervised_network.py:7:0: E0401: Unable to import 'modules.residual' (import-error)
imitation_learning/supervised_network.py:8:0: R0402: Use 'from torch import nn' instead (consider-using-from-import)
imitation_learning/supervised_network.py:8:0: E0401: Unable to import 'torch.nn' (import-error)
imitation_learning/supervised_network.py:11:0: C0115: Missing class docstring (missing-class-docstring)
imitation_learning/supervised_network.py:11:0: R0902: Too many instance attributes (9/7) (too-many-instance-attributes)
imitation_learning/supervised_network.py:25:8: C0103: Variable name "B" doesn't conform to snake_case naming style (invalid-name)
imitation_learning/supervised_network.py:30:15: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
imitation_learning/supervised_network.py:52:15: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
imitation_learning/supervised_network.py:77:19: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
imitation_learning/supervised_network.py:12:0: W0613: Unused argument 'args' (unused-argument)
imitation_learning/supervised_network.py:12:0: W0613: Unused argument 'kwargs' (unused-argument)
imitation_learning/supervised_network.py:104:4: C0116: Missing function or method docstring (missing-function-docstring)
imitation_learning/supervised_network.py:115:4: C0116: Missing function or method docstring (missing-function-docstring)
imitation_learning/supervised_network.py:119:8: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
imitation_learning/supervised_network.py:121:12: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
imitation_learning/supervised_network.py:124:12: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
imitation_learning/supervised_network.py:126:8: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
imitation_learning/supervised_network.py:129:12: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
imitation_learning/supervised_network.py:130:8: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
imitation_learning/supervised_network.py:133:4: C0116: Missing function or method docstring (missing-function-docstring)
imitation_learning/supervised_network.py:8:0: C0411: third party import "import torch.nn as nn" should be placed before "from modules.conv import Conv2dStack" (wrong-import-order)
************* Module conv
modules/conv.py:28:0: C0301: Line too long (201/100) (line-too-long)
modules/conv.py:54:0: C0301: Line too long (106/100) (line-too-long)
modules/conv.py:1:0: C0114: Missing module docstring (missing-module-docstring)
modules/conv.py:3:0: E0401: Unable to import 'torch' (import-error)
modules/conv.py:4:0: E0611: No name 'calculate_padding' in module 'utils' (no-name-in-module)
modules/conv.py:7:11: C0103: Argument name "x" doesn't conform to snake_case naming style (invalid-name)
modules/conv.py:7:0: C0116: Missing function or method docstring (missing-function-docstring)
modules/conv.py:8:4: R1705: Unnecessary "else" after "return" (no-else-return)
modules/conv.py:15:15: W0703: Catching too general exception Exception (broad-except)
modules/conv.py:15:8: C0103: Variable name "e" doesn't conform to snake_case naming style (invalid-name)
modules/conv.py:7:0: R1710: Either all return statements in a function should return an expression, or none of them should. (inconsistent-return-statements)
modules/conv.py:19:0: C0115: Missing class docstring (missing-class-docstring)
modules/conv.py:21:37: C0103: Argument name "s" doesn't conform to snake_case naming style (invalid-name)
modules/conv.py:33:8: C0103: Variable name "h" doesn't conform to snake_case naming style (invalid-name)
modules/conv.py:33:11: C0103: Variable name "w" doesn't conform to snake_case naming style (invalid-name)
modules/conv.py:38:8: R1705: Unnecessary "else" after "return" (no-else-return)
modules/conv.py:44:4: R0913: Too many arguments (7/5) (too-many-arguments)
modules/conv.py:57:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
modules/conv.py:73:8: C0200: Consider using enumerate instead of iterating with range and len (consider-using-enumerate)
modules/conv.py:75:12: C0103: Variable name "h" doesn't conform to snake_case naming style (invalid-name)
modules/conv.py:75:15: C0103: Variable name "w" doesn't conform to snake_case naming style (invalid-name)
modules/conv.py:104:4: C0116: Missing function or method docstring (missing-function-docstring)
modules/conv.py:105:31: C0103: Argument name "m" doesn't conform to snake_case naming style (invalid-name)
modules/conv.py:111:4: C0116: Missing function or method docstring (missing-function-docstring)
modules/conv.py:112:8: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
modules/conv.py:114:12: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
modules/conv.py:117:4: C0116: Missing function or method docstring (missing-function-docstring)
modules/conv.py:126:4: C0116: Missing function or method docstring (missing-function-docstring)
modules/conv.py:136:4: C0116: Missing function or method docstring (missing-function-docstring)
************* Module dense
modules/dense.py:116:0: C0301: Line too long (186/100) (line-too-long)
modules/dense.py:180:0: C0301: Line too long (101/100) (line-too-long)
modules/dense.py:1:0: C0114: Missing module docstring (missing-module-docstring)
modules/dense.py:3:0: E0401: Unable to import 'torch' (import-error)
modules/dense.py:4:0: E0401: Unable to import 'torch' (import-error)
modules/dense.py:7:0: C0115: Missing class docstring (missing-class-docstring)
modules/dense.py:8:4: W1113: Keyword argument before variable positional arguments list in the definition of __init__ function (keyword-arg-before-vararg)
modules/dense.py:11:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
modules/dense.py:16:4: C0116: Missing function or method docstring (missing-function-docstring)
modules/dense.py:19:4: C0116: Missing function or method docstring (missing-function-docstring)
modules/dense.py:22:4: C0116: Missing function or method docstring (missing-function-docstring)
modules/dense.py:26:0: R0902: Too many instance attributes (11/7) (too-many-instance-attributes)
modules/dense.py:30:4: C0103: Method name "f" doesn't conform to snake_case naming style (invalid-name)
modules/dense.py:30:10: C0103: Argument name "x" doesn't conform to snake_case naming style (invalid-name)
modules/dense.py:30:4: C0116: Missing function or method docstring (missing-function-docstring)
modules/dense.py:33:4: R0913: Too many arguments (6/5) (too-many-arguments)
modules/dense.py:65:4: C0116: Missing function or method docstring (missing-function-docstring)
modules/dense.py:78:4: C0116: Missing function or method docstring (missing-function-docstring)
modules/dense.py:83:4: C0116: Missing function or method docstring (missing-function-docstring)
modules/dense.py:84:8: C0103: Variable name "p" doesn't conform to snake_case naming style (invalid-name)
modules/dense.py:99:4: C0116: Missing function or method docstring (missing-function-docstring)
modules/dense.py:103:4: C0116: Missing function or method docstring (missing-function-docstring)
modules/dense.py:104:8: R1705: Unnecessary "else" after "return" (no-else-return)
modules/dense.py:109:4: C0116: Missing function or method docstring (missing-function-docstring)
modules/dense.py:112:4: C0116: Missing function or method docstring (missing-function-docstring)
modules/dense.py:112:22: W0622: Redefining built-in 'input' (redefined-builtin)
modules/dense.py:115:4: C0116: Missing function or method docstring (missing-function-docstring)
modules/dense.py:119:0: C0116: Missing function or method docstring (missing-function-docstring)
modules/dense.py:120:4: R1705: Unnecessary "else" after "return" (no-else-return)
modules/dense.py:126:0: C0115: Missing class docstring (missing-class-docstring)
modules/dense.py:134:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
modules/dense.py:142:8: C0200: Consider using enumerate instead of iterating with range and len (consider-using-enumerate)
modules/dense.py:154:4: C0116: Missing function or method docstring (missing-function-docstring)
modules/dense.py:158:4: C0116: Missing function or method docstring (missing-function-docstring)
modules/dense.py:159:8: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
modules/dense.py:161:12: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
modules/dense.py:164:4: C0116: Missing function or method docstring (missing-function-docstring)
modules/dense.py:164:4: R1711: Useless return at end of function or method (useless-return)
modules/dense.py:171:4: C0116: Missing function or method docstring (missing-function-docstring)
modules/dense.py:171:4: R1711: Useless return at end of function or method (useless-return)
modules/dense.py:179:4: C0116: Missing function or method docstring (missing-function-docstring)
modules/dense.py:183:4: C0116: Missing function or method docstring (missing-function-docstring)
************* Module residual
modules/residual.py:18:0: C0301: Line too long (106/100) (line-too-long)
modules/residual.py:1:0: C0114: Missing module docstring (missing-module-docstring)
modules/residual.py:3:0: E0401: Unable to import 'torch' (import-error)
modules/residual.py:4:0: E0611: No name 'calculate_padding' in module 'utils' (no-name-in-module)
modules/residual.py:7:0: C0115: Missing class docstring (missing-class-docstring)
modules/residual.py:8:4: R0913: Too many arguments (7/5) (too-many-arguments)
modules/residual.py:21:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
modules/residual.py:40:8: C0200: Consider using enumerate instead of iterating with range and len (consider-using-enumerate)
modules/residual.py:53:4: C0116: Missing function or method docstring (missing-function-docstring)
modules/residual.py:54:31: C0103: Argument name "m" doesn't conform to snake_case naming style (invalid-name)
modules/residual.py:60:4: C0116: Missing function or method docstring (missing-function-docstring)
modules/residual.py:61:8: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
modules/residual.py:63:12: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
modules/residual.py:66:4: C0116: Missing function or method docstring (missing-function-docstring)
modules/residual.py:75:4: C0116: Missing function or method docstring (missing-function-docstring)
modules/residual.py:85:4: C0116: Missing function or method docstring (missing-function-docstring)
modules/residual.py:89:0: C0115: Missing class docstring (missing-class-docstring)
modules/residual.py:97:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
modules/residual.py:138:4: C0116: Missing function or method docstring (missing-function-docstring)
modules/residual.py:139:31: C0103: Argument name "m" doesn't conform to snake_case naming style (invalid-name)
modules/residual.py:145:4: C0116: Missing function or method docstring (missing-function-docstring)
modules/residual.py:148:8: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
modules/residual.py:149:8: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
modules/residual.py:150:8: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
modules/residual.py:151:8: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
modules/residual.py:152:8: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
modules/residual.py:153:8: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
modules/residual.py:4:0: W0611: Unused calculate_padding imported from utils (unused-import)
************* Module rl-research.muzero.muzero_agent
muzero/muzero_agent.py:1:0: C0114: Missing module docstring (missing-module-docstring)
muzero/muzero_agent.py:5:0: E0401: Unable to import 'alphazero.alphazero_agent' (import-error)
muzero/muzero_agent.py:6:0: E0401: Unable to import 'muzero.muzero_minmax_stats' (import-error)
muzero/muzero_agent.py:10:0: C0413: Import "import os" should be placed at the top of the module (wrong-import-position)
muzero/muzero_agent.py:17:0: E0401: Unable to import 'tensorflow' (import-error)
muzero/muzero_agent.py:17:0: C0413: Import "import tensorflow as tf" should be placed at the top of the module (wrong-import-position)
muzero/muzero_agent.py:34:0: C0413: Import "import copy" should be placed at the top of the module (wrong-import-position)
muzero/muzero_agent.py:35:0: C0413: Import "import numpy as np" should be placed at the top of the module (wrong-import-position)
muzero/muzero_agent.py:36:0: W0404: Reimport 'tensorflow' (imported line 17) (reimported)
muzero/muzero_agent.py:36:0: E0401: Unable to import 'tensorflow' (import-error)
muzero/muzero_agent.py:36:0: C0413: Import "import tensorflow as tf" should be placed at the top of the module (wrong-import-position)
muzero/muzero_agent.py:37:0: E0401: Unable to import 'replay_buffers.muzero_replay_buffer' (import-error)
muzero/muzero_agent.py:37:0: C0413: Import "from replay_buffers.muzero_replay_buffer import ReplayBuffer, Game" should be placed at the top of the module (wrong-import-position)
muzero/muzero_agent.py:38:0: C0413: Import "import math" should be placed at the top of the module (wrong-import-position)
muzero/muzero_agent.py:39:0: E0401: Unable to import 'muzero.muzero_mcts' (import-error)
muzero/muzero_agent.py:39:0: C0413: Import "from muzero.muzero_mcts import Node" should be placed at the top of the module (wrong-import-position)
muzero/muzero_agent.py:40:0: E0401: Unable to import 'muzero.muzero_network' (import-error)
muzero/muzero_agent.py:40:0: C0413: Import "from muzero.muzero_network import Network" should be placed at the top of the module (wrong-import-position)
muzero/muzero_agent.py:41:0: C0413: Import "import matplotlib.pyplot as plt" should be placed at the top of the module (wrong-import-position)
muzero/muzero_agent.py:42:0: E0401: Unable to import 'gymnasium' (import-error)
muzero/muzero_agent.py:42:0: C0413: Import "import gymnasium as gym" should be placed at the top of the module (wrong-import-position)
muzero/muzero_agent.py:45:0: C0115: Missing class docstring (missing-class-docstring)
muzero/muzero_agent.py:46:4: W0235: Useless super delegation in method '__init__' (useless-super-delegation)
muzero/muzero_agent.py:47:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
muzero/muzero_agent.py:49:4: C0116: Missing function or method docstring (missing-function-docstring)
muzero/muzero_agent.py:57:4: C0116: Missing function or method docstring (missing-function-docstring)
muzero/muzero_agent.py:84:16: E1101: Instance of 'MuZeroAgent' has no 'total_environment_steps' member (no-member)
muzero/muzero_agent.py:70:8: W0612: Unused variable 'targets' (unused-variable)
muzero/muzero_agent.py:82:16: W0612: Unused variable 'training_game' (unused-variable)
muzero/muzero_agent.py:88:16: W0612: Unused variable 'minibatch' (unused-variable)
muzero/muzero_agent.py:106:4: C0116: Missing function or method docstring (missing-function-docstring)
muzero/muzero_agent.py:106:4: R0914: Too many local variables (19/15) (too-many-locals)
muzero/muzero_agent.py:110:71: E0601: Using variable 'reward' before assignment (used-before-assignment)
muzero/muzero_agent.py:106:38: W0613: Unused argument 'env' (unused-argument)
muzero/muzero_agent.py:151:4: C0116: Missing function or method docstring (missing-function-docstring)
muzero/muzero_agent.py:151:4: R0914: Too many local variables (27/15) (too-many-locals)
muzero/muzero_agent.py:159:12: W0612: Unused variable 'training_iteration' (unused-variable)
muzero/muzero_agent.py:229:4: C0116: Missing function or method docstring (missing-function-docstring)
muzero/muzero_agent.py:235:4: C0116: Missing function or method docstring (missing-function-docstring)
muzero/muzero_agent.py:243:4: C0116: Missing function or method docstring (missing-function-docstring)
muzero/muzero_agent.py:244:30: E1120: No value for argument 'action_history' in method call (no-value-for-parameter)
muzero/muzero_agent.py:259:8: R1705: Unnecessary "else" after "return" (no-else-return)
muzero/muzero_agent.py:264:4: C0116: Missing function or method docstring (missing-function-docstring)
muzero/muzero_agent.py:60:30: E0203: Access to member 'training_time' before its definition line 100 (access-member-before-definition)
muzero/muzero_agent.py:100:16: W0201: Attribute 'training_time' defined outside __init__ (attribute-defined-outside-init)
muzero/muzero_agent.py:102:8: W0201: Attribute 'training_time' defined outside __init__ (attribute-defined-outside-init)
muzero/muzero_agent.py:1:0: W0611: Unused import gc (unused-import)
muzero/muzero_agent.py:37:0: W0611: Unused ReplayBuffer imported from replay_buffers.muzero_replay_buffer (unused-import)
muzero/muzero_agent.py:38:0: W0611: Unused import math (unused-import)
muzero/muzero_agent.py:40:0: W0611: Unused Network imported from muzero.muzero_network (unused-import)
muzero/muzero_agent.py:41:0: W0611: Unused matplotlib.pyplot imported as plt (unused-import)
muzero/muzero_agent.py:42:0: W0611: Unused gymnasium imported as gym (unused-import)
muzero/muzero_agent.py:10:0: C0411: standard import "import os" should be placed before "from alphazero.alphazero_agent import AlphaZeroAgent" (wrong-import-order)
muzero/muzero_agent.py:17:0: C0411: third party import "import tensorflow as tf" should be placed before "from alphazero.alphazero_agent import AlphaZeroAgent" (wrong-import-order)
muzero/muzero_agent.py:34:0: C0411: standard import "import copy" should be placed before "import tensorflow as tf" (wrong-import-order)
muzero/muzero_agent.py:35:0: C0411: third party import "import numpy as np" should be placed before "from alphazero.alphazero_agent import AlphaZeroAgent" (wrong-import-order)
muzero/muzero_agent.py:36:0: C0411: third party import "import tensorflow as tf" should be placed before "from alphazero.alphazero_agent import AlphaZeroAgent" (wrong-import-order)
muzero/muzero_agent.py:38:0: C0411: standard import "import math" should be placed before "import tensorflow as tf" (wrong-import-order)
muzero/muzero_agent.py:41:0: C0411: third party import "import matplotlib.pyplot as plt" should be placed before "from alphazero.alphazero_agent import AlphaZeroAgent" (wrong-import-order)
muzero/muzero_agent.py:42:0: C0411: third party import "import gymnasium as gym" should be placed before "from alphazero.alphazero_agent import AlphaZeroAgent" (wrong-import-order)
muzero/muzero_agent.py:36:0: C0412: Imports from package tensorflow are not grouped (ungrouped-imports)
muzero/muzero_agent.py:39:0: C0412: Imports from package muzero are not grouped (ungrouped-imports)
************* Module rl-research.muzero.muzero_mcts
muzero/muzero_mcts.py:1:0: C0114: Missing module docstring (missing-module-docstring)
muzero/muzero_mcts.py:7:0: C0115: Missing class docstring (missing-class-docstring)
muzero/muzero_mcts.py:17:4: C0116: Missing function or method docstring (missing-function-docstring)
muzero/muzero_mcts.py:17:4: R0913: Too many arguments (6/5) (too-many-arguments)
muzero/muzero_mcts.py:25:20: C0103: Variable name "p" doesn't conform to snake_case naming style (invalid-name)
muzero/muzero_mcts.py:28:4: C0116: Missing function or method docstring (missing-function-docstring)
muzero/muzero_mcts.py:31:4: C0116: Missing function or method docstring (missing-function-docstring)
muzero/muzero_mcts.py:36:4: C0116: Missing function or method docstring (missing-function-docstring)
muzero/muzero_mcts.py:40:12: C0103: Variable name "a" doesn't conform to snake_case naming style (invalid-name)
muzero/muzero_mcts.py:40:15: C0103: Variable name "n" doesn't conform to snake_case naming style (invalid-name)
muzero/muzero_mcts.py:45:4: C0116: Missing function or method docstring (missing-function-docstring)
muzero/muzero_mcts.py:59:4: C0116: Missing function or method docstring (missing-function-docstring)
muzero/muzero_mcts.py:1:0: W0611: Unused deepcopy imported from copy (unused-import)
muzero/muzero_mcts.py:2:0: W0611: Unused inf imported from math (unused-import)
muzero/muzero_mcts.py:3:0: W0611: Unused import copy (unused-import)
************* Module rl-research.muzero.muzero_minmax_stats
muzero/muzero_minmax_stats.py:1:0: C0114: Missing module docstring (missing-module-docstring)
muzero/muzero_minmax_stats.py:8:0: C0115: Missing class docstring (missing-class-docstring)
muzero/muzero_minmax_stats.py:8:0: R0205: Class 'MinMaxStats' inherits from object, can be safely removed from bases in python3 (useless-object-inheritance)
muzero/muzero_minmax_stats.py:15:4: C0116: Missing function or method docstring (missing-function-docstring)
muzero/muzero_minmax_stats.py:19:4: C0116: Missing function or method docstring (missing-function-docstring)
************* Module rl-research.muzero.muzero_network
muzero/muzero_network.py:1:0: C0114: Missing module docstring (missing-module-docstring)
muzero/muzero_network.py:2:0: E0611: No name 'alphazero_config' in module 'agent_configs' (no-name-in-module)
muzero/muzero_network.py:2:0: E0401: Unable to import 'agent_configs.alphazero_config' (import-error)
muzero/muzero_network.py:3:0: E0401: Unable to import 'torch' (import-error)
muzero/muzero_network.py:6:0: E0401: Unable to import 'modules.conv' (import-error)
muzero/muzero_network.py:7:0: E0401: Unable to import 'modules.dense' (import-error)
muzero/muzero_network.py:8:0: E0401: Unable to import 'modules.residual' (import-error)
muzero/muzero_network.py:9:0: E0401: Unable to import 'torch' (import-error)
muzero/muzero_network.py:12:0: C0115: Missing class docstring (missing-class-docstring)
muzero/muzero_network.py:12:0: R0902: Too many instance attributes (9/7) (too-many-instance-attributes)
muzero/muzero_network.py:25:8: E1003: Bad first argument 'Network' given to super() (bad-super-call)
muzero/muzero_network.py:37:8: C0103: Variable name "B" doesn't conform to snake_case naming style (invalid-name)
muzero/muzero_network.py:44:15: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
muzero/muzero_network.py:68:15: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
muzero/muzero_network.py:109:11: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
muzero/muzero_network.py:125:4: C0116: Missing function or method docstring (missing-function-docstring)
muzero/muzero_network.py:134:4: C0116: Missing function or method docstring (missing-function-docstring)
muzero/muzero_network.py:139:8: C0103: Variable name "S" doesn't conform to snake_case naming style (invalid-name)
muzero/muzero_network.py:146:12: C0103: Variable name "S" doesn't conform to snake_case naming style (invalid-name)
muzero/muzero_network.py:150:12: C0103: Variable name "S" doesn't conform to snake_case naming style (invalid-name)
muzero/muzero_network.py:156:12: C0103: Variable name "S" doesn't conform to snake_case naming style (invalid-name)
muzero/muzero_network.py:157:12: C0103: Variable name "S" doesn't conform to snake_case naming style (invalid-name)
muzero/muzero_network.py:162:0: C0115: Missing class docstring (missing-class-docstring)
muzero/muzero_network.py:162:0: R0902: Too many instance attributes (9/7) (too-many-instance-attributes)
muzero/muzero_network.py:175:8: E1003: Bad first argument 'Network' given to super() (bad-super-call)
muzero/muzero_network.py:187:8: C0103: Variable name "B" doesn't conform to snake_case naming style (invalid-name)
muzero/muzero_network.py:194:15: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
muzero/muzero_network.py:216:15: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
muzero/muzero_network.py:257:11: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
muzero/muzero_network.py:271:4: C0116: Missing function or method docstring (missing-function-docstring)
muzero/muzero_network.py:280:4: C0116: Missing function or method docstring (missing-function-docstring)
muzero/muzero_network.py:285:8: C0103: Variable name "S" doesn't conform to snake_case naming style (invalid-name)
muzero/muzero_network.py:292:12: C0103: Variable name "S" doesn't conform to snake_case naming style (invalid-name)
muzero/muzero_network.py:296:12: C0103: Variable name "S" doesn't conform to snake_case naming style (invalid-name)
muzero/muzero_network.py:302:12: C0103: Variable name "S" doesn't conform to snake_case naming style (invalid-name)
muzero/muzero_network.py:303:12: C0103: Variable name "S" doesn't conform to snake_case naming style (invalid-name)
muzero/muzero_network.py:308:0: C0115: Missing class docstring (missing-class-docstring)
muzero/muzero_network.py:308:0: R0902: Too many instance attributes (10/7) (too-many-instance-attributes)
muzero/muzero_network.py:321:8: E1003: Bad first argument 'Network' given to super() (bad-super-call)
muzero/muzero_network.py:333:8: C0103: Variable name "B" doesn't conform to snake_case naming style (invalid-name)
muzero/muzero_network.py:340:15: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
muzero/muzero_network.py:362:15: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
muzero/muzero_network.py:403:4: C0116: Missing function or method docstring (missing-function-docstring)
muzero/muzero_network.py:414:4: C0116: Missing function or method docstring (missing-function-docstring)
muzero/muzero_network.py:419:8: C0103: Variable name "S" doesn't conform to snake_case naming style (invalid-name)
muzero/muzero_network.py:424:12: C0103: Variable name "S" doesn't conform to snake_case naming style (invalid-name)
muzero/muzero_network.py:428:12: C0103: Variable name "S" doesn't conform to snake_case naming style (invalid-name)
muzero/muzero_network.py:434:12: C0103: Variable name "S" doesn't conform to snake_case naming style (invalid-name)
muzero/muzero_network.py:435:12: C0103: Variable name "S" doesn't conform to snake_case naming style (invalid-name)
muzero/muzero_network.py:440:0: C0115: Missing class docstring (missing-class-docstring)
muzero/muzero_network.py:450:8: C0103: Variable name "B" doesn't conform to snake_case naming style (invalid-name)
muzero/muzero_network.py:503:4: C0116: Missing function or method docstring (missing-function-docstring)
muzero/muzero_network.py:510:4: C0116: Missing function or method docstring (missing-function-docstring)
muzero/muzero_network.py:514:15: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
muzero/muzero_network.py:516:8: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
muzero/muzero_network.py:518:12: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
muzero/muzero_network.py:520:12: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
muzero/muzero_network.py:521:12: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
muzero/muzero_network.py:525:4: C0116: Missing function or method docstring (missing-function-docstring)
muzero/muzero_network.py:533:0: C0115: Missing class docstring (missing-class-docstring)
muzero/muzero_network.py:548:8: C0103: Variable name "B" doesn't conform to snake_case naming style (invalid-name)
muzero/muzero_network.py:576:19: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
muzero/muzero_network.py:604:4: C0116: Missing function or method docstring (missing-function-docstring)
muzero/muzero_network.py:613:4: C0116: Missing function or method docstring (missing-function-docstring)
muzero/muzero_network.py:617:15: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
muzero/muzero_network.py:619:8: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
muzero/muzero_network.py:621:12: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
muzero/muzero_network.py:623:12: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
muzero/muzero_network.py:624:12: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
muzero/muzero_network.py:628:4: C0116: Missing function or method docstring (missing-function-docstring)
muzero/muzero_network.py:636:0: C0115: Missing class docstring (missing-class-docstring)
muzero/muzero_network.py:638:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
muzero/muzero_network.py:640:30: E1120: No value for argument 'input_shape' in constructor call (no-value-for-parameter)
muzero/muzero_network.py:641:24: E1120: No value for argument 'input_shape' in constructor call (no-value-for-parameter)
muzero/muzero_network.py:642:26: E1121: Too many positional arguments for constructor call (too-many-function-args)
muzero/muzero_network.py:646:32: C0103: Argument name "x" doesn't conform to snake_case naming style (invalid-name)
muzero/muzero_network.py:646:4: C0116: Missing function or method docstring (missing-function-docstring)
muzero/muzero_network.py:651:4: C0116: Missing function or method docstring (missing-function-docstring)
muzero/muzero_network.py:9:0: C0411: third party import "import torch" should be placed before "from modules.conv import Conv2dStack" (wrong-import-order)
************* Module agent_configs.agent_configs.__init__
packages/agent_configs/agent_configs/__init__.py:21:0: C0304: Final newline missing (missing-final-newline)
************* Module agent_configs.agent_configs
packages/agent_configs/agent_configs/__init__.py:1:0: C0114: Missing module docstring (missing-module-docstring)
************* Module agent_configs.agent_configs.a2c_config
packages/agent_configs/agent_configs/a2c_config.py:27:0: C0301: Line too long (109/100) (line-too-long)
packages/agent_configs/agent_configs/a2c_config.py:36:0: C0301: Line too long (110/100) (line-too-long)
packages/agent_configs/agent_configs/a2c_config.py:46:0: C0301: Line too long (110/100) (line-too-long)
packages/agent_configs/agent_configs/a2c_config.py:73:0: C0305: Trailing newlines (trailing-newlines)
packages/agent_configs/agent_configs/a2c_config.py:1:0: C0114: Missing module docstring (missing-module-docstring)
packages/agent_configs/agent_configs/a2c_config.py:1:0: E0611: No name 'actor_config' in module 'agent_configs' (no-name-in-module)
packages/agent_configs/agent_configs/a2c_config.py:1:0: E0401: Unable to import 'agent_configs.actor_config' (import-error)
packages/agent_configs/agent_configs/a2c_config.py:2:0: E0611: No name 'critic_config' in module 'agent_configs' (no-name-in-module)
packages/agent_configs/agent_configs/a2c_config.py:2:0: E0401: Unable to import 'agent_configs.critic_config' (import-error)
packages/agent_configs/agent_configs/a2c_config.py:4:0: E0611: No name 'CategoricalCrossentropyLoss' in module 'utils' (no-name-in-module)
packages/agent_configs/agent_configs/a2c_config.py:4:0: E0611: No name 'tointlists' in module 'utils' (no-name-in-module)
packages/agent_configs/agent_configs/a2c_config.py:7:0: C0115: Missing class docstring (missing-class-docstring)
packages/agent_configs/agent_configs/a2c_config.py:7:0: R0902: Too many instance attributes (16/7) (too-many-instance-attributes)
packages/agent_configs/agent_configs/a2c_config.py:11:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
packages/agent_configs/agent_configs/a2c_config.py:4:0: W0611: Unused CategoricalCrossentropyLoss imported from utils (unused-import)
packages/agent_configs/agent_configs/a2c_config.py:4:0: W0611: Unused tointlists imported from utils (unused-import)
packages/agent_configs/agent_configs/a2c_config.py:4:0: C0411: third party import "from utils import CategoricalCrossentropyLoss, tointlists" should be placed before "from .base_config import Config" (wrong-import-order)
************* Module agent_configs.agent_configs.actor_config
packages/agent_configs/agent_configs/actor_config.py:1:0: C0114: Missing module docstring (missing-module-docstring)
packages/agent_configs/agent_configs/actor_config.py:2:0: E0401: Unable to import 'torch.optim' (import-error)
packages/agent_configs/agent_configs/actor_config.py:5:0: C0115: Missing class docstring (missing-class-docstring)
packages/agent_configs/agent_configs/actor_config.py:2:0: C0411: third party import "from torch.optim import Optimizer, Adam" should be placed before "from .base_config import ConfigBase" (wrong-import-order)
************* Module agent_configs.agent_configs.alphazero_config
packages/agent_configs/agent_configs/alphazero_config.py:68:0: C0301: Line too long (116/100) (line-too-long)
packages/agent_configs/agent_configs/alphazero_config.py:1:0: C0114: Missing module docstring (missing-module-docstring)
packages/agent_configs/agent_configs/alphazero_config.py:2:0: E0611: No name 'CategoricalCrossentropyLoss' in module 'utils' (no-name-in-module)
packages/agent_configs/agent_configs/alphazero_config.py:2:0: E0611: No name 'tointlists' in module 'utils' (no-name-in-module)
packages/agent_configs/agent_configs/alphazero_config.py:5:0: C0115: Missing class docstring (missing-class-docstring)
packages/agent_configs/agent_configs/alphazero_config.py:5:0: R0902: Too many instance attributes (20/7) (too-many-instance-attributes)
packages/agent_configs/agent_configs/alphazero_config.py:2:0: W0611: Unused CategoricalCrossentropyLoss imported from utils (unused-import)
packages/agent_configs/agent_configs/alphazero_config.py:2:0: C0411: third party import "from utils import CategoricalCrossentropyLoss, tointlists" should be placed before "from .base_config import Config" (wrong-import-order)
************* Module agent_configs.agent_configs.base_config
packages/agent_configs/agent_configs/base_config.py:1:0: C0114: Missing module docstring (missing-module-docstring)
packages/agent_configs/agent_configs/base_config.py:1:0: E0401: Unable to import 'torch' (import-error)
packages/agent_configs/agent_configs/base_config.py:2:0: E0611: No name 'Loss' in module 'utils' (no-name-in-module)
packages/agent_configs/agent_configs/base_config.py:5:0: E0611: No name 'GameConfig' in module 'game_configs' (no-name-in-module)
packages/agent_configs/agent_configs/base_config.py:6:0: E0611: No name 'prepare_kernel_initializers' in module 'utils' (no-name-in-module)
packages/agent_configs/agent_configs/base_config.py:6:0: E0611: No name 'prepare_activations' in module 'utils' (no-name-in-module)
packages/agent_configs/agent_configs/base_config.py:12:0: C0115: Missing class docstring (missing-class-docstring)
packages/agent_configs/agent_configs/base_config.py:13:4: C0116: Missing function or method docstring (missing-function-docstring)
packages/agent_configs/agent_configs/base_config.py:13:4: R0913: Too many arguments (6/5) (too-many-arguments)
packages/agent_configs/agent_configs/base_config.py:30:8: R1720: Unnecessary "else" after "raise" (no-else-raise)
packages/agent_configs/agent_configs/base_config.py:13:4: R1710: Either all return statements in a function should return an expression, or none of them should. (inconsistent-return-statements)
packages/agent_configs/agent_configs/base_config.py:14:69: W0613: Unused argument 'dtype' (unused-argument)
packages/agent_configs/agent_configs/base_config.py:46:4: C0116: Missing function or method docstring (missing-function-docstring)
packages/agent_configs/agent_configs/base_config.py:47:13: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
packages/agent_configs/agent_configs/base_config.py:47:36: C0103: Variable name "f" doesn't conform to snake_case naming style (invalid-name)
packages/agent_configs/agent_configs/base_config.py:48:12: C0103: Variable name "o" doesn't conform to snake_case naming style (invalid-name)
packages/agent_configs/agent_configs/base_config.py:50:12: C0103: Variable name "a" doesn't conform to snake_case naming style (invalid-name)
packages/agent_configs/agent_configs/base_config.py:54:4: C0116: Missing function or method docstring (missing-function-docstring)
packages/agent_configs/agent_configs/base_config.py:57:13: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
packages/agent_configs/agent_configs/base_config.py:57:36: C0103: Variable name "f" doesn't conform to snake_case naming style (invalid-name)
packages/agent_configs/agent_configs/base_config.py:61:0: C0115: Missing class docstring (missing-class-docstring)
packages/agent_configs/agent_configs/base_config.py:61:0: R0902: Too many instance attributes (18/7) (too-many-instance-attributes)
packages/agent_configs/agent_configs/base_config.py:64:13: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
packages/agent_configs/agent_configs/base_config.py:64:36: C0103: Variable name "f" doesn't conform to snake_case naming style (invalid-name)
packages/agent_configs/agent_configs/base_config.py:65:12: C0103: Variable name "o" doesn't conform to snake_case naming style (invalid-name)
packages/agent_configs/agent_configs/base_config.py:67:12: C0103: Variable name "a" doesn't conform to snake_case naming style (invalid-name)
packages/agent_configs/agent_configs/base_config.py:74:13: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
packages/agent_configs/agent_configs/base_config.py:74:36: C0103: Variable name "f" doesn't conform to snake_case naming style (invalid-name)
packages/agent_configs/agent_configs/base_config.py:131:31: C0103: Argument name "x" doesn't conform to snake_case naming style (invalid-name)
packages/agent_configs/agent_configs/base_config.py:131:0: C0116: Missing function or method docstring (missing-function-docstring)
packages/agent_configs/agent_configs/base_config.py:132:4: R1705: Unnecessary "elif" after "return" (no-else-return)
packages/agent_configs/agent_configs/base_config.py:6:0: C0412: Imports from package utils are not grouped (ungrouped-imports)
************* Module agent_configs.agent_configs.critic_config
packages/agent_configs/agent_configs/critic_config.py:1:0: C0114: Missing module docstring (missing-module-docstring)
packages/agent_configs/agent_configs/critic_config.py:2:0: E0401: Unable to import 'torch.optim' (import-error)
packages/agent_configs/agent_configs/critic_config.py:5:0: C0115: Missing class docstring (missing-class-docstring)
packages/agent_configs/agent_configs/critic_config.py:2:0: C0411: third party import "from torch.optim import Optimizer, Adam" should be placed before "from .base_config import ConfigBase" (wrong-import-order)
************* Module agent_configs.agent_configs.distributed_configs
packages/agent_configs/agent_configs/distributed_configs.py:1:0: C0114: Missing module docstring (missing-module-docstring)
packages/agent_configs/agent_configs/distributed_configs.py:1:0: E0611: No name 'base_config' in module 'agent_configs' (no-name-in-module)
packages/agent_configs/agent_configs/distributed_configs.py:1:0: E0401: Unable to import 'agent_configs.base_config' (import-error)
packages/agent_configs/agent_configs/distributed_configs.py:4:0: C0115: Missing class docstring (missing-class-docstring)
packages/agent_configs/agent_configs/distributed_configs.py:4:0: R0903: Too few public methods (0/2) (too-few-public-methods)
packages/agent_configs/agent_configs/distributed_configs.py:18:0: C0115: Missing class docstring (missing-class-docstring)
packages/agent_configs/agent_configs/distributed_configs.py:18:0: R0903: Too few public methods (0/2) (too-few-public-methods)
packages/agent_configs/agent_configs/distributed_configs.py:27:0: C0115: Missing class docstring (missing-class-docstring)
packages/agent_configs/agent_configs/distributed_configs.py:27:0: R0903: Too few public methods (0/2) (too-few-public-methods)
************* Module ape_x_config
packages/agent_configs/agent_configs/dqn/ape_x_config.py:14:0: C0301: Line too long (127/100) (line-too-long)
packages/agent_configs/agent_configs/dqn/ape_x_config.py:1:0: C0114: Missing module docstring (missing-module-docstring)
packages/agent_configs/agent_configs/dqn/ape_x_config.py:1:0: E0611: No name 'distributed_configs' in module 'agent_configs' (no-name-in-module)
packages/agent_configs/agent_configs/dqn/ape_x_config.py:1:0: E0401: Unable to import 'agent_configs.distributed_configs' (import-error)
packages/agent_configs/agent_configs/dqn/ape_x_config.py:5:0: E0402: Attempted relative import beyond top-level package (relative-beyond-top-level)
packages/agent_configs/agent_configs/dqn/ape_x_config.py:8:0: C0115: Missing class docstring (missing-class-docstring)
packages/agent_configs/agent_configs/dqn/ape_x_config.py:9:4: W0235: Useless super delegation in method '__init__' (useless-super-delegation)
packages/agent_configs/agent_configs/dqn/ape_x_config.py:11:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
packages/agent_configs/agent_configs/dqn/ape_x_config.py:8:0: R0903: Too few public methods (0/2) (too-few-public-methods)
packages/agent_configs/agent_configs/dqn/ape_x_config.py:17:0: C0115: Missing class docstring (missing-class-docstring)
packages/agent_configs/agent_configs/dqn/ape_x_config.py:20:8: E1003: Bad first argument 'DistributedLearnerConfig' given to super() (bad-super-call)
packages/agent_configs/agent_configs/dqn/ape_x_config.py:19:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
packages/agent_configs/agent_configs/dqn/ape_x_config.py:17:0: R0903: Too few public methods (0/2) (too-few-public-methods)
packages/agent_configs/agent_configs/dqn/ape_x_config.py:35:0: C0115: Missing class docstring (missing-class-docstring)
packages/agent_configs/agent_configs/dqn/ape_x_config.py:38:8: E1003: Bad first argument 'DistributedActorConfig' given to super() (bad-super-call)
packages/agent_configs/agent_configs/dqn/ape_x_config.py:37:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
packages/agent_configs/agent_configs/dqn/ape_x_config.py:35:0: R0903: Too few public methods (0/2) (too-few-public-methods)
************* Module categorical_dqn_config
packages/agent_configs/agent_configs/dqn/categorical_dqn_config.py:22:0: C0301: Line too long (225/100) (line-too-long)
packages/agent_configs/agent_configs/dqn/categorical_dqn_config.py:24:0: C0301: Line too long (185/100) (line-too-long)
packages/agent_configs/agent_configs/dqn/categorical_dqn_config.py:1:0: C0114: Missing module docstring (missing-module-docstring)
packages/agent_configs/agent_configs/dqn/categorical_dqn_config.py:1:0: E0611: No name 'dqn' in module 'agent_configs' (no-name-in-module)
packages/agent_configs/agent_configs/dqn/categorical_dqn_config.py:1:0: E0401: Unable to import 'agent_configs.dqn.rainbow_config' (import-error)
packages/agent_configs/agent_configs/dqn/categorical_dqn_config.py:4:0: C0115: Missing class docstring (missing-class-docstring)
packages/agent_configs/agent_configs/dqn/categorical_dqn_config.py:4:0: R0902: Too many instance attributes (10/7) (too-many-instance-attributes)
packages/agent_configs/agent_configs/dqn/categorical_dqn_config.py:6:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
packages/agent_configs/agent_configs/dqn/categorical_dqn_config.py:4:0: R0903: Too few public methods (0/2) (too-few-public-methods)
************* Module double_dqn_config
packages/agent_configs/agent_configs/dqn/double_dqn_config.py:21:0: C0301: Line too long (225/100) (line-too-long)
packages/agent_configs/agent_configs/dqn/double_dqn_config.py:23:0: C0301: Line too long (185/100) (line-too-long)
packages/agent_configs/agent_configs/dqn/double_dqn_config.py:1:0: C0114: Missing module docstring (missing-module-docstring)
packages/agent_configs/agent_configs/dqn/double_dqn_config.py:1:0: E0611: No name 'dqn' in module 'agent_configs' (no-name-in-module)
packages/agent_configs/agent_configs/dqn/double_dqn_config.py:1:0: E0401: Unable to import 'agent_configs.dqn.rainbow_config' (import-error)
packages/agent_configs/agent_configs/dqn/double_dqn_config.py:4:0: C0115: Missing class docstring (missing-class-docstring)
packages/agent_configs/agent_configs/dqn/double_dqn_config.py:4:0: R0902: Too many instance attributes (9/7) (too-many-instance-attributes)
packages/agent_configs/agent_configs/dqn/double_dqn_config.py:6:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
packages/agent_configs/agent_configs/dqn/double_dqn_config.py:4:0: R0903: Too few public methods (0/2) (too-few-public-methods)
************* Module dqn_config
packages/agent_configs/agent_configs/dqn/dqn_config.py:23:0: C0301: Line too long (225/100) (line-too-long)
packages/agent_configs/agent_configs/dqn/dqn_config.py:25:0: C0301: Line too long (185/100) (line-too-long)
packages/agent_configs/agent_configs/dqn/dqn_config.py:1:0: C0114: Missing module docstring (missing-module-docstring)
packages/agent_configs/agent_configs/dqn/dqn_config.py:1:0: E0611: No name 'dqn' in module 'agent_configs' (no-name-in-module)
packages/agent_configs/agent_configs/dqn/dqn_config.py:1:0: E0401: Unable to import 'agent_configs.dqn.rainbow_config' (import-error)
packages/agent_configs/agent_configs/dqn/dqn_config.py:4:0: C0115: Missing class docstring (missing-class-docstring)
packages/agent_configs/agent_configs/dqn/dqn_config.py:4:0: R0902: Too many instance attributes (11/7) (too-many-instance-attributes)
packages/agent_configs/agent_configs/dqn/dqn_config.py:6:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
packages/agent_configs/agent_configs/dqn/dqn_config.py:4:0: R0903: Too few public methods (0/2) (too-few-public-methods)
************* Module dueling_dqn_config
packages/agent_configs/agent_configs/dqn/dueling_dqn_config.py:28:0: C0301: Line too long (225/100) (line-too-long)
packages/agent_configs/agent_configs/dqn/dueling_dqn_config.py:30:0: C0301: Line too long (185/100) (line-too-long)
packages/agent_configs/agent_configs/dqn/dueling_dqn_config.py:1:0: C0114: Missing module docstring (missing-module-docstring)
packages/agent_configs/agent_configs/dqn/dueling_dqn_config.py:1:0: E0611: No name 'dqn' in module 'agent_configs' (no-name-in-module)
packages/agent_configs/agent_configs/dqn/dueling_dqn_config.py:1:0: E0401: Unable to import 'agent_configs.dqn.rainbow_config' (import-error)
packages/agent_configs/agent_configs/dqn/dueling_dqn_config.py:4:0: C0115: Missing class docstring (missing-class-docstring)
packages/agent_configs/agent_configs/dqn/dueling_dqn_config.py:4:0: R0902: Too many instance attributes (16/7) (too-many-instance-attributes)
packages/agent_configs/agent_configs/dqn/dueling_dqn_config.py:6:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
packages/agent_configs/agent_configs/dqn/dueling_dqn_config.py:4:0: R0903: Too few public methods (0/2) (too-few-public-methods)
************* Module n_step_dqn_config
packages/agent_configs/agent_configs/dqn/n_step_dqn_config.py:22:0: C0301: Line too long (225/100) (line-too-long)
packages/agent_configs/agent_configs/dqn/n_step_dqn_config.py:24:0: C0301: Line too long (185/100) (line-too-long)
packages/agent_configs/agent_configs/dqn/n_step_dqn_config.py:1:0: C0114: Missing module docstring (missing-module-docstring)
packages/agent_configs/agent_configs/dqn/n_step_dqn_config.py:1:0: E0611: No name 'dqn' in module 'agent_configs' (no-name-in-module)
packages/agent_configs/agent_configs/dqn/n_step_dqn_config.py:1:0: E0401: Unable to import 'agent_configs.dqn.rainbow_config' (import-error)
packages/agent_configs/agent_configs/dqn/n_step_dqn_config.py:4:0: C0115: Missing class docstring (missing-class-docstring)
packages/agent_configs/agent_configs/dqn/n_step_dqn_config.py:4:0: R0902: Too many instance attributes (10/7) (too-many-instance-attributes)
packages/agent_configs/agent_configs/dqn/n_step_dqn_config.py:6:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
packages/agent_configs/agent_configs/dqn/n_step_dqn_config.py:4:0: R0903: Too few public methods (0/2) (too-few-public-methods)
************* Module nfsp_config
packages/agent_configs/agent_configs/dqn/nfsp_config.py:1:0: C0114: Missing module docstring (missing-module-docstring)
packages/agent_configs/agent_configs/dqn/nfsp_config.py:1:0: E0611: No name 'dqn' in module 'agent_configs' (no-name-in-module)
packages/agent_configs/agent_configs/dqn/nfsp_config.py:1:0: E0401: Unable to import 'agent_configs.dqn.rainbow_config' (import-error)
packages/agent_configs/agent_configs/dqn/nfsp_config.py:2:0: E0611: No name 'sl_config' in module 'agent_configs' (no-name-in-module)
packages/agent_configs/agent_configs/dqn/nfsp_config.py:2:0: E0401: Unable to import 'agent_configs.sl_config' (import-error)
packages/agent_configs/agent_configs/dqn/nfsp_config.py:3:0: E0402: Attempted relative import beyond top-level package (relative-beyond-top-level)
packages/agent_configs/agent_configs/dqn/nfsp_config.py:4:0: E0401: Unable to import 'torch.optim' (import-error)
packages/agent_configs/agent_configs/dqn/nfsp_config.py:7:0: C0115: Missing class docstring (missing-class-docstring)
packages/agent_configs/agent_configs/dqn/nfsp_config.py:10:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
packages/agent_configs/agent_configs/dqn/nfsp_config.py:18:12: C0103: Variable name "c" doesn't conform to snake_case naming style (invalid-name)
packages/agent_configs/agent_configs/dqn/nfsp_config.py:7:0: R0903: Too few public methods (0/2) (too-few-public-methods)
packages/agent_configs/agent_configs/dqn/nfsp_config.py:4:0: W0611: Unused Optimizer imported from torch.optim (unused-import)
packages/agent_configs/agent_configs/dqn/nfsp_config.py:4:0: W0611: Unused Adam imported from torch.optim (unused-import)
packages/agent_configs/agent_configs/dqn/nfsp_config.py:4:0: C0411: third party import "from torch.optim import Optimizer, Adam" should be placed before "from ..base_config import Config" (wrong-import-order)
************* Module noisy_dqn_config
packages/agent_configs/agent_configs/dqn/noisy_dqn_config.py:22:0: C0301: Line too long (225/100) (line-too-long)
packages/agent_configs/agent_configs/dqn/noisy_dqn_config.py:24:0: C0301: Line too long (185/100) (line-too-long)
packages/agent_configs/agent_configs/dqn/noisy_dqn_config.py:1:0: C0114: Missing module docstring (missing-module-docstring)
packages/agent_configs/agent_configs/dqn/noisy_dqn_config.py:1:0: E0611: No name 'dqn' in module 'agent_configs' (no-name-in-module)
packages/agent_configs/agent_configs/dqn/noisy_dqn_config.py:1:0: E0401: Unable to import 'agent_configs.dqn.rainbow_config' (import-error)
packages/agent_configs/agent_configs/dqn/noisy_dqn_config.py:4:0: C0115: Missing class docstring (missing-class-docstring)
packages/agent_configs/agent_configs/dqn/noisy_dqn_config.py:4:0: R0902: Too many instance attributes (10/7) (too-many-instance-attributes)
packages/agent_configs/agent_configs/dqn/noisy_dqn_config.py:6:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
packages/agent_configs/agent_configs/dqn/noisy_dqn_config.py:4:0: R0903: Too few public methods (0/2) (too-few-public-methods)
************* Module per_dqn_config
packages/agent_configs/agent_configs/dqn/per_dqn_config.py:20:0: C0301: Line too long (225/100) (line-too-long)
packages/agent_configs/agent_configs/dqn/per_dqn_config.py:22:0: C0301: Line too long (185/100) (line-too-long)
packages/agent_configs/agent_configs/dqn/per_dqn_config.py:1:0: C0114: Missing module docstring (missing-module-docstring)
packages/agent_configs/agent_configs/dqn/per_dqn_config.py:1:0: E0611: No name 'dqn' in module 'agent_configs' (no-name-in-module)
packages/agent_configs/agent_configs/dqn/per_dqn_config.py:1:0: E0401: Unable to import 'agent_configs.dqn.rainbow_config' (import-error)
packages/agent_configs/agent_configs/dqn/per_dqn_config.py:4:0: C0115: Missing class docstring (missing-class-docstring)
packages/agent_configs/agent_configs/dqn/per_dqn_config.py:4:0: R0902: Too many instance attributes (8/7) (too-many-instance-attributes)
packages/agent_configs/agent_configs/dqn/per_dqn_config.py:6:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
packages/agent_configs/agent_configs/dqn/per_dqn_config.py:4:0: R0903: Too few public methods (0/2) (too-few-public-methods)
************* Module rainbow_config
packages/agent_configs/agent_configs/dqn/rainbow_config.py:47:0: C0301: Line too long (127/100) (line-too-long)
packages/agent_configs/agent_configs/dqn/rainbow_config.py:58:0: C0301: Line too long (225/100) (line-too-long)
packages/agent_configs/agent_configs/dqn/rainbow_config.py:60:0: C0301: Line too long (185/100) (line-too-long)
packages/agent_configs/agent_configs/dqn/rainbow_config.py:67:0: C0303: Trailing whitespace (trailing-whitespace)
packages/agent_configs/agent_configs/dqn/rainbow_config.py:1:0: C0114: Missing module docstring (missing-module-docstring)
packages/agent_configs/agent_configs/dqn/rainbow_config.py:1:0: E0402: Attempted relative import beyond top-level package (relative-beyond-top-level)
packages/agent_configs/agent_configs/dqn/rainbow_config.py:2:0: E0611: No name 'CategoricalCrossentropyLoss' in module 'utils' (no-name-in-module)
packages/agent_configs/agent_configs/dqn/rainbow_config.py:2:0: E0611: No name 'tointlists' in module 'utils' (no-name-in-module)
packages/agent_configs/agent_configs/dqn/rainbow_config.py:5:0: C0115: Missing class docstring (missing-class-docstring)
packages/agent_configs/agent_configs/dqn/rainbow_config.py:5:0: R0902: Too many instance attributes (24/7) (too-many-instance-attributes)
packages/agent_configs/agent_configs/dqn/rainbow_config.py:7:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
packages/agent_configs/agent_configs/dqn/rainbow_config.py:66:19: C0121: Comparison 'self.v_min != None' should be 'self.v_min is not None' (singleton-comparison)
packages/agent_configs/agent_configs/dqn/rainbow_config.py:66:42: C0121: Comparison 'self.v_max != None' should be 'self.v_max is not None' (singleton-comparison)
packages/agent_configs/agent_configs/dqn/rainbow_config.py:5:0: R0903: Too few public methods (0/2) (too-few-public-methods)
packages/agent_configs/agent_configs/dqn/rainbow_config.py:2:0: W0611: Unused CategoricalCrossentropyLoss imported from utils (unused-import)
packages/agent_configs/agent_configs/dqn/rainbow_config.py:2:0: C0411: third party import "from utils import CategoricalCrossentropyLoss, tointlists" should be placed before "from ..base_config import Config" (wrong-import-order)
************* Module agent_configs.agent_configs.muzero_config
packages/agent_configs/agent_configs/muzero_config.py:10:0: C0301: Line too long (162/100) (line-too-long)
packages/agent_configs/agent_configs/muzero_config.py:1:0: C0114: Missing module docstring (missing-module-docstring)
packages/agent_configs/agent_configs/muzero_config.py:4:0: C0115: Missing class docstring (missing-class-docstring)
packages/agent_configs/agent_configs/muzero_config.py:6:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
************* Module agent_configs.agent_configs.ppo_config
packages/agent_configs/agent_configs/ppo_config.py:36:0: C0301: Line too long (105/100) (line-too-long)
packages/agent_configs/agent_configs/ppo_config.py:38:0: C0301: Line too long (109/100) (line-too-long)
packages/agent_configs/agent_configs/ppo_config.py:47:0: C0301: Line too long (110/100) (line-too-long)
packages/agent_configs/agent_configs/ppo_config.py:57:0: C0301: Line too long (110/100) (line-too-long)
packages/agent_configs/agent_configs/ppo_config.py:1:0: C0114: Missing module docstring (missing-module-docstring)
packages/agent_configs/agent_configs/ppo_config.py:6:0: C0115: Missing class docstring (missing-class-docstring)
packages/agent_configs/agent_configs/ppo_config.py:6:0: R0902: Too many instance attributes (18/7) (too-many-instance-attributes)
packages/agent_configs/agent_configs/ppo_config.py:14:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
************* Module agent_configs.agent_configs.replay_config
packages/agent_configs/agent_configs/replay_config.py:1:0: C0114: Missing module docstring (missing-module-docstring)
packages/agent_configs/agent_configs/replay_config.py:1:0: E0611: No name 'base_config' in module 'agent_configs' (no-name-in-module)
packages/agent_configs/agent_configs/replay_config.py:1:0: E0401: Unable to import 'agent_configs.base_config' (import-error)
packages/agent_configs/agent_configs/replay_config.py:4:0: C0115: Missing class docstring (missing-class-docstring)
packages/agent_configs/agent_configs/replay_config.py:4:0: R0902: Too many instance attributes (9/7) (too-many-instance-attributes)
packages/agent_configs/agent_configs/replay_config.py:4:0: R0903: Too few public methods (0/2) (too-few-public-methods)
************* Module agent_configs.agent_configs.sl_config
packages/agent_configs/agent_configs/sl_config.py:1:0: C0114: Missing module docstring (missing-module-docstring)
packages/agent_configs/agent_configs/sl_config.py:1:0: E0611: No name 'Loss' in module 'utils' (no-name-in-module)
packages/agent_configs/agent_configs/sl_config.py:3:0: E0611: No name 'prepare_activations' in module 'utils' (no-name-in-module)
packages/agent_configs/agent_configs/sl_config.py:3:0: E0611: No name 'prepare_kernel_initializers' in module 'utils' (no-name-in-module)
packages/agent_configs/agent_configs/sl_config.py:4:0: E0401: Unable to import 'torch.optim' (import-error)
packages/agent_configs/agent_configs/sl_config.py:7:0: C0115: Missing class docstring (missing-class-docstring)
packages/agent_configs/agent_configs/sl_config.py:7:0: R0902: Too many instance attributes (20/7) (too-many-instance-attributes)
packages/agent_configs/agent_configs/sl_config.py:3:0: W0611: Unused prepare_kernel_initializers imported from utils (unused-import)
packages/agent_configs/agent_configs/sl_config.py:3:0: C0411: third party import "from utils import prepare_activations, prepare_kernel_initializers" should be placed before "from .base_config import ConfigBase, kernel_initializer_wrapper" (wrong-import-order)
packages/agent_configs/agent_configs/sl_config.py:4:0: C0411: third party import "from torch.optim import Optimizer, Adam" should be placed before "from .base_config import ConfigBase, kernel_initializer_wrapper" (wrong-import-order)
************* Module agent_configs.setup
packages/agent_configs/setup.py:1:0: C0114: Missing module docstring (missing-module-docstring)
************* Module lib
packages/game_configs/build/lib/__init__.py:1:0: C0114: Missing module docstring (missing-module-docstring)
packages/game_configs/build/lib/__init__.py:1:0: E0401: Unable to import 'atari_config' (import-error)
packages/game_configs/build/lib/__init__.py:2:0: E0401: Unable to import 'connect4_config' (import-error)
packages/game_configs/build/lib/__init__.py:3:0: E0401: Unable to import 'tictactoe_config' (import-error)
packages/game_configs/build/lib/__init__.py:4:0: E0401: Unable to import 'game_config' (import-error)
packages/game_configs/build/lib/__init__.py:5:0: E0401: Unable to import 'cartpole_config' (import-error)
************* Module lib.atari_config
packages/game_configs/build/lib/atari_config.py:1:0: C0114: Missing module docstring (missing-module-docstring)
packages/game_configs/build/lib/atari_config.py:1:0: E0401: Unable to import 'game_config' (import-error)
packages/game_configs/build/lib/atari_config.py:4:0: C0115: Missing class docstring (missing-class-docstring)
packages/game_configs/build/lib/atari_config.py:6:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
packages/game_configs/build/lib/atari_config.py:4:0: R0903: Too few public methods (0/2) (too-few-public-methods)
************* Module lib.cartpole_config
packages/game_configs/build/lib/cartpole_config.py:11:0: C0301: Line too long (170/100) (line-too-long)
packages/game_configs/build/lib/cartpole_config.py:1:0: C0114: Missing module docstring (missing-module-docstring)
packages/game_configs/build/lib/cartpole_config.py:1:0: E0401: Unable to import 'game_config' (import-error)
packages/game_configs/build/lib/cartpole_config.py:4:0: C0115: Missing class docstring (missing-class-docstring)
packages/game_configs/build/lib/cartpole_config.py:6:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
packages/game_configs/build/lib/cartpole_config.py:4:0: R0903: Too few public methods (0/2) (too-few-public-methods)
************* Module lib.connect4_config
packages/game_configs/build/lib/connect4_config.py:1:0: C0114: Missing module docstring (missing-module-docstring)
packages/game_configs/build/lib/connect4_config.py:1:0: E0401: Unable to import 'game_config' (import-error)
packages/game_configs/build/lib/connect4_config.py:4:0: C0115: Missing class docstring (missing-class-docstring)
packages/game_configs/build/lib/connect4_config.py:6:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
packages/game_configs/build/lib/connect4_config.py:4:0: R0903: Too few public methods (0/2) (too-few-public-methods)
************* Module lib.game_config
packages/game_configs/build/lib/game_config.py:13:0: C0301: Line too long (175/100) (line-too-long)
packages/game_configs/build/lib/game_config.py:18:0: C0301: Line too long (189/100) (line-too-long)
packages/game_configs/build/lib/game_config.py:1:0: C0114: Missing module docstring (missing-module-docstring)
packages/game_configs/build/lib/game_config.py:1:0: C0115: Missing class docstring (missing-class-docstring)
packages/game_configs/build/lib/game_config.py:2:4: R0913: Too many arguments (7/5) (too-many-arguments)
packages/game_configs/build/lib/game_config.py:1:0: R0903: Too few public methods (0/2) (too-few-public-methods)
************* Module lib.tictactoe_config
packages/game_configs/build/lib/tictactoe_config.py:1:0: C0114: Missing module docstring (missing-module-docstring)
packages/game_configs/build/lib/tictactoe_config.py:1:0: E0401: Unable to import 'game_config' (import-error)
packages/game_configs/build/lib/tictactoe_config.py:4:0: C0115: Missing class docstring (missing-class-docstring)
packages/game_configs/build/lib/tictactoe_config.py:6:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
packages/game_configs/build/lib/tictactoe_config.py:4:0: R0903: Too few public methods (0/2) (too-few-public-methods)
************* Module game_configs.game_configs
packages/game_configs/game_configs/__init__.py:1:0: C0114: Missing module docstring (missing-module-docstring)
************* Module game_configs.game_configs.atari_config
packages/game_configs/game_configs/atari_config.py:13:0: C0301: Line too long (137/100) (line-too-long)
packages/game_configs/game_configs/atari_config.py:1:0: C0114: Missing module docstring (missing-module-docstring)
packages/game_configs/game_configs/atari_config.py:4:0: C0115: Missing class docstring (missing-class-docstring)
packages/game_configs/game_configs/atari_config.py:6:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
packages/game_configs/game_configs/atari_config.py:4:0: R0903: Too few public methods (0/2) (too-few-public-methods)
************* Module game_configs.game_configs.blackjack_config
packages/game_configs/game_configs/blackjack_config.py:1:0: C0114: Missing module docstring (missing-module-docstring)
packages/game_configs/game_configs/blackjack_config.py:4:0: C0115: Missing class docstring (missing-class-docstring)
packages/game_configs/game_configs/blackjack_config.py:6:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
packages/game_configs/game_configs/blackjack_config.py:4:0: R0903: Too few public methods (0/2) (too-few-public-methods)
************* Module game_configs.game_configs.cartpole_config
packages/game_configs/game_configs/cartpole_config.py:11:0: C0301: Line too long (170/100) (line-too-long)
packages/game_configs/game_configs/cartpole_config.py:1:0: C0114: Missing module docstring (missing-module-docstring)
packages/game_configs/game_configs/cartpole_config.py:4:0: C0115: Missing class docstring (missing-class-docstring)
packages/game_configs/game_configs/cartpole_config.py:6:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
packages/game_configs/game_configs/cartpole_config.py:4:0: R0903: Too few public methods (0/2) (too-few-public-methods)
************* Module game_configs.game_configs.classiccontrol_config
packages/game_configs/game_configs/classiccontrol_config.py:11:0: C0301: Line too long (170/100) (line-too-long)
packages/game_configs/game_configs/classiccontrol_config.py:1:0: C0114: Missing module docstring (missing-module-docstring)
packages/game_configs/game_configs/classiccontrol_config.py:4:0: C0115: Missing class docstring (missing-class-docstring)
packages/game_configs/game_configs/classiccontrol_config.py:6:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
packages/game_configs/game_configs/classiccontrol_config.py:4:0: R0903: Too few public methods (0/2) (too-few-public-methods)
************* Module game_configs.game_configs.connect4_config
packages/game_configs/game_configs/connect4_config.py:1:0: C0114: Missing module docstring (missing-module-docstring)
packages/game_configs/game_configs/connect4_config.py:4:0: C0115: Missing class docstring (missing-class-docstring)
packages/game_configs/game_configs/connect4_config.py:6:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
packages/game_configs/game_configs/connect4_config.py:4:0: R0903: Too few public methods (0/2) (too-few-public-methods)
************* Module game_configs.game_configs.game_config
packages/game_configs/game_configs/game_config.py:16:0: C0301: Line too long (175/100) (line-too-long)
packages/game_configs/game_configs/game_config.py:21:0: C0301: Line too long (189/100) (line-too-long)
packages/game_configs/game_configs/game_config.py:1:0: C0114: Missing module docstring (missing-module-docstring)
packages/game_configs/game_configs/game_config.py:1:0: C0115: Missing class docstring (missing-class-docstring)
packages/game_configs/game_configs/game_config.py:1:0: R0902: Too many instance attributes (9/7) (too-many-instance-attributes)
packages/game_configs/game_configs/game_config.py:2:4: R0913: Too many arguments (10/5) (too-many-arguments)
packages/game_configs/game_configs/game_config.py:27:21: C0103: Argument name "o" doesn't conform to snake_case naming style (invalid-name)
packages/game_configs/game_configs/game_config.py:1:0: R0903: Too few public methods (1/2) (too-few-public-methods)
************* Module game_configs.game_configs.leduc_holdem_config
packages/game_configs/game_configs/leduc_holdem_config.py:1:0: C0114: Missing module docstring (missing-module-docstring)
packages/game_configs/game_configs/leduc_holdem_config.py:4:0: C0115: Missing class docstring (missing-class-docstring)
packages/game_configs/game_configs/leduc_holdem_config.py:6:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
packages/game_configs/game_configs/leduc_holdem_config.py:4:0: R0903: Too few public methods (0/2) (too-few-public-methods)
************* Module game_configs.game_configs.mississippi_marbles_config
packages/game_configs/game_configs/mississippi_marbles_config.py:1:0: C0114: Missing module docstring (missing-module-docstring)
packages/game_configs/game_configs/mississippi_marbles_config.py:4:0: C0115: Missing class docstring (missing-class-docstring)
packages/game_configs/game_configs/mississippi_marbles_config.py:6:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
packages/game_configs/game_configs/mississippi_marbles_config.py:4:0: R0903: Too few public methods (0/2) (too-few-public-methods)
************* Module game_configs.game_configs.tictactoe_config
packages/game_configs/game_configs/tictactoe_config.py:1:0: C0114: Missing module docstring (missing-module-docstring)
packages/game_configs/game_configs/tictactoe_config.py:4:0: C0115: Missing class docstring (missing-class-docstring)
packages/game_configs/game_configs/tictactoe_config.py:6:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
packages/game_configs/game_configs/tictactoe_config.py:4:0: R0903: Too few public methods (0/2) (too-few-public-methods)
************* Module game_configs.game_configs.toytext_config
packages/game_configs/game_configs/toytext_config.py:1:0: C0114: Missing module docstring (missing-module-docstring)
packages/game_configs/game_configs/toytext_config.py:4:0: C0115: Missing class docstring (missing-class-docstring)
packages/game_configs/game_configs/toytext_config.py:6:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
packages/game_configs/game_configs/toytext_config.py:4:0: R0903: Too few public methods (0/2) (too-few-public-methods)
************* Module game_configs.setup
packages/game_configs/setup.py:1:0: C0114: Missing module docstring (missing-module-docstring)
************* Module utils.setup
packages/utils/setup.py:1:0: C0114: Missing module docstring (missing-module-docstring)
************* Module utils.utils
packages/utils/utils/__init__.py:1:0: C0114: Missing module docstring (missing-module-docstring)
************* Module linear_annealed_lr
packages/utils/utils/lr_schedulers/linear_annealed_lr.py:1:0: C0114: Missing module docstring (missing-module-docstring)
packages/utils/utils/lr_schedulers/linear_annealed_lr.py:1:0: C0115: Missing class docstring (missing-class-docstring)
packages/utils/utils/lr_schedulers/linear_annealed_lr.py:8:4: C0116: Missing function or method docstring (missing-function-docstring)
packages/utils/utils/lr_schedulers/linear_annealed_lr.py:1:0: R0903: Too few public methods (1/2) (too-few-public-methods)
************* Module lr_schedule
packages/utils/utils/lr_schedulers/lr_schedule.py:1:0: C0114: Missing module docstring (missing-module-docstring)
packages/utils/utils/lr_schedulers/lr_schedule.py:1:0: C0115: Missing class docstring (missing-class-docstring)
packages/utils/utils/lr_schedulers/lr_schedule.py:9:4: C0116: Missing function or method docstring (missing-function-docstring)
packages/utils/utils/lr_schedulers/lr_schedule.py:10:8: R1705: Unnecessary "else" after "return" (no-else-return)
packages/utils/utils/lr_schedulers/lr_schedule.py:1:0: R0903: Too few public methods (1/2) (too-few-public-methods)
************* Module utils.utils.utils
packages/utils/utils/utils.py:567:5: W0511: TODO (fixme)
packages/utils/utils/utils.py:127:0: C0301: Line too long (101/100) (line-too-long)
packages/utils/utils/utils.py:467:0: C0301: Line too long (112/100) (line-too-long)
packages/utils/utils/utils.py:912:0: C0301: Line too long (105/100) (line-too-long)
packages/utils/utils/utils.py:983:0: C0301: Line too long (111/100) (line-too-long)
packages/utils/utils/utils.py:987:0: C0301: Line too long (114/100) (line-too-long)
packages/utils/utils/utils.py:1138:0: C0301: Line too long (108/100) (line-too-long)
packages/utils/utils/utils.py:1:0: C0302: Too many lines in module (1281/1000) (too-many-lines)
packages/utils/utils/utils.py:1:0: C0114: Missing module docstring (missing-module-docstring)
packages/utils/utils/utils.py:10:0: C0413: Import "from matplotlib import pyplot as plt" should be placed at the top of the module (wrong-import-position)
packages/utils/utils/utils.py:11:0: C0413: Import "import scipy" should be placed at the top of the module (wrong-import-position)
packages/utils/utils/utils.py:12:0: C0413: Import "import pickle" should be placed at the top of the module (wrong-import-position)
packages/utils/utils/utils.py:14:0: C0413: Import "from typing import Iterable, Tuple" should be placed at the top of the module (wrong-import-position)
packages/utils/utils/utils.py:15:0: C0413: Import "from datetime import datetime" should be placed at the top of the module (wrong-import-position)
packages/utils/utils/utils.py:17:0: E0401: Unable to import 'torch' (import-error)
packages/utils/utils/utils.py:17:0: C0413: Import "import torch" should be placed at the top of the module (wrong-import-position)
packages/utils/utils/utils.py:18:0: E0401: Unable to import 'torch' (import-error)
packages/utils/utils/utils.py:18:0: C0413: Import "from torch import nn, Tensor" should be placed at the top of the module (wrong-import-position)
packages/utils/utils/utils.py:20:0: C0413: Import "import numpy as np" should be placed at the top of the module (wrong-import-position)
packages/utils/utils/utils.py:21:0: C0413: Import "import numpy.typing as npt" should be placed at the top of the module (wrong-import-position)
packages/utils/utils/utils.py:23:0: C0413: Import "import itertools" should be placed at the top of the module (wrong-import-position)
packages/utils/utils/utils.py:24:0: E0401: Unable to import 'hyperopt' (import-error)
packages/utils/utils/utils.py:24:0: C0413: Import "from hyperopt import space_eval" should be placed at the top of the module (wrong-import-position)
packages/utils/utils/utils.py:26:0: C0413: Import "import pandas as pd" should be placed at the top of the module (wrong-import-position)
packages/utils/utils/utils.py:33:0: C0116: Missing function or method docstring (missing-function-docstring)
packages/utils/utils/utils.py:50:7: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
packages/utils/utils/utils.py:87:0: C0116: Missing function or method docstring (missing-function-docstring)
packages/utils/utils/utils.py:89:4: R1705: Unnecessary "else" after "return" (no-else-return)
packages/utils/utils/utils.py:124:0: C0116: Missing function or method docstring (missing-function-docstring)
packages/utils/utils/utils.py:140:0: C0116: Missing function or method docstring (missing-function-docstring)
packages/utils/utils/utils.py:158:0: C0116: Missing function or method docstring (missing-function-docstring)
packages/utils/utils/utils.py:165:0: C0116: Missing function or method docstring (missing-function-docstring)
packages/utils/utils/utils.py:165:0: R0913: Too many arguments (6/5) (too-many-arguments)
packages/utils/utils/utils.py:169:8: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
packages/utils/utils/utils.py:171:4: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
packages/utils/utils/utils.py:177:0: C0116: Missing function or method docstring (missing-function-docstring)
packages/utils/utils/utils.py:177:0: R0913: Too many arguments (6/5) (too-many-arguments)
packages/utils/utils/utils.py:177:0: R0914: Too many local variables (19/15) (too-many-locals)
packages/utils/utils/utils.py:182:4: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
packages/utils/utils/utils.py:245:18: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
packages/utils/utils/utils.py:251:0: C0116: Missing function or method docstring (missing-function-docstring)
packages/utils/utils/utils.py:251:0: R0913: Too many arguments (6/5) (too-many-arguments)
packages/utils/utils/utils.py:253:4: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
packages/utils/utils/utils.py:295:18: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
packages/utils/utils/utils.py:301:0: C0116: Missing function or method docstring (missing-function-docstring)
packages/utils/utils/utils.py:301:0: R0913: Too many arguments (6/5) (too-many-arguments)
packages/utils/utils/utils.py:301:0: R0914: Too many local variables (16/15) (too-many-locals)
packages/utils/utils/utils.py:313:4: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
packages/utils/utils/utils.py:395:18: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
packages/utils/utils/utils.py:401:0: C0116: Missing function or method docstring (missing-function-docstring)
packages/utils/utils/utils.py:409:8: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
packages/utils/utils/utils.py:412:8: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
packages/utils/utils/utils.py:444:0: C0116: Missing function or method docstring (missing-function-docstring)
packages/utils/utils/utils.py:451:4: W0622: Redefining built-in 'dir' (redefined-builtin)
packages/utils/utils/utils.py:444:0: R0913: Too many arguments (7/5) (too-many-arguments)
packages/utils/utils/utils.py:444:0: R0914: Too many local variables (19/15) (too-many-locals)
packages/utils/utils/utils.py:467:8: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
packages/utils/utils/utils.py:488:16: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
packages/utils/utils/utils.py:493:0: C0116: Missing function or method docstring (missing-function-docstring)
packages/utils/utils/utils.py:496:4: W0622: Redefining built-in 'dir' (redefined-builtin)
packages/utils/utils/utils.py:515:12: C0103: Variable name "s" doesn't conform to snake_case naming style (invalid-name)
packages/utils/utils/utils.py:537:16: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
packages/utils/utils/utils.py:542:0: C0116: Missing function or method docstring (missing-function-docstring)
packages/utils/utils/utils.py:545:4: R1705: Unnecessary "elif" after "return" (no-else-return)
packages/utils/utils/utils.py:542:57: W0613: Unused argument 'output_layer' (unused-argument)
packages/utils/utils/utils.py:542:0: R0911: Too many return statements (13/6) (too-many-return-statements)
packages/utils/utils/utils.py:542:0: R0912: Too many branches (13/12) (too-many-branches)
packages/utils/utils/utils.py:578:0: C0116: Missing function or method docstring (missing-function-docstring)
packages/utils/utils/utils.py:580:4: R1705: Unnecessary "elif" after "return" (no-else-return)
packages/utils/utils/utils.py:592:9: R1714: Consider merging these comparisons with "in" to "activation in ('silu', 'swish')" (consider-using-in)
packages/utils/utils/utils.py:578:0: R0911: Too many return statements (12/6) (too-many-return-statements)
packages/utils/utils/utils.py:618:0: C0116: Missing function or method docstring (missing-function-docstring)
packages/utils/utils/utils.py:623:8: R1705: Unnecessary "else" after "return" (no-else-return)
packages/utils/utils/utils.py:637:0: C0116: Missing function or method docstring (missing-function-docstring)
packages/utils/utils/utils.py:643:11: C0103: Variable name "n" doesn't conform to snake_case naming style (invalid-name)
packages/utils/utils/utils.py:648:0: C0116: Missing function or method docstring (missing-function-docstring)
packages/utils/utils/utils.py:660:8: C0200: Consider using enumerate instead of iterating with range and len (consider-using-enumerate)
packages/utils/utils/utils.py:725:0: C0116: Missing function or method docstring (missing-function-docstring)
packages/utils/utils/utils.py:799:8: C0103: Variable name "l" doesn't conform to snake_case naming style (invalid-name)
packages/utils/utils/utils.py:800:8: C0103: Variable name "h" doesn't conform to snake_case naming style (invalid-name)
packages/utils/utils/utils.py:808:0: C0116: Missing function or method docstring (missing-function-docstring)
packages/utils/utils/utils.py:809:4: R1705: Unnecessary "elif" after "return" (no-else-return)
packages/utils/utils/utils.py:816:31: C0103: Argument name "x" doesn't conform to snake_case naming style (invalid-name)
packages/utils/utils/utils.py:816:0: C0116: Missing function or method docstring (missing-function-docstring)
packages/utils/utils/utils.py:821:13: C0103: Argument name "l" doesn't conform to snake_case naming style (invalid-name)
packages/utils/utils/utils.py:834:0: C0116: Missing function or method docstring (missing-function-docstring)
packages/utils/utils/utils.py:838:0: C0103: Constant name "_epsilon" doesn't conform to UPPER_CASE naming style (invalid-name)
packages/utils/utils/utils.py:841:0: C0116: Missing function or method docstring (missing-function-docstring)
packages/utils/utils/utils.py:851:0: C0115: Missing class docstring (missing-class-docstring)
packages/utils/utils/utils.py:851:0: R0903: Too few public methods (1/2) (too-few-public-methods)
packages/utils/utils/utils.py:860:0: C0116: Missing function or method docstring (missing-function-docstring)
packages/utils/utils/utils.py:867:0: C0115: Missing class docstring (missing-class-docstring)
packages/utils/utils/utils.py:867:0: R0903: Too few public methods (1/2) (too-few-public-methods)
packages/utils/utils/utils.py:876:0: C0116: Missing function or method docstring (missing-function-docstring)
packages/utils/utils/utils.py:876:57: W0613: Unused argument 'axis' (unused-argument)
packages/utils/utils/utils.py:883:0: C0115: Missing class docstring (missing-class-docstring)
packages/utils/utils/utils.py:883:0: R0903: Too few public methods (1/2) (too-few-public-methods)
packages/utils/utils/utils.py:892:0: C0116: Missing function or method docstring (missing-function-docstring)
packages/utils/utils/utils.py:898:0: C0115: Missing class docstring (missing-class-docstring)
packages/utils/utils/utils.py:898:0: R0903: Too few public methods (1/2) (too-few-public-methods)
packages/utils/utils/utils.py:906:0: C0413: Import "from typing import Callable" should be placed at the top of the module (wrong-import-position)
packages/utils/utils/utils.py:911:38: C0103: Argument name "s" doesn't conform to snake_case naming style (invalid-name)
packages/utils/utils/utils.py:923:4: C0103: Variable name "p" doesn't conform to snake_case naming style (invalid-name)
packages/utils/utils/utils.py:939:0: C0116: Missing function or method docstring (missing-function-docstring)
packages/utils/utils/utils.py:939:0: R0913: Too many arguments (6/5) (too-many-arguments)
packages/utils/utils/utils.py:939:0: R0914: Too many local variables (24/15) (too-many-locals)
packages/utils/utils/utils.py:947:25: R1732: Consider using 'with' for resource-allocating operations (consider-using-with)
packages/utils/utils/utils.py:949:14: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
packages/utils/utils/utils.py:951:14: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
packages/utils/utils/utils.py:957:4: W0106: Expression "checkpoints.remove('videos') if 'videos' in checkpoints else None" is assigned to nothing (expression-not-assigned)
packages/utils/utils/utils.py:958:4: W0106: Expression "checkpoints.remove('.DS_Store') if '.DS_Store' in checkpoints else None" is assigned to nothing (expression-not-assigned)
packages/utils/utils/utils.py:971:11: R1716: Simplify chained comparison between the operands (chained-comparison)
packages/utils/utils/utils.py:986:16: R1732: Consider using 'with' for resource-allocating operations (consider-using-with)
packages/utils/utils/utils.py:1022:16: R1714: Consider merging these comparisons with "in" to "eval_method in ('rolling_average', 'final_score_rolling_average')" (consider-using-in)
packages/utils/utils/utils.py:1049:10: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
packages/utils/utils/utils.py:1052:8: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
packages/utils/utils/utils.py:1057:8: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
packages/utils/utils/utils.py:1062:10: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
packages/utils/utils/utils.py:1063:10: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
packages/utils/utils/utils.py:1064:10: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
packages/utils/utils/utils.py:1065:10: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
packages/utils/utils/utils.py:1067:10: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
packages/utils/utils/utils.py:1068:10: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
packages/utils/utils/utils.py:1069:10: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
packages/utils/utils/utils.py:1070:10: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
packages/utils/utils/utils.py:1072:10: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
packages/utils/utils/utils.py:1073:10: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
packages/utils/utils/utils.py:1074:10: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
packages/utils/utils/utils.py:1075:10: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
packages/utils/utils/utils.py:1090:8: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
packages/utils/utils/utils.py:1095:8: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
packages/utils/utils/utils.py:1100:8: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
packages/utils/utils/utils.py:939:0: R0915: Too many statements (67/50) (too-many-statements)
packages/utils/utils/utils.py:1106:0: C0116: Missing function or method docstring (missing-function-docstring)
packages/utils/utils/utils.py:1131:8: W0621: Redefining name 'plt' from outer scope (line 10) (redefined-outer-name)
packages/utils/utils/utils.py:1106:0: R0914: Too many local variables (20/15) (too-many-locals)
packages/utils/utils/utils.py:1109:52: C0103: Variable name "f" doesn't conform to snake_case naming style (invalid-name)
packages/utils/utils/utils.py:1113:31: R1732: Consider using 'with' for resource-allocating operations (consider-using-with)
packages/utils/utils/utils.py:1122:4: C0103: Variable name "df" doesn't conform to snake_case naming style (invalid-name)
packages/utils/utils/utils.py:1126:4: C0103: Variable name "df" doesn't conform to snake_case naming style (invalid-name)
packages/utils/utils/utils.py:1137:16: R1714: Consider merging these comparisons with "in" to "col in ('kernel_initializer', 'activation')" (consider-using-in)
packages/utils/utils/utils.py:1133:8: W0612: Unused variable 'medians' (unused-variable)
packages/utils/utils/utils.py:1135:8: W0612: Unused variable 'stddev' (unused-variable)
packages/utils/utils/utils.py:1145:0: C0116: Missing function or method docstring (missing-function-docstring)
packages/utils/utils/utils.py:1149:4: R1705: Unnecessary "else" after "return" (no-else-return)
packages/utils/utils/utils.py:1157:8: C0103: Variable name "c" doesn't conform to snake_case naming style (invalid-name)
packages/utils/utils/utils.py:1159:12: C0103: Variable name "c" doesn't conform to snake_case naming style (invalid-name)
packages/utils/utils/utils.py:1163:0: C0115: Missing class docstring (missing-class-docstring)
packages/utils/utils/utils.py:1169:15: R1714: Consider merging these comparisons with "in" to "mode in ('fan_in', 'fan_out', 'fan_avg')" (consider-using-in)
packages/utils/utils/utils.py:1163:0: R0903: Too few public methods (1/2) (too-few-public-methods)
packages/utils/utils/utils.py:1188:15: C0103: Argument name "o" doesn't conform to snake_case naming style (invalid-name)
packages/utils/utils/utils.py:1188:0: C0116: Missing function or method docstring (missing-function-docstring)
packages/utils/utils/utils.py:1190:8: C0103: Variable name "it" doesn't conform to snake_case naming style (invalid-name)
packages/utils/utils/utils.py:1190:8: W0612: Unused variable 'it' (unused-variable)
packages/utils/utils/utils.py:1196:0: C0116: Missing function or method docstring (missing-function-docstring)
packages/utils/utils/utils.py:1196:15: W0622: Redefining built-in 'list' (redefined-builtin)
packages/utils/utils/utils.py:1198:8: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
packages/utils/utils/utils.py:1206:0: C0413: Import "import time" should be placed at the top of the module (wrong-import-position)
packages/utils/utils/utils.py:1207:0: C0413: Import "from collections import deque" should be placed at the top of the module (wrong-import-position)
packages/utils/utils/utils.py:1210:0: C0115: Missing class docstring (missing-class-docstring)
packages/utils/utils/utils.py:1214:4: C0116: Missing function or method docstring (missing-function-docstring)
packages/utils/utils/utils.py:1214:26: W0613: Unused argument 'details' (unused-argument)
packages/utils/utils/utils.py:1214:4: R0201: Method could be a function (no-self-use)
packages/utils/utils/utils.py:1210:0: R0903: Too few public methods (1/2) (too-few-public-methods)
packages/utils/utils/utils.py:1218:0: C0115: Missing class docstring (missing-class-docstring)
packages/utils/utils/utils.py:1219:4: W0231: __init__ method from base class 'StoppingCriteria' is not called (super-init-not-called)
packages/utils/utils/utils.py:1218:0: R0903: Too few public methods (1/2) (too-few-public-methods)
packages/utils/utils/utils.py:1226:0: C0115: Missing class docstring (missing-class-docstring)
packages/utils/utils/utils.py:1227:4: W0231: __init__ method from base class 'StoppingCriteria' is not called (super-init-not-called)
packages/utils/utils/utils.py:1226:0: R0903: Too few public methods (1/2) (too-few-public-methods)
packages/utils/utils/utils.py:1234:0: C0115: Missing class docstring (missing-class-docstring)
packages/utils/utils/utils.py:1235:4: W0231: __init__ method from base class 'StoppingCriteria' is not called (super-init-not-called)
packages/utils/utils/utils.py:1234:0: R0903: Too few public methods (1/2) (too-few-public-methods)
packages/utils/utils/utils.py:1242:0: C0115: Missing class docstring (missing-class-docstring)
packages/utils/utils/utils.py:1243:4: W0231: __init__ method from base class 'StoppingCriteria' is not called (super-init-not-called)
packages/utils/utils/utils.py:1248:4: C0116: Missing function or method docstring (missing-function-docstring)
packages/utils/utils/utils.py:1258:0: C0115: Missing class docstring (missing-class-docstring)
packages/utils/utils/utils.py:1259:4: W0231: __init__ method from base class 'StoppingCriteria' is not called (super-init-not-called)
packages/utils/utils/utils.py:1279:4: C0116: Missing function or method docstring (missing-function-docstring)
packages/utils/utils/utils.py:1280:8: C0103: Variable name "tc" doesn't conform to snake_case naming style (invalid-name)
packages/utils/utils/utils.py:12:0: C0411: standard import "import pickle" should be placed before "import matplotlib" (wrong-import-order)
packages/utils/utils/utils.py:14:0: C0411: standard import "from typing import Iterable, Tuple" should be placed before "import matplotlib" (wrong-import-order)
packages/utils/utils/utils.py:15:0: C0411: standard import "from datetime import datetime" should be placed before "import matplotlib" (wrong-import-order)
packages/utils/utils/utils.py:23:0: C0411: standard import "import itertools" should be placed before "import matplotlib" (wrong-import-order)
packages/utils/utils/utils.py:906:0: C0411: standard import "from typing import Callable" should be placed before "import matplotlib" (wrong-import-order)
packages/utils/utils/utils.py:1206:0: C0411: standard import "import time" should be placed before "import matplotlib" (wrong-import-order)
packages/utils/utils/utils.py:1207:0: C0411: standard import "from collections import deque" should be placed before "import matplotlib" (wrong-import-order)
packages/utils/utils/utils.py:906:0: C0412: Imports from package typing are not grouped (ungrouped-imports)
packages/utils/utils/utils.py:1207:0: C0412: Imports from package collections are not grouped (ungrouped-imports)
************* Module rl-research.ppo.ppo_agent
ppo/ppo_agent.py:37:0: C0301: Line too long (128/100) (line-too-long)
ppo/ppo_agent.py:46:0: C0301: Line too long (105/100) (line-too-long)
ppo/ppo_agent.py:116:0: C0303: Trailing whitespace (trailing-whitespace)
ppo/ppo_agent.py:1:0: C0114: Missing module docstring (missing-module-docstring)
ppo/ppo_agent.py:5:0: E0401: Unable to import 'torch' (import-error)
ppo/ppo_agent.py:6:0: E0401: Unable to import 'torch.nn.utils' (import-error)
ppo/ppo_agent.py:8:0: E0611: No name 'PPOConfig' in module 'agent_configs' (no-name-in-module)
ppo/ppo_agent.py:9:0: E0401: Unable to import 'torch.optim.sgd' (import-error)
ppo/ppo_agent.py:10:0: E0401: Unable to import 'torch.optim.adam' (import-error)
ppo/ppo_agent.py:12:0: E0611: No name 'normalize_policy' in module 'utils' (no-name-in-module)
ppo/ppo_agent.py:12:0: E0611: No name 'action_mask' in module 'utils' (no-name-in-module)
ppo/ppo_agent.py:12:0: E0611: No name 'get_legal_moves' in module 'utils' (no-name-in-module)
ppo/ppo_agent.py:12:0: E0611: No name 'update_linear_lr_schedule' in module 'utils' (no-name-in-module)
ppo/ppo_agent.py:22:0: C0413: Import "import datetime" should be placed at the top of the module (wrong-import-position)
ppo/ppo_agent.py:23:0: E0401: Unable to import 'ppo.ppo_network' (import-error)
ppo/ppo_agent.py:23:0: C0413: Import "from ppo.ppo_network import Network" should be placed at the top of the module (wrong-import-position)
ppo/ppo_agent.py:24:0: E0401: Unable to import 'replay_buffers.base_replay_buffer' (import-error)
ppo/ppo_agent.py:24:0: C0413: Import "from replay_buffers.base_replay_buffer import BasePPOReplayBuffer" should be placed at the top of the module (wrong-import-position)
ppo/ppo_agent.py:25:0: E0401: Unable to import 'base_agent.agent' (import-error)
ppo/ppo_agent.py:25:0: C0413: Import "from base_agent.agent import BaseAgent" should be placed at the top of the module (wrong-import-position)
ppo/ppo_agent.py:28:0: C0115: Missing class docstring (missing-class-docstring)
ppo/ppo_agent.py:28:0: R0902: Too many instance attributes (9/7) (too-many-instance-attributes)
ppo/ppo_agent.py:29:4: R0913: Too many arguments (6/5) (too-many-arguments)
ppo/ppo_agent.py:46:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
ppo/ppo_agent.py:117:4: C0116: Missing function or method docstring (missing-function-docstring)
ppo/ppo_agent.py:122:4: C0116: Missing function or method docstring (missing-function-docstring)
ppo/ppo_agent.py:126:4: C0116: Missing function or method docstring (missing-function-docstring)
ppo/ppo_agent.py:145:4: C0116: Missing function or method docstring (missing-function-docstring)
ppo/ppo_agent.py:145:0: W0613: Unused argument 'args' (unused-argument)
ppo/ppo_agent.py:145:0: W0613: Unused argument 'kwargs' (unused-argument)
ppo/ppo_agent.py:145:4: R0201: Method could be a function (no-self-use)
ppo/ppo_agent.py:151:4: C0116: Missing function or method docstring (missing-function-docstring)
ppo/ppo_agent.py:151:4: R0913: Too many arguments (7/5) (too-many-arguments)
ppo/ppo_agent.py:151:4: R0914: Too many local variables (19/15) (too-many-locals)
ppo/ppo_agent.py:224:4: C0116: Missing function or method docstring (missing-function-docstring)
ppo/ppo_agent.py:242:4: C0116: Missing function or method docstring (missing-function-docstring)
ppo/ppo_agent.py:242:4: R0914: Too many local variables (23/15) (too-many-locals)
ppo/ppo_agent.py:288:22: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
ppo/ppo_agent.py:326:4: C0116: Missing function or method docstring (missing-function-docstring)
ppo/ppo_agent.py:326:4: R0914: Too many local variables (20/15) (too-many-locals)
ppo/ppo_agent.py:332:14: E1101: Instance of 'PPOAgent' has no 'training_step' member (no-member)
ppo/ppo_agent.py:334:19: E1101: Instance of 'PPOAgent' has no 'training_step' member (no-member)
ppo/ppo_agent.py:373:15: E1101: Instance of 'PPOAgent' has no 'training_step' member (no-member)
ppo/ppo_agent.py:377:12: E1101: Instance of 'PPOAgent' has no 'training_step' member (no-member)
ppo/ppo_agent.py:329:30: E0203: Access to member 'training_time' before its definition line 374 (access-member-before-definition)
ppo/ppo_agent.py:375:16: E0203: Access to member 'total_environment_steps' before its definition line 380 (access-member-before-definition)
ppo/ppo_agent.py:374:16: W0201: Attribute 'training_time' defined outside __init__ (attribute-defined-outside-init)
ppo/ppo_agent.py:379:8: W0201: Attribute 'training_time' defined outside __init__ (attribute-defined-outside-init)
ppo/ppo_agent.py:380:8: W0201: Attribute 'total_environment_steps' defined outside __init__ (attribute-defined-outside-init)
ppo/ppo_agent.py:1:0: W0611: Unused ge imported from operator (unused-import)
ppo/ppo_agent.py:12:0: W0611: Unused normalize_policy imported from utils (unused-import)
ppo/ppo_agent.py:22:0: C0411: standard import "import datetime" should be placed before "import torch" (wrong-import-order)
ppo/ppo_agent.py:9:0: C0412: Imports from package torch are not grouped (ungrouped-imports)
************* Module rl-research.ppo.ppo_network
ppo/ppo_network.py:1:0: C0114: Missing module docstring (missing-module-docstring)
ppo/ppo_network.py:2:0: E0611: No name 'ppo_config' in module 'agent_configs' (no-name-in-module)
ppo/ppo_network.py:2:0: E0401: Unable to import 'agent_configs.ppo_config' (import-error)
ppo/ppo_network.py:3:0: E0401: Unable to import 'torch' (import-error)
ppo/ppo_network.py:6:0: E0401: Unable to import 'modules.conv' (import-error)
ppo/ppo_network.py:7:0: E0401: Unable to import 'modules.dense' (import-error)
ppo/ppo_network.py:8:0: R0402: Use 'from torch import nn' instead (consider-using-from-import)
ppo/ppo_network.py:8:0: E0401: Unable to import 'torch.nn' (import-error)
ppo/ppo_network.py:11:0: C0115: Missing class docstring (missing-class-docstring)
ppo/ppo_network.py:20:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
ppo/ppo_network.py:24:4: C0116: Missing function or method docstring (missing-function-docstring)
ppo/ppo_network.py:28:4: C0116: Missing function or method docstring (missing-function-docstring)
ppo/ppo_network.py:32:0: C0115: Missing class docstring (missing-class-docstring)
ppo/ppo_network.py:40:8: C0103: Variable name "B" doesn't conform to snake_case naming style (invalid-name)
ppo/ppo_network.py:92:4: C0116: Missing function or method docstring (missing-function-docstring)
ppo/ppo_network.py:99:4: C0116: Missing function or method docstring (missing-function-docstring)
ppo/ppo_network.py:103:8: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
ppo/ppo_network.py:105:12: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
ppo/ppo_network.py:107:12: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
ppo/ppo_network.py:111:4: C0116: Missing function or method docstring (missing-function-docstring)
ppo/ppo_network.py:119:0: C0115: Missing class docstring (missing-class-docstring)
ppo/ppo_network.py:119:0: R0902: Too many instance attributes (9/7) (too-many-instance-attributes)
ppo/ppo_network.py:136:8: C0103: Variable name "B" doesn't conform to snake_case naming style (invalid-name)
ppo/ppo_network.py:163:19: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
ppo/ppo_network.py:203:4: C0116: Missing function or method docstring (missing-function-docstring)
ppo/ppo_network.py:216:4: C0116: Missing function or method docstring (missing-function-docstring)
ppo/ppo_network.py:220:8: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
ppo/ppo_network.py:222:12: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
ppo/ppo_network.py:224:12: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
ppo/ppo_network.py:225:8: R1705: Unnecessary "else" after "return" (no-else-return)
ppo/ppo_network.py:233:4: C0116: Missing function or method docstring (missing-function-docstring)
ppo/ppo_network.py:8:0: C0411: third party import "import torch.nn as nn" should be placed before "from modules.conv import Conv2dStack" (wrong-import-order)
************* Module rl-research.replay_buffers.a2c_replay_buffer
replay_buffers/a2c_replay_buffer.py:68:30: C0303: Trailing whitespace (trailing-whitespace)
replay_buffers/a2c_replay_buffer.py:76:0: C0305: Trailing newlines (trailing-newlines)
replay_buffers/a2c_replay_buffer.py:1:0: C0114: Missing module docstring (missing-module-docstring)
replay_buffers/a2c_replay_buffer.py:1:0: E0401: Unable to import 'replay_buffers.base_replay_buffer' (import-error)
replay_buffers/a2c_replay_buffer.py:4:0: E0401: Unable to import 'torch' (import-error)
replay_buffers/a2c_replay_buffer.py:6:0: C0115: Missing class docstring (missing-class-docstring)
replay_buffers/a2c_replay_buffer.py:6:0: R0902: Too many instance attributes (10/7) (too-many-instance-attributes)
replay_buffers/a2c_replay_buffer.py:7:4: R0913: Too many arguments (6/5) (too-many-arguments)
replay_buffers/a2c_replay_buffer.py:28:8: C0103: Argument name "id" doesn't conform to snake_case naming style (invalid-name)
replay_buffers/a2c_replay_buffer.py:22:4: C0116: Missing function or method docstring (missing-function-docstring)
replay_buffers/a2c_replay_buffer.py:28:8: W0622: Redefining built-in 'id' (redefined-builtin)
replay_buffers/a2c_replay_buffer.py:22:4: R0913: Too many arguments (6/5) (too-many-arguments)
replay_buffers/a2c_replay_buffer.py:28:8: W0613: Unused argument 'id' (unused-argument)
replay_buffers/a2c_replay_buffer.py:37:4: C0116: Missing function or method docstring (missing-function-docstring)
replay_buffers/a2c_replay_buffer.py:51:4: C0116: Missing function or method docstring (missing-function-docstring)
replay_buffers/a2c_replay_buffer.py:61:4: C0116: Missing function or method docstring (missing-function-docstring)
replay_buffers/a2c_replay_buffer.py:35:8: W0201: Attribute 'size' defined outside __init__ (attribute-defined-outside-init)
replay_buffers/a2c_replay_buffer.py:59:8: W0201: Attribute 'size' defined outside __init__ (attribute-defined-outside-init)
replay_buffers/a2c_replay_buffer.py:52:8: W0201: Attribute 'reward_buffer' defined outside __init__ (attribute-defined-outside-init)
replay_buffers/a2c_replay_buffer.py:53:8: W0201: Attribute 'advantage_buffer' defined outside __init__ (attribute-defined-outside-init)
replay_buffers/a2c_replay_buffer.py:54:8: W0201: Attribute 'return_buffer' defined outside __init__ (attribute-defined-outside-init)
replay_buffers/a2c_replay_buffer.py:55:8: W0201: Attribute 'value_buffer' defined outside __init__ (attribute-defined-outside-init)
replay_buffers/a2c_replay_buffer.py:56:8: W0201: Attribute 'log_probability_buffer' defined outside __init__ (attribute-defined-outside-init)
replay_buffers/a2c_replay_buffer.py:57:8: W0201: Attribute 'distribution_buffer' defined outside __init__ (attribute-defined-outside-init)
replay_buffers/a2c_replay_buffer.py:2:0: C0411: third party import "import numpy as np" should be placed before "from replay_buffers.base_replay_buffer import BaseReplayBuffer" (wrong-import-order)
replay_buffers/a2c_replay_buffer.py:3:0: C0411: third party import "from utils.utils import discounted_cumulative_sums" should be placed before "from replay_buffers.base_replay_buffer import BaseReplayBuffer" (wrong-import-order)
replay_buffers/a2c_replay_buffer.py:4:0: C0411: third party import "import torch" should be placed before "from replay_buffers.base_replay_buffer import BaseReplayBuffer" (wrong-import-order)
************* Module rl-research.replay_buffers.alphazero_replay_buffer
replay_buffers/alphazero_replay_buffer.py:1:0: C0114: Missing module docstring (missing-module-docstring)
replay_buffers/alphazero_replay_buffer.py:2:0: E0401: Unable to import 'replay_buffers.base_replay_buffer' (import-error)
replay_buffers/alphazero_replay_buffer.py:5:0: C0115: Missing class docstring (missing-class-docstring)
replay_buffers/alphazero_replay_buffer.py:6:4: C0116: Missing function or method docstring (missing-function-docstring)
replay_buffers/alphazero_replay_buffer.py:5:0: R0903: Too few public methods (1/2) (too-few-public-methods)
replay_buffers/alphazero_replay_buffer.py:2:0: W0611: Unused Game imported from replay_buffers.base_replay_buffer (unused-import)
************* Module rl-research.replay_buffers.base_replay_buffer
replay_buffers/base_replay_buffer.py:1:0: C0114: Missing module docstring (missing-module-docstring)
replay_buffers/base_replay_buffer.py:7:0: C0115: Missing class docstring (missing-class-docstring)
replay_buffers/base_replay_buffer.py:19:15: E1101: Instance of 'BaseReplayBuffer' has no 'size' member (no-member)
replay_buffers/base_replay_buffer.py:23:4: C0116: Missing function or method docstring (missing-function-docstring)
replay_buffers/base_replay_buffer.py:26:4: C0116: Missing function or method docstring (missing-function-docstring)
replay_buffers/base_replay_buffer.py:29:4: C0116: Missing function or method docstring (missing-function-docstring)
replay_buffers/base_replay_buffer.py:32:4: C0116: Missing function or method docstring (missing-function-docstring)
replay_buffers/base_replay_buffer.py:35:4: C0116: Missing function or method docstring (missing-function-docstring)
replay_buffers/base_replay_buffer.py:39:15: E1101: Instance of 'BaseReplayBuffer' has no 'size' member (no-member)
replay_buffers/base_replay_buffer.py:42:0: C0115: Missing class docstring (missing-class-docstring)
replay_buffers/base_replay_buffer.py:42:0: R0902: Too many instance attributes (8/7) (too-many-instance-attributes)
replay_buffers/base_replay_buffer.py:56:4: C0116: Missing function or method docstring (missing-function-docstring)
replay_buffers/base_replay_buffer.py:56:4: R0913: Too many arguments (7/5) (too-many-arguments)
replay_buffers/base_replay_buffer.py:73:4: C0116: Missing function or method docstring (missing-function-docstring)
replay_buffers/base_replay_buffer.py:88:0: C0115: Missing class docstring (missing-class-docstring)
replay_buffers/base_replay_buffer.py:88:0: W0223: Method 'load' is abstract in class 'BaseReplayBuffer' but is not overridden (abstract-method)
replay_buffers/base_replay_buffer.py:88:0: W0223: Method 'sample_from_indices' is abstract in class 'BaseReplayBuffer' but is not overridden (abstract-method)
replay_buffers/base_replay_buffer.py:96:4: W0221: Number of parameters was 3 in 'BaseReplayBuffer.store' and is now 2 in overridden 'BaseGameReplayBuffer.store' method (arguments-differ)
replay_buffers/base_replay_buffer.py:96:4: W0221: Variadics removed in overridden 'BaseGameReplayBuffer.store' method (arguments-differ)
replay_buffers/base_replay_buffer.py:102:4: W0221: Variadics removed in overridden 'BaseGameReplayBuffer.sample' method (arguments-differ)
replay_buffers/base_replay_buffer.py:117:0: C0115: Missing class docstring (missing-class-docstring)
replay_buffers/base_replay_buffer.py:117:0: R0902: Too many instance attributes (12/7) (too-many-instance-attributes)
replay_buffers/base_replay_buffer.py:117:0: W0223: Method 'load' is abstract in class 'BaseReplayBuffer' but is not overridden (abstract-method)
replay_buffers/base_replay_buffer.py:118:4: R0913: Too many arguments (6/5) (too-many-arguments)
replay_buffers/base_replay_buffer.py:144:8: W0622: Redefining built-in 'id' (redefined-builtin)
replay_buffers/base_replay_buffer.py:135:4: R0913: Too many arguments (9/5) (too-many-arguments)
replay_buffers/base_replay_buffer.py:135:4: W0221: Number of parameters was 3 in 'BaseReplayBuffer.store' and is now 9 in overridden 'BaseDQNReplayBuffer.store' method (arguments-differ)
replay_buffers/base_replay_buffer.py:135:4: W0221: Variadics removed in overridden 'BaseDQNReplayBuffer.store' method (arguments-differ)
replay_buffers/base_replay_buffer.py:181:4: W0221: Variadics removed in overridden 'BaseDQNReplayBuffer.sample' method (arguments-differ)
replay_buffers/base_replay_buffer.py:207:39: C0103: Argument name "id" doesn't conform to snake_case naming style (invalid-name)
replay_buffers/base_replay_buffer.py:207:39: W0622: Redefining built-in 'id' (redefined-builtin)
replay_buffers/base_replay_buffer.py:156:8: W0201: Attribute 'pointer' defined outside __init__ (attribute-defined-outside-init)
replay_buffers/base_replay_buffer.py:157:8: W0201: Attribute 'size' defined outside __init__ (attribute-defined-outside-init)
replay_buffers/base_replay_buffer.py:211:0: C0115: Missing class docstring (missing-class-docstring)
replay_buffers/base_replay_buffer.py:211:0: R0902: Too many instance attributes (16/7) (too-many-instance-attributes)
replay_buffers/base_replay_buffer.py:211:0: W0223: Method 'load' is abstract in class 'BaseReplayBuffer' but is not overridden (abstract-method)
replay_buffers/base_replay_buffer.py:211:0: W0223: Method 'sample_from_indices' is abstract in class 'BaseReplayBuffer' but is not overridden (abstract-method)
replay_buffers/base_replay_buffer.py:212:4: R0913: Too many arguments (7/5) (too-many-arguments)
replay_buffers/base_replay_buffer.py:237:8: W0622: Redefining built-in 'id' (redefined-builtin)
replay_buffers/base_replay_buffer.py:229:4: R0913: Too many arguments (8/5) (too-many-arguments)
replay_buffers/base_replay_buffer.py:229:4: W0221: Number of parameters was 3 in 'BaseReplayBuffer.store' and is now 8 in overridden 'BasePPOReplayBuffer.store' method (arguments-differ)
replay_buffers/base_replay_buffer.py:229:4: W0221: Variadics removed in overridden 'BasePPOReplayBuffer.store' method (arguments-differ)
replay_buffers/base_replay_buffer.py:237:8: W0613: Unused argument 'id' (unused-argument)
replay_buffers/base_replay_buffer.py:249:4: W0221: Variadics removed in overridden 'BasePPOReplayBuffer.sample' method (arguments-differ)
replay_buffers/base_replay_buffer.py:289:4: C0116: Missing function or method docstring (missing-function-docstring)
replay_buffers/base_replay_buffer.py:246:8: W0201: Attribute 'pointer' defined outside __init__ (attribute-defined-outside-init)
replay_buffers/base_replay_buffer.py:250:8: W0201: Attribute 'pointer' defined outside __init__ (attribute-defined-outside-init)
replay_buffers/base_replay_buffer.py:247:8: W0201: Attribute 'size' defined outside __init__ (attribute-defined-outside-init)
replay_buffers/base_replay_buffer.py:250:22: W0201: Attribute 'trajectory_start_index' defined outside __init__ (attribute-defined-outside-init)
replay_buffers/base_replay_buffer.py:306:8: W0201: Attribute 'trajectory_start_index' defined outside __init__ (attribute-defined-outside-init)
replay_buffers/base_replay_buffer.py:253:8: W0201: Attribute 'advantage_buffer' defined outside __init__ (attribute-defined-outside-init)
************* Module rl-research.replay_buffers.fast_sum_tree
replay_buffers/fast_sum_tree.py:1:0: C0114: Missing module docstring (missing-module-docstring)
replay_buffers/fast_sum_tree.py:4:0: C0115: Missing class docstring (missing-class-docstring)
replay_buffers/fast_sum_tree.py:4:0: R0205: Class 'FastSumTree' inherits from object, can be safely removed from bases in python3 (useless-object-inheritance)
replay_buffers/fast_sum_tree.py:27:4: C0116: Missing function or method docstring (missing-function-docstring)
replay_buffers/fast_sum_tree.py:36:23: C0103: Argument name "v" doesn't conform to snake_case naming style (invalid-name)
replay_buffers/fast_sum_tree.py:36:4: C0116: Missing function or method docstring (missing-function-docstring)
replay_buffers/fast_sum_tree.py:41:12: R1723: Unnecessary "else" after "break" (no-else-break)
replay_buffers/fast_sum_tree.py:54:4: C0116: Missing function or method docstring (missing-function-docstring)
************* Module rl-research.replay_buffers.muzero_replay_buffer
replay_buffers/muzero_replay_buffer.py:1:0: C0114: Missing module docstring (missing-module-docstring)
replay_buffers/muzero_replay_buffer.py:2:0: E0401: Unable to import 'replay_buffers.alphazero_replay_buffer' (import-error)
replay_buffers/muzero_replay_buffer.py:3:0: E0401: Unable to import 'replay_buffers.base_replay_buffer' (import-error)
replay_buffers/muzero_replay_buffer.py:6:0: C0115: Missing class docstring (missing-class-docstring)
replay_buffers/muzero_replay_buffer.py:20:4: C0116: Missing function or method docstring (missing-function-docstring)
replay_buffers/muzero_replay_buffer.py:46:4: R0913: Too many arguments (7/5) (too-many-arguments)
replay_buffers/muzero_replay_buffer.py:6:0: R0903: Too few public methods (1/2) (too-few-public-methods)
replay_buffers/muzero_replay_buffer.py:1:0: W0611: Unused numpy imported as np (unused-import)
replay_buffers/muzero_replay_buffer.py:2:0: W0611: Unused AlphaZeroReplayBuffer imported from replay_buffers.alphazero_replay_buffer (unused-import)
replay_buffers/muzero_replay_buffer.py:3:0: W0611: Unused Game imported from replay_buffers.base_replay_buffer (unused-import)
************* Module rl-research.replay_buffers.n_step_replay_buffer
replay_buffers/n_step_replay_buffer.py:47:0: C0301: Line too long (102/100) (line-too-long)
replay_buffers/n_step_replay_buffer.py:1:0: C0114: Missing module docstring (missing-module-docstring)
replay_buffers/n_step_replay_buffer.py:4:0: E0401: Unable to import 'replay_buffers.base_replay_buffer' (import-error)
replay_buffers/n_step_replay_buffer.py:7:0: C0115: Missing class docstring (missing-class-docstring)
replay_buffers/n_step_replay_buffer.py:8:4: R0913: Too many arguments (9/5) (too-many-arguments)
replay_buffers/n_step_replay_buffer.py:39:8: C0103: Argument name "id" doesn't conform to snake_case naming style (invalid-name)
replay_buffers/n_step_replay_buffer.py:39:8: W0622: Redefining built-in 'id' (redefined-builtin)
replay_buffers/n_step_replay_buffer.py:30:4: R0913: Too many arguments (10/5) (too-many-arguments)
replay_buffers/n_step_replay_buffer.py:78:4: C0116: Missing function or method docstring (missing-function-docstring)
replay_buffers/n_step_replay_buffer.py:88:12: C0103: Variable name "r" doesn't conform to snake_case naming style (invalid-name)
replay_buffers/n_step_replay_buffer.py:88:25: C0103: Variable name "d" doesn't conform to snake_case naming style (invalid-name)
replay_buffers/n_step_replay_buffer.py:80:8: W0201: Attribute 'n_step_buffers' defined outside __init__ (attribute-defined-outside-init)
replay_buffers/n_step_replay_buffer.py:4:0: W0611: Unused BaseReplayBuffer imported from replay_buffers.base_replay_buffer (unused-import)
replay_buffers/n_step_replay_buffer.py:2:0: C0411: standard import "from collections import deque" should be placed before "import numpy as np" (wrong-import-order)
************* Module rl-research.replay_buffers.nfsp_reservoir_buffer
replay_buffers/nfsp_reservoir_buffer.py:37:0: C0301: Line too long (204/100) (line-too-long)
replay_buffers/nfsp_reservoir_buffer.py:1:0: C0114: Missing module docstring (missing-module-docstring)
replay_buffers/nfsp_reservoir_buffer.py:3:0: E0401: Unable to import 'replay_buffers.base_replay_buffer' (import-error)
replay_buffers/nfsp_reservoir_buffer.py:5:0: E0611: No name 'augment_board' in module 'utils' (no-name-in-module)
replay_buffers/nfsp_reservoir_buffer.py:8:0: C0115: Missing class docstring (missing-class-docstring)
replay_buffers/nfsp_reservoir_buffer.py:8:0: R0902: Too many instance attributes (8/7) (too-many-instance-attributes)
replay_buffers/nfsp_reservoir_buffer.py:9:4: R0913: Too many arguments (7/5) (too-many-arguments)
replay_buffers/nfsp_reservoir_buffer.py:32:8: C0103: Argument name "id" doesn't conform to snake_case naming style (invalid-name)
replay_buffers/nfsp_reservoir_buffer.py:32:8: W0622: Redefining built-in 'id' (redefined-builtin)
replay_buffers/nfsp_reservoir_buffer.py:32:8: W0613: Unused argument 'id' (unused-argument)
replay_buffers/nfsp_reservoir_buffer.py:53:4: C0116: Missing function or method docstring (missing-function-docstring)
replay_buffers/nfsp_reservoir_buffer.py:97:4: C0116: Missing function or method docstring (missing-function-docstring)
replay_buffers/nfsp_reservoir_buffer.py:44:12: W0201: Attribute 'size' defined outside __init__ (attribute-defined-outside-init)
replay_buffers/nfsp_reservoir_buffer.py:111:8: W0201: Attribute 'size' defined outside __init__ (attribute-defined-outside-init)
replay_buffers/nfsp_reservoir_buffer.py:112:8: W0201: Attribute 'add_calls' defined outside __init__ (attribute-defined-outside-init)
replay_buffers/nfsp_reservoir_buffer.py:99:12: W0201: Attribute 'observation_buffer' defined outside __init__ (attribute-defined-outside-init)
replay_buffers/nfsp_reservoir_buffer.py:104:12: W0201: Attribute 'observation_buffer' defined outside __init__ (attribute-defined-outside-init)
replay_buffers/nfsp_reservoir_buffer.py:107:8: W0201: Attribute 'info_buffer' defined outside __init__ (attribute-defined-outside-init)
replay_buffers/nfsp_reservoir_buffer.py:108:8: W0201: Attribute 'target_policy_buffer' defined outside __init__ (attribute-defined-outside-init)
replay_buffers/nfsp_reservoir_buffer.py:5:0: W0611: Unused augment_board imported from utils (unused-import)
replay_buffers/nfsp_reservoir_buffer.py:5:0: C0411: third party import "from utils import augment_board" should be placed before "from replay_buffers.base_replay_buffer import BaseReplayBuffer" (wrong-import-order)
************* Module rl-research.replay_buffers.prioritized_n_step_replay_buffer
replay_buffers/prioritized_n_step_replay_buffer.py:41:0: C0301: Line too long (140/100) (line-too-long)
replay_buffers/prioritized_n_step_replay_buffer.py:230:0: C0301: Line too long (140/100) (line-too-long)
replay_buffers/prioritized_n_step_replay_buffer.py:1:0: C0114: Missing module docstring (missing-module-docstring)
replay_buffers/prioritized_n_step_replay_buffer.py:3:0: E0401: Unable to import 'replay_buffers.segment_tree' (import-error)
replay_buffers/prioritized_n_step_replay_buffer.py:4:0: E0401: Unable to import 'replay_buffers.fast_sum_tree' (import-error)
replay_buffers/prioritized_n_step_replay_buffer.py:5:0: E0401: Unable to import 'replay_buffers.n_step_replay_buffer' (import-error)
replay_buffers/prioritized_n_step_replay_buffer.py:8:0: C0115: Missing class docstring (missing-class-docstring)
replay_buffers/prioritized_n_step_replay_buffer.py:9:4: R0913: Too many arguments (12/5) (too-many-arguments)
replay_buffers/prioritized_n_step_replay_buffer.py:24:15: R1716: Simplify chained comparison between the operands (chained-comparison)
replay_buffers/prioritized_n_step_replay_buffer.py:25:15: R1716: Simplify chained comparison between the operands (chained-comparison)
replay_buffers/prioritized_n_step_replay_buffer.py:27:15: R1716: Simplify chained comparison between the operands (chained-comparison)
replay_buffers/prioritized_n_step_replay_buffer.py:30:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
replay_buffers/prioritized_n_step_replay_buffer.py:54:8: C0103: Argument name "id" doesn't conform to snake_case naming style (invalid-name)
replay_buffers/prioritized_n_step_replay_buffer.py:45:4: C0116: Missing function or method docstring (missing-function-docstring)
replay_buffers/prioritized_n_step_replay_buffer.py:54:8: W0622: Redefining built-in 'id' (redefined-builtin)
replay_buffers/prioritized_n_step_replay_buffer.py:45:4: R0913: Too many arguments (11/5) (too-many-arguments)
replay_buffers/prioritized_n_step_replay_buffer.py:83:4: C0116: Missing function or method docstring (missing-function-docstring)
replay_buffers/prioritized_n_step_replay_buffer.py:86:4: C0116: Missing function or method docstring (missing-function-docstring)
replay_buffers/prioritized_n_step_replay_buffer.py:98:8: C0200: Consider using enumerate instead of iterating with range and len (consider-using-enumerate)
replay_buffers/prioritized_n_step_replay_buffer.py:111:4: C0116: Missing function or method docstring (missing-function-docstring)
replay_buffers/prioritized_n_step_replay_buffer.py:113:12: R1720: Unnecessary "else" after "raise" (no-else-raise)
replay_buffers/prioritized_n_step_replay_buffer.py:114:16: E0702: Raising str while only classes or instances are allowed (raising-bad-type)
replay_buffers/prioritized_n_step_replay_buffer.py:114:22: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
replay_buffers/prioritized_n_step_replay_buffer.py:134:4: C0116: Missing function or method docstring (missing-function-docstring)
replay_buffers/prioritized_n_step_replay_buffer.py:146:4: C0116: Missing function or method docstring (missing-function-docstring)
replay_buffers/prioritized_n_step_replay_buffer.py:152:23: W0622: Redefining built-in 'id' (redefined-builtin)
replay_buffers/prioritized_n_step_replay_buffer.py:152:23: C0103: Variable name "id" doesn't conform to snake_case naming style (invalid-name)
replay_buffers/prioritized_n_step_replay_buffer.py:155:19: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
replay_buffers/prioritized_n_step_replay_buffer.py:169:37: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
replay_buffers/prioritized_n_step_replay_buffer.py:186:12: C0103: Variable name "a" doesn't conform to snake_case naming style (invalid-name)
replay_buffers/prioritized_n_step_replay_buffer.py:187:12: C0103: Variable name "b" doesn't conform to snake_case naming style (invalid-name)
replay_buffers/prioritized_n_step_replay_buffer.py:72:12: W0201: Attribute 'max_priority' defined outside __init__ (attribute-defined-outside-init)
replay_buffers/prioritized_n_step_replay_buffer.py:136:8: W0201: Attribute 'max_priority' defined outside __init__ (attribute-defined-outside-init)
replay_buffers/prioritized_n_step_replay_buffer.py:165:16: W0201: Attribute 'max_priority' defined outside __init__ (attribute-defined-outside-init)
replay_buffers/prioritized_n_step_replay_buffer.py:174:16: W0201: Attribute 'max_priority' defined outside __init__ (attribute-defined-outside-init)
replay_buffers/prioritized_n_step_replay_buffer.py:79:12: W0201: Attribute 'tree_pointer' defined outside __init__ (attribute-defined-outside-init)
replay_buffers/prioritized_n_step_replay_buffer.py:137:8: W0201: Attribute 'tree_pointer' defined outside __init__ (attribute-defined-outside-init)
replay_buffers/prioritized_n_step_replay_buffer.py:143:8: W0201: Attribute 'sum_tree' defined outside __init__ (attribute-defined-outside-init)
replay_buffers/prioritized_n_step_replay_buffer.py:144:8: W0201: Attribute 'min_tree' defined outside __init__ (attribute-defined-outside-init)
replay_buffers/prioritized_n_step_replay_buffer.py:204:0: C0115: Missing class docstring (missing-class-docstring)
replay_buffers/prioritized_n_step_replay_buffer.py:205:4: R0913: Too many arguments (9/5) (too-many-arguments)
replay_buffers/prioritized_n_step_replay_buffer.py:217:15: R1716: Simplify chained comparison between the operands (chained-comparison)
replay_buffers/prioritized_n_step_replay_buffer.py:218:15: R1716: Simplify chained comparison between the operands (chained-comparison)
replay_buffers/prioritized_n_step_replay_buffer.py:220:15: R1716: Simplify chained comparison between the operands (chained-comparison)
replay_buffers/prioritized_n_step_replay_buffer.py:222:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
replay_buffers/prioritized_n_step_replay_buffer.py:236:4: C0116: Missing function or method docstring (missing-function-docstring)
replay_buffers/prioritized_n_step_replay_buffer.py:236:4: R0913: Too many arguments (6/5) (too-many-arguments)
replay_buffers/prioritized_n_step_replay_buffer.py:256:4: C0116: Missing function or method docstring (missing-function-docstring)
replay_buffers/prioritized_n_step_replay_buffer.py:256:4: R0914: Too many local variables (17/15) (too-many-locals)
replay_buffers/prioritized_n_step_replay_buffer.py:264:12: C0103: Variable name "a" doesn't conform to snake_case naming style (invalid-name)
replay_buffers/prioritized_n_step_replay_buffer.py:264:15: C0103: Variable name "b" doesn't conform to snake_case naming style (invalid-name)
replay_buffers/prioritized_n_step_replay_buffer.py:303:4: C0116: Missing function or method docstring (missing-function-docstring)
replay_buffers/prioritized_n_step_replay_buffer.py:308:33: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
replay_buffers/prioritized_n_step_replay_buffer.py:1:0: W0611: Unused time imported from time (unused-import)
************* Module rl-research.replay_buffers.segment_tree
replay_buffers/segment_tree.py:105:9: W0511: TODO: Check assert case and fix bug (fixme)
replay_buffers/segment_tree.py:142:0: C0304: Final newline missing (missing-final-newline)
replay_buffers/segment_tree.py:37:4: R0913: Too many arguments (6/5) (too-many-arguments)
replay_buffers/segment_tree.py:44:8: R1705: Unnecessary "else" after "return" (no-else-return)
replay_buffers/segment_tree.py:47:12: R1705: Unnecessary "else" after "return" (no-else-return)
replay_buffers/segment_tree.py:95:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
replay_buffers/segment_tree.py:101:15: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
replay_buffers/segment_tree.py:106:53: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
replay_buffers/segment_tree.py:136:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
replay_buffers/segment_tree.py:142:15: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
************* Module rl-research.replay_buffers.test
replay_buffers/test.py:1:0: C0114: Missing module docstring (missing-module-docstring)
replay_buffers/test.py:1:0: E0401: Unable to import 'dill' (import-error)
replay_buffers/test.py:2:0: E0401: Unable to import 'tensorflow' (import-error)
replay_buffers/test.py:6:0: E0401: Unable to import 'gymnasium' (import-error)
replay_buffers/test.py:6:0: C0413: Import "import gymnasium as gym" should be placed at the top of the module (wrong-import-position)
replay_buffers/test.py:8:0: C0413: Import "import sys" should be placed at the top of the module (wrong-import-position)
replay_buffers/test.py:12:0: C0413: Import "from rainbow.rainbow_agent import RainbowAgent" should be placed at the top of the module (wrong-import-position)
replay_buffers/test.py:14:0: C0413: Import "import numpy as np" should be placed at the top of the module (wrong-import-position)
replay_buffers/test.py:15:0: C0413: Import "import random" should be placed at the top of the module (wrong-import-position)
replay_buffers/test.py:21:0: C0116: Missing function or method docstring (missing-function-docstring)
replay_buffers/test.py:22:51: C0103: Variable name "f" doesn't conform to snake_case naming style (invalid-name)
replay_buffers/test.py:26:38: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)
replay_buffers/test.py:30:21: C0103: Argument name "n" doesn't conform to snake_case naming style (invalid-name)
replay_buffers/test.py:30:0: C0116: Missing function or method docstring (missing-function-docstring)
replay_buffers/test.py:34:18: R1734: Consider using [] instead of list() (use-list-literal)
replay_buffers/test.py:43:8: C0103: Variable name "t" doesn't conform to snake_case naming style (invalid-name)
replay_buffers/test.py:37:8: W0612: Unused variable 'training_step' (unused-variable)
replay_buffers/test.py:40:51: W0612: Unused variable 'info' (unused-variable)
replay_buffers/test.py:60:0: C0116: Missing function or method docstring (missing-function-docstring)
replay_buffers/test.py:62:59: C0103: Variable name "f" doesn't conform to snake_case naming style (invalid-name)
replay_buffers/test.py:68:8: W0612: Unused variable 'training_step' (unused-variable)
replay_buffers/test.py:71:20: W0612: Unused variable 'reward' (unused-variable)
replay_buffers/test.py:71:51: W0612: Unused variable 'info' (unused-variable)
replay_buffers/test.py:97:0: E0401: Unable to import 'replay_buffers.n_step_replay_buffer' (import-error)
replay_buffers/test.py:97:0: C0413: Import "from replay_buffers.n_step_replay_buffer import ReplayBuffer as OldNStep" should be placed at the top of the module (wrong-import-position)
replay_buffers/test.py:98:0: E0401: Unable to import 'replay_buffers.prioritized_n_step_replay_buffer' (import-error)
replay_buffers/test.py:98:0: C0413: Import "from replay_buffers.prioritized_n_step_replay_buffer import PrioritizedReplayBuffer as OldPrioritized" should be placed at the top of the module (wrong-import-position)
replay_buffers/test.py:101:0: E0401: Unable to import 'replay_buffers.prioritized_nstep' (import-error)
replay_buffers/test.py:101:0: C0413: Import "from replay_buffers.prioritized_nstep import ReplayBuffer as NewNStep" should be placed at the top of the module (wrong-import-position)
replay_buffers/test.py:104:0: C0116: Missing function or method docstring (missing-function-docstring)
replay_buffers/test.py:112:4: C0103: Variable name "oldN" doesn't conform to snake_case naming style (invalid-name)
replay_buffers/test.py:113:4: C0103: Variable name "oldP" doesn't conform to snake_case naming style (invalid-name)
replay_buffers/test.py:117:8: C0103: Variable name "t" doesn't conform to snake_case naming style (invalid-name)
replay_buffers/test.py:8:0: C0411: standard import "import sys" should be placed before "import dill" (wrong-import-order)
replay_buffers/test.py:15:0: C0411: standard import "import random" should be placed before "import dill" (wrong-import-order)
************* Module rl-research.search.alpha_beta_pruning
search/alpha_beta_pruning.py:223:29: W0511: TODO - different move ordering (fixme)
search/alpha_beta_pruning.py:315:29: W0511: TODO - different move ordering (fixme)
search/alpha_beta_pruning.py:35:0: C0301: Line too long (206/100) (line-too-long)
search/alpha_beta_pruning.py:180:0: C0301: Line too long (175/100) (line-too-long)
search/alpha_beta_pruning.py:237:0: C0301: Line too long (165/100) (line-too-long)
search/alpha_beta_pruning.py:252:0: C0301: Line too long (122/100) (line-too-long)
search/alpha_beta_pruning.py:272:0: C0301: Line too long (162/100) (line-too-long)
search/alpha_beta_pruning.py:329:0: C0301: Line too long (152/100) (line-too-long)
search/alpha_beta_pruning.py:390:0: C0301: Line too long (121/100) (line-too-long)
search/alpha_beta_pruning.py:1:0: C0114: Missing module docstring (missing-module-docstring)
search/alpha_beta_pruning.py:2:0: E0401: Unable to import 'bitboard' (import-error)
search/alpha_beta_pruning.py:15:0: C0115: Missing class docstring (missing-class-docstring)
search/alpha_beta_pruning.py:16:37: W0622: Redefining built-in 'eval' (redefined-builtin)
search/alpha_beta_pruning.py:16:4: R0913: Too many arguments (7/5) (too-many-arguments)
search/alpha_beta_pruning.py:31:0: C0115: Missing class docstring (missing-class-docstring)
search/alpha_beta_pruning.py:54:65: R1734: Consider using [] instead of list() (use-list-literal)
search/alpha_beta_pruning.py:56:32: R1735: Consider using {} instead of dict() (use-dict-literal)
search/alpha_beta_pruning.py:55:12: W0612: Unused variable 'i' (unused-variable)
search/alpha_beta_pruning.py:58:50: W0622: Redefining built-in 'eval' (redefined-builtin)
search/alpha_beta_pruning.py:58:4: R0913: Too many arguments (7/5) (too-many-arguments)
search/alpha_beta_pruning.py:83:33: W0622: Redefining built-in 'eval' (redefined-builtin)
search/alpha_beta_pruning.py:82:4: R0913: Too many arguments (7/5) (too-many-arguments)
search/alpha_beta_pruning.py:114:28: W0622: Redefining built-in 'eval' (redefined-builtin)
search/alpha_beta_pruning.py:113:4: R0913: Too many arguments (7/5) (too-many-arguments)
search/alpha_beta_pruning.py:114:14: W0613: Unused argument 'state' (unused-argument)
search/alpha_beta_pruning.py:114:21: W0613: Unused argument 'depth' (unused-argument)
search/alpha_beta_pruning.py:114:28: W0613: Unused argument 'eval' (unused-argument)
search/alpha_beta_pruning.py:114:34: W0613: Unused argument 'flag' (unused-argument)
search/alpha_beta_pruning.py:114:40: W0613: Unused argument 'best_move' (unused-argument)
search/alpha_beta_pruning.py:114:51: W0613: Unused argument 'ancient' (unused-argument)
search/alpha_beta_pruning.py:113:4: R0201: Method could be a function (no-self-use)
search/alpha_beta_pruning.py:119:4: C0116: Missing function or method docstring (missing-function-docstring)
search/alpha_beta_pruning.py:119:34: W0622: Redefining built-in 'eval' (redefined-builtin)
search/alpha_beta_pruning.py:119:4: R0913: Too many arguments (7/5) (too-many-arguments)
search/alpha_beta_pruning.py:134:4: C0116: Missing function or method docstring (missing-function-docstring)
search/alpha_beta_pruning.py:144:4: C0116: Missing function or method docstring (missing-function-docstring)
search/alpha_beta_pruning.py:149:0: C0115: Missing class docstring (missing-class-docstring)
search/alpha_beta_pruning.py:150:4: R0913: Too many arguments (6/5) (too-many-arguments)
search/alpha_beta_pruning.py:167:8: W0622: Redefining built-in 'hash' (redefined-builtin)
search/alpha_beta_pruning.py:204:12: W0622: Redefining built-in 'eval' (redefined-builtin)
search/alpha_beta_pruning.py:164:4: R0913: Too many arguments (7/5) (too-many-arguments)
search/alpha_beta_pruning.py:164:4: R0911: Too many return statements (7/6) (too-many-return-statements)
search/alpha_beta_pruning.py:164:4: R0912: Too many branches (20/12) (too-many-branches)
search/alpha_beta_pruning.py:259:8: W0622: Redefining built-in 'hash' (redefined-builtin)
search/alpha_beta_pruning.py:296:12: W0622: Redefining built-in 'eval' (redefined-builtin)
search/alpha_beta_pruning.py:256:4: R0913: Too many arguments (7/5) (too-many-arguments)
search/alpha_beta_pruning.py:256:4: R0911: Too many return statements (7/6) (too-many-return-statements)
search/alpha_beta_pruning.py:256:4: R0912: Too many branches (20/12) (too-many-branches)
search/alpha_beta_pruning.py:346:4: C0116: Missing function or method docstring (missing-function-docstring)
search/alpha_beta_pruning.py:346:4: R0913: Too many arguments (7/5) (too-many-arguments)
search/alpha_beta_pruning.py:360:4: C0116: Missing function or method docstring (missing-function-docstring)
search/alpha_beta_pruning.py:366:11: C0121: Comparison 'run_max_depth == None' should be 'run_max_depth is None' (singleton-comparison)
search/alpha_beta_pruning.py:3:0: C0411: standard import "import time" should be placed before "import bitboard as bb" (wrong-import-order)
search/alpha_beta_pruning.py:4:0: C0411: standard import "import typing" should be placed before "import bitboard as bb" (wrong-import-order)
************* Module rl-research.search.monte_carlo_tree_search
search/monte_carlo_tree_search.py:1:0: C0114: Missing module docstring (missing-module-docstring)
search/monte_carlo_tree_search.py:2:0: E0401: Unable to import 'gymnasium' (import-error)
search/monte_carlo_tree_search.py:3:0: R0402: Use 'from environments.environments_ import envs' instead (consider-using-from-import)
search/monte_carlo_tree_search.py:3:0: E0401: Unable to import 'environments.environments_.envs' (import-error)
search/monte_carlo_tree_search.py:4:0: E0401: Unable to import 'tensorflow' (import-error)
search/monte_carlo_tree_search.py:51:0: C0413: Import "from copy import deepcopy" should be placed at the top of the module (wrong-import-position)
search/monte_carlo_tree_search.py:52:0: C0413: Import "from math import log, sqrt, inf" should be placed at the top of the module (wrong-import-position)
search/monte_carlo_tree_search.py:53:0: C0413: Import "import random" should be placed at the top of the module (wrong-import-position)
search/monte_carlo_tree_search.py:56:0: C0115: Missing class docstring (missing-class-docstring)
search/monte_carlo_tree_search.py:56:0: R0902: Too many instance attributes (9/7) (too-many-instance-attributes)
search/monte_carlo_tree_search.py:57:4: R0913: Too many arguments (6/5) (too-many-arguments)
search/monte_carlo_tree_search.py:67:4: C0103: Method name "get_UCB_score" doesn't conform to snake_case naming style (invalid-name)
search/monte_carlo_tree_search.py:67:4: C0116: Missing function or method docstring (missing-function-docstring)
search/monte_carlo_tree_search.py:74:4: C0116: Missing function or method docstring (missing-function-docstring)
search/monte_carlo_tree_search.py:77:15: E1101: Instance of 'Node' has no 'game' member (no-member)
search/monte_carlo_tree_search.py:80:32: E1101: Instance of 'Node' has no 'game' member (no-member)
search/monte_carlo_tree_search.py:83:35: E1101: Instance of 'Node' has no 'action_to_try' member; maybe 'actions_to_try'? (no-member)
search/monte_carlo_tree_search.py:74:4: R1710: Either all return statements in a function should return an expression, or none of them should. (inconsistent-return-statements)
search/monte_carlo_tree_search.py:81:25: W0612: Unused variable 'reward' (unused-variable)
search/monte_carlo_tree_search.py:81:56: W0612: Unused variable 'info' (unused-variable)
search/monte_carlo_tree_search.py:89:4: C0116: Missing function or method docstring (missing-function-docstring)
search/monte_carlo_tree_search.py:93:12: C0103: Variable name "max_U" doesn't conform to snake_case naming style (invalid-name)
search/monte_carlo_tree_search.py:95:30: E1121: Too many positional arguments for method call (too-many-function-args)
search/monte_carlo_tree_search.py:95:53: E1101: Instance of 'Node' has no 'game' member (no-member)
search/monte_carlo_tree_search.py:116:4: C0116: Missing function or method docstring (missing-function-docstring)
search/monte_carlo_tree_search.py:119:8: C0103: Variable name "v" doesn't conform to snake_case naming style (invalid-name)
search/monte_carlo_tree_search.py:121:28: E1101: Instance of 'Node' has no 'game' member (no-member)
search/monte_carlo_tree_search.py:126:12: C0103: Variable name "v" doesn't conform to snake_case naming style (invalid-name)
search/monte_carlo_tree_search.py:124:12: W0612: Unused variable 'observation' (unused-variable)
search/monte_carlo_tree_search.py:124:56: W0612: Unused variable 'info' (unused-variable)
search/monte_carlo_tree_search.py:133:4: C0116: Missing function or method docstring (missing-function-docstring)
search/monte_carlo_tree_search.py:138:8: C0103: Variable name "max_N" doesn't conform to snake_case naming style (invalid-name)
search/monte_carlo_tree_search.py:78:8: W0201: Attribute 'actions_to_try' defined outside __init__ (attribute-defined-outside-init)
search/monte_carlo_tree_search.py:144:0: C0116: Missing function or method docstring (missing-function-docstring)
search/monte_carlo_tree_search.py:146:8: W0612: Unused variable 'i' (unused-variable)
search/monte_carlo_tree_search.py:1:0: W0611: Unused import time (unused-import)
search/monte_carlo_tree_search.py:3:0: W0611: Unused environments.environments_.envs imported as envs (unused-import)
search/monte_carlo_tree_search.py:51:0: C0411: standard import "from copy import deepcopy" should be placed before "import gymnasium as gym" (wrong-import-order)
search/monte_carlo_tree_search.py:52:0: C0411: standard import "from math import log, sqrt, inf" should be placed before "import gymnasium as gym" (wrong-import-order)
search/monte_carlo_tree_search.py:53:0: C0411: standard import "import random" should be placed before "import gymnasium as gym" (wrong-import-order)
************* Module compress_utils
storage/compress_utils.py:1:0: C0114: Missing module docstring (missing-module-docstring)
storage/compress_utils.py:18:19: C0103: Argument name "b" doesn't conform to snake_case naming style (invalid-name)
storage/compress_utils.py:18:0: C0116: Missing function or method docstring (missing-function-docstring)
storage/compress_utils.py:25:21: C0103: Argument name "o" doesn't conform to snake_case naming style (invalid-name)
storage/compress_utils.py:25:0: C0116: Missing function or method docstring (missing-function-docstring)
************* Module storage
storage/storage.py:1:0: C0114: Missing module docstring (missing-module-docstring)
storage/storage.py:3:0: E0401: Unable to import 'torch' (import-error)
storage/storage.py:4:0: E0401: Unable to import 'pymongo' (import-error)
storage/storage.py:5:0: E0401: Unable to import 'gridfs' (import-error)
storage/storage.py:13:0: C0115: Missing class docstring (missing-class-docstring)
storage/storage.py:20:0: C0115: Missing class docstring (missing-class-docstring)
storage/storage.py:29:8: C0103: Variable name "e" doesn't conform to snake_case naming style (invalid-name)
storage/storage.py:37:12: C0103: Variable name "db" doesn't conform to snake_case naming style (invalid-name)
storage/storage.py:45:4: C0116: Missing function or method docstring (missing-function-docstring)
storage/storage.py:48:8: W0622: Redefining built-in 'id' (redefined-builtin)
storage/storage.py:46:8: C0103: Variable name "db" doesn't conform to snake_case naming style (invalid-name)
storage/storage.py:48:8: C0103: Variable name "id" doesn't conform to snake_case naming style (invalid-name)
storage/storage.py:54:42: C0103: Argument name "id" doesn't conform to snake_case naming style (invalid-name)
storage/storage.py:54:4: C0116: Missing function or method docstring (missing-function-docstring)
storage/storage.py:54:42: W0622: Redefining built-in 'id' (redefined-builtin)
storage/storage.py:55:8: C0103: Variable name "db" doesn't conform to snake_case naming style (invalid-name)
storage/storage.py:72:12: W0622: Redefining built-in 'id' (redefined-builtin)
storage/storage.py:64:8: C0103: Variable name "db" doesn't conform to snake_case naming style (invalid-name)
storage/storage.py:65:8: C0103: Variable name "fs" doesn't conform to snake_case naming style (invalid-name)
storage/storage.py:71:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
storage/storage.py:72:12: C0103: Variable name "id" doesn't conform to snake_case naming style (invalid-name)
storage/storage.py:80:4: C0116: Missing function or method docstring (missing-function-docstring)
storage/storage.py:84:4: C0116: Missing function or method docstring (missing-function-docstring)
storage/storage.py:110:19: W0703: Catching too general exception Exception (broad-except)
storage/storage.py:89:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
storage/storage.py:102:16: C0103: Variable name "db" doesn't conform to snake_case naming style (invalid-name)
storage/storage.py:103:16: C0103: Variable name "fs" doesn't conform to snake_case naming style (invalid-name)
storage/storage.py:107:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
storage/storage.py:108:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
storage/storage.py:110:12: C0103: Variable name "e" doesn't conform to snake_case naming style (invalid-name)
storage/storage.py:111:16: E1205: Too many arguments for logging format string (logging-too-many-args)
storage/storage.py:6:0: C0411: standard import "import hashlib" should be placed before "import torch" (wrong-import-order)
storage/storage.py:7:0: C0411: standard import "import io" should be placed before "import torch" (wrong-import-order)
************* Module agent_configs_test
tests/agent_configs_test.py:1:0: C0114: Missing module docstring (missing-module-docstring)
tests/agent_configs_test.py:3:0: E0611: No name 'RainbowConfig' in module 'agent_configs' (no-name-in-module)
tests/agent_configs_test.py:3:0: E0611: No name 'ApeXActorConfig' in module 'agent_configs' (no-name-in-module)
tests/agent_configs_test.py:4:0: E0611: No name 'CartPoleConfig' in module 'game_configs' (no-name-in-module)
tests/agent_configs_test.py:7:0: C0116: Missing function or method docstring (missing-function-docstring)
tests/agent_configs_test.py:8:4: W0622: Redefining built-in 'dict' (redefined-builtin)
tests/agent_configs_test.py:31:0: C0116: Missing function or method docstring (missing-function-docstring)
************* Module can
vectorhash/can.py:203:0: C0301: Line too long (112/100) (line-too-long)
vectorhash/can.py:208:0: C0301: Line too long (124/100) (line-too-long)
vectorhash/can.py:216:0: C0301: Line too long (139/100) (line-too-long)
vectorhash/can.py:1:0: C0114: Missing module docstring (missing-module-docstring)
vectorhash/can.py:2:0: E0401: Unable to import 'torch' (import-error)
vectorhash/can.py:8:0: R0402: Use 'from matplotlib import animation' instead (consider-using-from-import)
vectorhash/can.py:11:0: C0103: Constant name "tau" doesn't conform to UPPER_CASE naming style (invalid-name)
vectorhash/can.py:12:0: C0103: Constant name "dt" doesn't conform to UPPER_CASE naming style (invalid-name)
vectorhash/can.py:16:0: C0103: Constant name "a" doesn't conform to UPPER_CASE naming style (invalid-name)
vectorhash/can.py:17:0: C0103: Constant name "lambda_net" doesn't conform to UPPER_CASE naming style (invalid-name)
vectorhash/can.py:18:0: C0103: Constant name "beta" doesn't conform to UPPER_CASE naming style (invalid-name)
vectorhash/can.py:19:0: C0103: Constant name "gamma" doesn't conform to UPPER_CASE naming style (invalid-name)
vectorhash/can.py:26:0: C0103: Constant name "l" doesn't conform to UPPER_CASE naming style (invalid-name)
vectorhash/can.py:27:0: C0103: Constant name "alpha" doesn't conform to UPPER_CASE naming style (invalid-name)
vectorhash/can.py:34:0: C0103: Constant name "l" doesn't conform to UPPER_CASE naming style (invalid-name)
vectorhash/can.py:35:0: C0103: Constant name "alpha" doesn't conform to UPPER_CASE naming style (invalid-name)
vectorhash/can.py:39:0: C0103: Constant name "a_0" doesn't conform to UPPER_CASE naming style (invalid-name)
vectorhash/can.py:40:0: C0103: Constant name "delta_r_ratio" doesn't conform to UPPER_CASE naming style (invalid-name)
vectorhash/can.py:70:8: C0103: Attribute name "dt" doesn't conform to snake_case naming style (invalid-name)
vectorhash/can.py:77:8: C0103: Attribute name "a" doesn't conform to snake_case naming style (invalid-name)
vectorhash/can.py:84:8: C0103: Attribute name "W" doesn't conform to snake_case naming style (invalid-name)
vectorhash/can.py:85:8: C0103: Attribute name "A" doesn't conform to snake_case naming style (invalid-name)
vectorhash/can.py:43:0: C0115: Missing class docstring (missing-class-docstring)
vectorhash/can.py:43:0: R0902: Too many instance attributes (24/7) (too-many-instance-attributes)
vectorhash/can.py:50:8: C0103: Argument name "dt" doesn't conform to snake_case naming style (invalid-name)
vectorhash/can.py:57:8: C0103: Argument name "a" doesn't conform to snake_case naming style (invalid-name)
vectorhash/can.py:49:8: W0621: Redefining name 'tau' from outer scope (line 11) (redefined-outer-name)
vectorhash/can.py:50:8: W0621: Redefining name 'dt' from outer scope (line 12) (redefined-outer-name)
vectorhash/can.py:54:8: W0621: Redefining name 'delta_r_ratio' from outer scope (line 40) (redefined-outer-name)
vectorhash/can.py:55:8: W0621: Redefining name 'alpha' from outer scope (line 27) (redefined-outer-name)
vectorhash/can.py:56:8: W0621: Redefining name 'a_0' from outer scope (line 39) (redefined-outer-name)
vectorhash/can.py:57:8: W0621: Redefining name 'a' from outer scope (line 16) (redefined-outer-name)
vectorhash/can.py:45:4: R0913: Too many arguments (16/5) (too-many-arguments)
vectorhash/can.py:45:4: R0914: Too many local variables (16/15) (too-many-locals)
vectorhash/can.py:63:11: C0121: Comparison 'initializer == None' should be 'initializer is None' (singleton-comparison)
vectorhash/can.py:65:11: C0121: Comparison 'healer == None' should be 'healer is None' (singleton-comparison)
vectorhash/can.py:95:4: C0103: Method name "_W" doesn't conform to snake_case naming style (invalid-name)
vectorhash/can.py:99:8: C0103: Variable name "X" doesn't conform to snake_case naming style (invalid-name)
vectorhash/can.py:99:11: C0103: Variable name "Y" doesn't conform to snake_case naming style (invalid-name)
vectorhash/can.py:124:4: C0103: Method name "_B" doesn't conform to snake_case naming style (invalid-name)
vectorhash/can.py:124:17: C0103: Argument name "v" doesn't conform to snake_case naming style (invalid-name)
vectorhash/can.py:130:4: C0103: Method name "_A" doesn't conform to snake_case naming style (invalid-name)
vectorhash/can.py:130:17: C0103: Argument name "x" doesn't conform to snake_case naming style (invalid-name)
vectorhash/can.py:145:19: C0103: Argument name "v" doesn't conform to snake_case naming style (invalid-name)
vectorhash/can.py:145:4: C0116: Missing function or method docstring (missing-function-docstring)
vectorhash/can.py:146:11: C0121: Comparison 'v == None' should be 'v is None' (singleton-comparison)
vectorhash/can.py:150:8: C0103: Variable name "Wx" doesn't conform to snake_case naming style (invalid-name)
vectorhash/can.py:151:8: C0103: Variable name "B" doesn't conform to snake_case naming style (invalid-name)
vectorhash/can.py:152:8: C0103: Variable name "z" doesn't conform to snake_case naming style (invalid-name)
vectorhash/can.py:43:0: R0903: Too few public methods (1/2) (too-few-public-methods)
vectorhash/can.py:161:0: C0413: Import "import math" should be placed at the top of the module (wrong-import-position)
vectorhash/can.py:164:0: C0116: Missing function or method docstring (missing-function-docstring)
vectorhash/can.py:184:8: W0621: Redefining name 'a' from outer scope (line 16) (redefined-outer-name)
vectorhash/can.py:164:0: R0914: Too many local variables (18/15) (too-many-locals)
vectorhash/can.py:170:8: C0103: Variable name "X" doesn't conform to snake_case naming style (invalid-name)
vectorhash/can.py:170:11: C0103: Variable name "Y" doesn't conform to snake_case naming style (invalid-name)
vectorhash/can.py:172:4: C0103: Variable name "l1" doesn't conform to snake_case naming style (invalid-name)
vectorhash/can.py:174:8: C0103: Variable name "l2" doesn't conform to snake_case naming style (invalid-name)
vectorhash/can.py:176:8: C0103: Variable name "l2" doesn't conform to snake_case naming style (invalid-name)
vectorhash/can.py:183:8: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
vectorhash/can.py:183:11: C0103: Variable name "y" doesn't conform to snake_case naming style (invalid-name)
vectorhash/can.py:184:8: C0103: Variable name "a" doesn't conform to snake_case naming style (invalid-name)
vectorhash/can.py:195:0: C0116: Missing function or method docstring (missing-function-docstring)
vectorhash/can.py:198:4: W0621: Redefining name 'dt' from outer scope (line 12) (redefined-outer-name)
vectorhash/can.py:198:4: C0103: Variable name "dt" doesn't conform to snake_case naming style (invalid-name)
vectorhash/can.py:211:4: C0103: Variable name "im" doesn't conform to snake_case naming style (invalid-name)
vectorhash/can.py:215:8: C0103: Variable name "im" doesn't conform to snake_case naming style (invalid-name)
vectorhash/can.py:216:8: C0103: Variable name "s" doesn't conform to snake_case naming style (invalid-name)
vectorhash/can.py:161:0: C0411: standard import "import math" should be placed before "import numpy as np" (wrong-import-order)
************* Module can_test
vectorhash/can_test.py:1:0: C0114: Missing module docstring (missing-module-docstring)
vectorhash/can_test.py:1:0: E0401: Unable to import 'torch' (import-error)
vectorhash/can_test.py:3:0: E0401: Unable to import 'tqdm' (import-error)
vectorhash/can_test.py:7:0: C0413: Import "from can import ContinousAttractorNetwork, plot_can_weights, animate_can" should be placed at the top of the module (wrong-import-position)
vectorhash/can_test.py:9:0: C0103: Constant name "device" doesn't conform to UPPER_CASE naming style (invalid-name)
vectorhash/can_test.py:12:0: C0116: Missing function or method docstring (missing-function-docstring)
vectorhash/can_test.py:20:0: C0116: Missing function or method docstring (missing-function-docstring)
vectorhash/can_test.py:24:8: W0612: Unused variable 'i' (unused-variable)
vectorhash/can_test.py:35:0: C0116: Missing function or method docstring (missing-function-docstring)
vectorhash/can_test.py:49:0: C0116: Missing function or method docstring (missing-function-docstring)
vectorhash/can_test.py:66:0: C0116: Missing function or method docstring (missing-function-docstring)
vectorhash/can_test.py:79:8: W0612: Unused variable 'i' (unused-variable)
vectorhash/can_test.py:90:0: C0116: Missing function or method docstring (missing-function-docstring)
vectorhash/can_test.py:113:0: C0116: Missing function or method docstring (missing-function-docstring)
vectorhash/can_test.py:2:0: C0411: standard import "import math" should be placed before "import torch" (wrong-import-order)
************* Module healers
vectorhash/healers.py:1:0: C0114: Missing module docstring (missing-module-docstring)
vectorhash/healers.py:1:0: E0401: Unable to import 'torch' (import-error)
vectorhash/healers.py:5:0: C0115: Missing class docstring (missing-class-docstring)
vectorhash/healers.py:12:4: C0116: Missing function or method docstring (missing-function-docstring)
vectorhash/healers.py:22:0: C0115: Missing class docstring (missing-class-docstring)
vectorhash/healers.py:23:4: W0231: __init__ method from base class 'Healer' is not called (super-init-not-called)
vectorhash/healers.py:48:8: C0103: Variable name "dt" doesn't conform to snake_case naming style (invalid-name)
vectorhash/healers.py:52:16: W0612: Unused variable 'i' (unused-variable)
vectorhash/healers.py:22:0: R0903: Too few public methods (1/2) (too-few-public-methods)
vectorhash/healers.py:2:0: C0411: standard import "import math" should be placed before "import torch" (wrong-import-order)
************* Module initializers
vectorhash/initializers.py:1:0: C0114: Missing module docstring (missing-module-docstring)
vectorhash/initializers.py:1:0: E0401: Unable to import 'torch' (import-error)
vectorhash/initializers.py:4:0: C0115: Missing class docstring (missing-class-docstring)
vectorhash/initializers.py:4:0: R0903: Too few public methods (1/2) (too-few-public-methods)
vectorhash/initializers.py:21:8: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
vectorhash/initializers.py:21:11: C0103: Variable name "y" doesn't conform to snake_case naming style (invalid-name)
vectorhash/initializers.py:22:8: C0103: Variable name "X" doesn't conform to snake_case naming style (invalid-name)
vectorhash/initializers.py:22:11: C0103: Variable name "Y" doesn't conform to snake_case naming style (invalid-name)
vectorhash/initializers.py:23:8: C0103: Variable name "x0" doesn't conform to snake_case naming style (invalid-name)
vectorhash/initializers.py:23:12: C0103: Variable name "y0" doesn't conform to snake_case naming style (invalid-name)
vectorhash/initializers.py:15:0: R0903: Too few public methods (0/2) (too-few-public-methods)
vectorhash/initializers.py:35:8: C0103: Variable name "x" doesn't conform to snake_case naming style (invalid-name)
vectorhash/initializers.py:35:11: C0103: Variable name "y" doesn't conform to snake_case naming style (invalid-name)
vectorhash/initializers.py:36:8: C0103: Variable name "X" doesn't conform to snake_case naming style (invalid-name)
vectorhash/initializers.py:36:11: C0103: Variable name "Y" doesn't conform to snake_case naming style (invalid-name)
vectorhash/initializers.py:39:12: C0103: Variable name "x0" doesn't conform to snake_case naming style (invalid-name)
vectorhash/initializers.py:40:12: C0103: Variable name "y0" doesn't conform to snake_case naming style (invalid-name)
vectorhash/initializers.py:38:12: W0612: Unused variable 'i' (unused-variable)
vectorhash/initializers.py:28:0: R0903: Too few public methods (0/2) (too-few-public-methods)
vectorhash/initializers.py:47:0: R0903: Too few public methods (0/2) (too-few-public-methods)
************* Module scaffold
vectorhash/scaffold.py:213:13: W0511: TODO: generalize to more dimensions (fixme)
vectorhash/scaffold.py:179:0: C0301: Line too long (109/100) (line-too-long)
vectorhash/scaffold.py:236:0: C0301: Line too long (135/100) (line-too-long)
vectorhash/scaffold.py:454:0: C0305: Trailing newlines (trailing-newlines)
vectorhash/scaffold.py:1:0: C0114: Missing module docstring (missing-module-docstring)
vectorhash/scaffold.py:1:0: E0401: Unable to import 'torch' (import-error)
vectorhash/scaffold.py:4:0: C0413: Import "from can import ContinousAttractorNetwork" should be placed at the top of the module (wrong-import-position)
vectorhash/scaffold.py:5:0: C0413: Import "from matplotlib import pyplot as plt" should be placed at the top of the module (wrong-import-position)
vectorhash/scaffold.py:6:0: C0413: Import "from healers import BurakHealer" should be placed at the top of the module (wrong-import-position)
vectorhash/scaffold.py:7:0: C0413: Import "import math" should be placed at the top of the module (wrong-import-position)
vectorhash/scaffold.py:8:0: C0413: Import "from vectorhash_functions import circular_mean, sort_polygon_vertices" should be placed at the top of the module (wrong-import-position)
vectorhash/scaffold.py:11:0: C0116: Missing function or method docstring (missing-function-docstring)
vectorhash/scaffold.py:29:8: C0103: Attribute name "N_h" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:30:8: C0103: Attribute name "N_g" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:31:8: C0103: Attribute name "N_patts" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:38:8: C0103: Attribute name "G" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:39:8: C0103: Attribute name "W_hg" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:40:8: C0103: Attribute name "H" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:41:8: C0103: Attribute name "W_gh" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:42:8: C0103: Attribute name "W_sh" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:43:8: C0103: Attribute name "W_hs" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:73:8: C0103: Attribute name "g" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:74:8: C0103: Attribute name "h" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:20:0: C0115: Missing class docstring (missing-class-docstring)
vectorhash/scaffold.py:20:0: R0902: Too many instance attributes (21/7) (too-many-instance-attributes)
vectorhash/scaffold.py:22:32: C0103: Argument name "N_h" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:22:4: R0913: Too many arguments (7/5) (too-many-arguments)
vectorhash/scaffold.py:33:12: C0103: Variable name "l" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:77:4: C0103: Method name "_G" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:78:8: C0103: Variable name "G" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:80:12: C0103: Variable name "l" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:89:4: C0103: Method name "_W_hg" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:90:8: C0103: Variable name "W_hg" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:93:8: C0103: Variable name "W_hg" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:97:4: C0103: Method name "_W_gh" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:105:4: R0914: Too many local variables (18/15) (too-many-locals)
vectorhash/scaffold.py:122:16: C0103: Variable name "d" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:136:28: W0621: Redefining name 'd' from outer scope (line 122) (redefined-outer-name)
vectorhash/scaffold.py:136:32: C0103: Variable name "d" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:120:8: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
vectorhash/scaffold.py:182:8: C0103: Variable name "c" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:194:12: W0621: Redefining name 'i' from outer scope (line 185) (redefined-outer-name)
vectorhash/scaffold.py:188:12: W0612: Unused variable 'closest' (unused-variable)
vectorhash/scaffold.py:212:12: W0622: Redefining built-in 'set' (redefined-builtin)
vectorhash/scaffold.py:214:12: C0103: Variable name "A" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:210:4: R0201: Method could be a function (no-self-use)
vectorhash/scaffold.py:223:12: C0103: Variable name "A" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:232:8: C0103: Variable name "g" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:233:8: C0103: Variable name "c" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:259:4: C0116: Missing function or method docstring (missing-function-docstring)
vectorhash/scaffold.py:270:4: C0116: Missing function or method docstring (missing-function-docstring)
vectorhash/scaffold.py:270:31: W0622: Redefining built-in 'input' (redefined-builtin)
vectorhash/scaffold.py:270:4: R0201: Method could be a function (no-self-use)
vectorhash/scaffold.py:278:27: C0103: Argument name "s" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:288:12: C0103: Variable name "h" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:295:4: C0116: Missing function or method docstring (missing-function-docstring)
vectorhash/scaffold.py:300:12: C0103: Variable name "s" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:301:12: C0103: Variable name "v" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:321:4: C0116: Missing function or method docstring (missing-function-docstring)
vectorhash/scaffold.py:326:12: C0103: Variable name "s" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:330:4: C0116: Missing function or method docstring (missing-function-docstring)
vectorhash/scaffold.py:333:8: C0103: Variable name "H" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:334:8: C0103: Variable name "G" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:335:8: C0103: Variable name "denoised_G" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:336:8: C0103: Variable name "denoised_H" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:337:8: C0103: Variable name "denoised_S" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:342:4: C0116: Missing function or method docstring (missing-function-docstring)
vectorhash/scaffold.py:344:8: C0103: Variable name "denoised_H" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:345:8: C0103: Variable name "denoised_S" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:350:23: C0103: Argument name "G" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:354:8: C0103: Variable name "denoised_G" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:358:19: C0103: Variable name "l" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:358:16: W0612: Unused variable 'j' (unused-variable)
vectorhash/scaffold.py:368:19: C0103: Argument name "g" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:368:0: C0116: Missing function or method docstring (missing-function-docstring)
vectorhash/scaffold.py:370:9: C0103: Variable name "ax" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:374:9: C0103: Variable name "ax" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:375:4: C0103: Variable name "a" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:379:9: C0103: Variable name "ax" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:380:4: C0103: Variable name "a" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:384:9: C0103: Variable name "ax" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:385:4: C0103: Variable name "a" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:390:23: C0103: Argument name "g" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:390:0: C0116: Missing function or method docstring (missing-function-docstring)
vectorhash/scaffold.py:391:39: W0212: Access to a protected member _find_clusters of a client class (protected-access)
vectorhash/scaffold.py:392:9: C0103: Variable name "ax" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:393:4: C0103: Variable name "a" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:397:12: C0103: Variable name "p" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:402:8: C0103: Variable name "c" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:407:8: C0103: Variable name "p" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:391:13: W0612: Unused variable 'visited_order' (unused-variable)
vectorhash/scaffold.py:438:35: C0103: Argument name "g" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:438:0: C0116: Missing function or method docstring (missing-function-docstring)
vectorhash/scaffold.py:439:9: C0103: Variable name "ax" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:440:4: C0103: Variable name "a" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold.py:7:0: C0411: standard import "import math" should be placed before "import torch" (wrong-import-order)
************* Module scaffold_test
vectorhash/scaffold_test.py:48:0: W0311: Bad indentation. Found 6 spaces, expected 8 (bad-indentation)
vectorhash/scaffold_test.py:49:0: W0311: Bad indentation. Found 6 spaces, expected 8 (bad-indentation)
vectorhash/scaffold_test.py:62:0: W0311: Bad indentation. Found 6 spaces, expected 8 (bad-indentation)
vectorhash/scaffold_test.py:1:0: C0114: Missing module docstring (missing-module-docstring)
vectorhash/scaffold_test.py:1:0: E0401: Unable to import 'torch' (import-error)
vectorhash/scaffold_test.py:5:0: C0116: Missing function or method docstring (missing-function-docstring)
vectorhash/scaffold_test.py:9:9: C0103: Variable name "ax" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold_test.py:21:0: C0116: Missing function or method docstring (missing-function-docstring)
vectorhash/scaffold_test.py:22:4: C0415: Import outside toplevel (torchvision) (import-outside-toplevel)
vectorhash/scaffold_test.py:22:4: E0401: Unable to import 'torchvision' (import-error)
vectorhash/scaffold_test.py:23:4: E0401: Unable to import 'torchvision' (import-error)
vectorhash/scaffold_test.py:23:4: C0415: Import outside toplevel (torchvision.transforms) (import-outside-toplevel)
vectorhash/scaffold_test.py:34:4: C0103: Variable name "l" doesn't conform to snake_case naming style (invalid-name)
vectorhash/scaffold_test.py:39:4: C0103: Variable name "GS" doesn't conform to snake_case naming style (invalid-name)
************* Module vectorhash_functions
vectorhash/vectorhash_functions.py:68:0: C0304: Final newline missing (missing-final-newline)
vectorhash/vectorhash_functions.py:1:0: C0114: Missing module docstring (missing-module-docstring)
vectorhash/vectorhash_functions.py:1:0: E0401: Unable to import 'torch' (import-error)
vectorhash/vectorhash_functions.py:4:28: C0103: Argument name "v" doesn't conform to snake_case naming style (invalid-name)
vectorhash/vectorhash_functions.py:14:4: C0103: Variable name "p" doesn't conform to snake_case naming style (invalid-name)
vectorhash/vectorhash_functions.py:32:4: C0103: Variable name "Im" doesn't conform to snake_case naming style (invalid-name)
vectorhash/vectorhash_functions.py:33:4: C0103: Variable name "Re" doesn't conform to snake_case naming style (invalid-name)
vectorhash/vectorhash_functions.py:36:4: C0103: Variable name "mean_Im" doesn't conform to snake_case naming style (invalid-name)
vectorhash/vectorhash_functions.py:37:4: C0103: Variable name "mean_Re" doesn't conform to snake_case naming style (invalid-name)
vectorhash/vectorhash_functions.py:40:4: C0103: Variable name "Arg" doesn't conform to snake_case naming style (invalid-name)
vectorhash/vectorhash_functions.py:45:15: C0103: Argument name "x" doesn't conform to snake_case naming style (invalid-name)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[56:929]
==utils.utils.utils:[32:905]
def normalize_policies(policies: torch.float32):
    # print(policies)
    policy_sums = policies.sum(axis=-1, keepdims=True)
    # print(policy_sums)
    policies = policies / policy_sums
    return policies


def action_mask(
    actions: Tensor, legal_moves, mask_value: float = 0, device="cpu"
) -> Tensor:
    """
    Mask actions that are not legal moves
    actions: Tensor, probabilities of actions or q-values
    """
    assert isinstance(
        legal_moves, list
    ), "Legal moves should be a list got {} of type {}".format(
        legal_moves, type(legal_moves)
    )

    # add a dimension if the legal moves are not a list of lists
    # if len(legal_moves) != actions.shape[0]:
    #     legal_moves = [legal_moves]
    assert (
        len(legal_moves) == actions.shape[0]
    ), "Legal moves should be the same length as the batch size"

    mask = torch.zeros_like(actions, dtype=torch.bool).to(device)
    for i, legal in enumerate(legal_moves):
        mask[i, legal] = True
    # print(mask)
    # print(actions)
    # actions[mask == 0] = mask_value
    actions = torch.where(mask, actions, torch.tensor(mask_value).to(device)).to(device)
    # print(mask)
    return actions


def clip_low_prob_actions(actions: Tensor, low_prob: float = 0.01) -> Tensor:
    """
    Clip actions with probability lower than low_prob to 0
    actions: Tensor, probabilities of actions
    """
    # print("Actions in low prob func", actions)
    if low_prob == 0:
        return actions
    mask = actions < low_prob
    # print("Mask", mask)
    actions = torch.where(mask, 0.0, actions)
    # print("Actions after clipping", actions)
    return actions


def get_legal_moves(info: dict | list[dict]):
    # print(info)
    if isinstance(info, dict):
        return [info["legal_moves"] if "legal_moves" in info else None]
    else:
        return [(i["legal_moves"] if "legal_moves" in i else None) for i in info]


def normalize_images(image: Tensor) -> Tensor:
    """Preprocessing step to normalize image with 8-bit (0-255) color inplace.
    Modifys the original tensor

    Args:
        image (Tensor): An 8-bit color image

    Returns:
        Tensor: The tensor divided by 255
    """
    # Return a copy of the tensor divided by 255
    normalized_image = image.div_(255)
    return normalized_image


def make_stack(item: Tensor) -> Tensor:
    """Convert a tensor of shape (*) to (1, *). Does not copy the data; instead,
    returns a view of the original tensor.

    Args:
        item (Tensor):

    Returns:
        Tensor: A view of the original tensor.
    """
    #
    return item.view(1, *item.shape)


def update_per_beta(
    per_beta: float, per_beta_final: float, per_beta_steps: int, initial_per_beta: int
):
    # could also use an initial per_beta instead of current (multiply below equation by current step)
    if per_beta < per_beta_final:
        clamp_func = min
    else:
        clamp_func = max
    per_beta = clamp_func(
        per_beta_final,
        per_beta + (per_beta_final - initial_per_beta) / (per_beta_steps),
    )

    return per_beta


def update_linear_schedule(
    final_value: float,
    total_steps: int,
    initial_value: float,
    current_step: int,
):
    # learning_rate = initial_value
    if initial_value < final_value:
        clamp_func = min
    else:
        clamp_func = max
    value = clamp_func(
        final_value,
        initial_value + ((final_value - initial_value) * (current_step / total_steps)),
    )
    return value


def update_inverse_sqrt_schedule(
    initial_value: float = None,
    current_step: int = None,
):
    return initial_value / math.sqrt(current_step + 1)


def default_plot_func(
    axs, key: str, values: list[dict], targets: dict, row: int, col: int
):
    axs[row][col].set_title(
        "{} | rolling average: {}".format(key, np.mean(values[-5:]))
    )
    x = np.arange(1, len(values) + 1)
    axs[row][col].plot(x, values)
    if key in targets and targets[key] is not None:
        axs[row][col].axhline(y=targets[key], color="r", linestyle="--")


def plot_scores(axs, key: str, values: list[dict], targets: dict, row: int, col: int):
    if len(values) == 0:
        return
    print(values)
    scores = [value["score"] for value in values]
    x = np.arange(1, len(values) + 1)
    axs[row][col].plot(x, scores)

    has_max_scores = "max_score" in values[0]
    has_min_scores = "min_score" in values[0]
    assert (
        has_max_scores == has_min_scores
    ), "Both max_scores and min_scores must be provided or not provided"

    if has_max_scores:
        max_scores = [value["max_score"] for value in values]
        min_scores = [value["min_score"] for value in values]
        axs[row][col].fill_between(x, min_scores, max_scores, alpha=0.5)

    has_target_model_updates = "target_model_updated" in values[0]
    has_model_updates = "model_updated" in values[0]

    if has_target_model_updates:
        weight_updates = [value["target_model_updated"] for value in values]
        for i, weight_update in enumerate(weight_updates):
            if weight_update:
                axs[row][col].axvline(
                    x=i,
                    color="black",
                    linestyle="dotted",
                    # label="Target Model Weight Update",
                )

    if has_model_updates:
        weight_updates = [value["model_updated"] for value in values]
        for i, weight_update in enumerate(weight_updates):
            if weight_update:
                axs[row][col].axvline(
                    x=i,
                    color="gray",
                    linestyle="dotted",
                    # label="Model Weight Update",
                )

    axs[row][col].set_title(
        f"{key} | rolling average: {np.mean(scores[-5:])} | latest: {scores[-1]}"
    )

    axs[row][col].set_xlabel("Game")
    axs[row][col].set_ylabel("Score")

    axs[row][col].set_xlim(1, len(values))

    if len(scores) > 1:
        best_fit_x, best_fit_y = np.polyfit(x, scores, 1)
        axs[row][col].plot(
            x,
            best_fit_x * x + best_fit_y,
            color="g",
            label="Best Fit Line",
            linestyle="dotted",
        )

    if key in targets and targets[key] is not None:
        axs[row][col].axhline(
            y=targets[key],
            color="r",
            linestyle="dashed",
            label="Target Score: {}".format(targets[key]),
        )

    axs[row][col].legend()


def plot_loss(axs, key: str, values: list[dict], targets: dict, row: int, col: int):
    loss = [value["loss"] for value in values]
    x = np.arange(1, len(values) + 1)
    axs[row][col].plot(x, loss)

    has_target_model_updates = "target_model_updated" in values[0]
    has_model_updates = "model_updated" in values[0]

    if has_target_model_updates:
        weight_updates = [value["target_model_updated"] for value in values]
        for i, weight_update in enumerate(weight_updates):
            if weight_update:
                axs[row][col].axvline(
                    x=i,
                    color="black",
                    linestyle="dotted",
                    # label="Target Model Weight Update",
                )

    if has_model_updates:
        weight_updates = [value["model_updated"] for value in values]
        for i, weight_update in enumerate(weight_updates):
            if weight_update:
                axs[row][col].axvline(
                    x=i,
                    color="gray",
                    linestyle="dotted",
                    # label="Model Weight Update",
                )

    axs[row][col].set_title(
        f"{key} | rolling average: {np.mean(loss[-5:])} | latest: {loss[-1]}"
    )

    axs[row][col].set_xlabel("Time Step")
    axs[row][col].set_ylabel("Loss")

    axs[row][col].set_xlim(1, len(values))

    if key in targets and targets[key] is not None:
        axs[row][col].axhline(
            y=targets[key],
            color="r",
            linestyle="dashed",
            label="Target Score: {}".format(targets[key]),
        )

    axs[row][col].legend()


def plot_exploitability(
    axs, key: str, values: list[dict], targets: dict, row: int, col: int
):
    if len(values) == 0:
        return
    exploitability = [abs(value["exploitability"]) for value in values]
    print(values)
    rolling_averages = [
        np.mean(exploitability[max(0, i - 5) : i])
        for i in range(1, len(exploitability) + 1)
    ]
    # print(rolling_averages)
    x = np.arange(1, len(values) + 1)
    axs[row][col].plot(x, rolling_averages)
    axs[row][col].plot(x, exploitability)

    has_target_model_updates = "target_model_updated" in values[0]
    has_model_updates = "model_updated" in values[0]

    if has_target_model_updates:
        weight_updates = [value["target_model_updated"] for value in values]
        for i, weight_update in enumerate(weight_updates):
            if weight_update:
                axs[row][col].axvline(
                    x=i,
                    color="black",
                    linestyle="dotted",
                    # label="Target Model Weight Update",
                )

    if has_model_updates:
        weight_updates = [value["model_updated"] for value in values]
        for i, weight_update in enumerate(weight_updates):
            if weight_update:
                axs[row][col].axvline(
                    x=i,
                    color="gray",
                    linestyle="dotted",
                    # label="Model Weight Update",
                )

    if len(rolling_averages) > 1:
        best_fit_x, best_fit_y = np.polyfit(x, rolling_averages, 1)
        axs[row][col].plot(
            x,
            best_fit_x * x + best_fit_y,
            color="g",
            label="Best Fit Line",
            linestyle="dotted",
        )

    axs[row][col].set_title(
        f"{key} | rolling average: {np.mean(exploitability[-5:])} | latest: {exploitability[-1]}"
    )

    axs[row][col].set_xlabel("Game")
    axs[row][col].set_ylabel("Exploitability (rolling average)")

    axs[row][col].set_xscale("log")
    axs[row][col].set_yscale("log")

    axs[row][col].set_xlim(1, len(values))
    # axs[row][col].set_ylim(0.01, 10)
    # axs[row][col].set_ylim(
    #     -(10 ** math.ceil(math.log10(abs(min_exploitability)))),
    #     10 ** math.ceil(math.log10(max_exploitability)),
    # )

    # axs[row][col].set_yticks(
    #     [
    #         -(10**i)
    #         for i in range(
    #             math.ceil(math.log10(abs(min_exploitability))),
    #             math.floor(math.log10(abs(min_exploitability))) - 1,
    #             -1,
    #         )
    #         if -(10**i) < min_exploitability
    #     ]
    #     + [0]
    #     + [
    #         10**i
    #         for i in range(
    #             math.ceil(math.log10(max_exploitability)),
    #             math.floor(math.log10(max_exploitability)) + 1,
    #         )
    #         if 10**i > max_exploitability
    #     ]
    # )

    if key in targets and targets[key] is not None:
        axs[row][col].axhline(
            y=targets[key],
            color="r",
            linestyle="dashed",
            label="Target Exploitability: {}".format(targets[key]),
        )

    axs[row][col].legend()


def plot_trials(scores: list, file_name: str, final_trial: int = 0):
    fig, axs = plt.subplots(
        1,
        1,
        figsize=(10, 5),
        squeeze=False,
    )
    if final_trial > 0:
        x = np.arange(1, final_trial + 1)
        scores = scores[:final_trial]
    else:
        x = np.arange(1, len(scores) + 1)
    axs[0][0].scatter(x, scores)
    best_fit_x, best_fit_y = np.polyfit(x, scores, 1)
    axs[0][0].plot(
        x,
        best_fit_x * x + best_fit_y,
        color="g",
        label="Best Fit Line",
        linestyle="dotted",
    )

    fig.suptitle("Score of Hyperopt trials over time for Rainbow DQN on CartPole-v1")
    axs[0][0].set_xlabel("Trial")
    axs[0][0].set_ylabel("Score")
    plt.savefig(f"./graphs/{file_name}.png")
    plt.show()
    plt.close(fig)


stat_keys_to_plot_funcs = {
    "test_score": plot_scores,
    "score": plot_scores,
    "policy_loss": plot_loss,
    "value_loss": plot_loss,
    "l2_loss": plot_loss,
    "loss": plot_loss,
    "rl_loss": plot_loss,
    "sl_loss": plot_loss,
    "exploitability": plot_exploitability,  # should this be plot_scores?
}


def plot_graphs(
    stats: dict,
    targets: dict,
    step: int,
    frames_seen: int,
    time_taken: float,
    model_name: str,
    dir: str = "./checkpoints/graphs",
):
    num_plots = len(stats)
    sqrt_num_plots = math.ceil(np.sqrt(num_plots))
    fig, axs = plt.subplots(
        sqrt_num_plots,
        sqrt_num_plots,
        figsize=(10 * sqrt_num_plots, 5 * sqrt_num_plots),
        squeeze=False,
    )

    hours = int(time_taken // 3600)
    minutes = int((time_taken % 3600) // 60)
    seconds = int(time_taken % 60)

    fig.suptitle(
        "training stats | training step {} | frames seen {} | time taken {} hours {} minutes {} seconds".format(
            step, frames_seen, hours, minutes, seconds
        )
    )

    for i, (key, values) in enumerate(stats.items()):
        row = i // sqrt_num_plots
        col = i % sqrt_num_plots

        if key in stat_keys_to_plot_funcs:
            stat_keys_to_plot_funcs[key](axs, key, values, targets, row, col)
        else:
            default_plot_func(axs, key, values, targets, row, col)

    for i in range(num_plots, sqrt_num_plots**2):
        row = i // sqrt_num_plots
        col = i % sqrt_num_plots
        fig.delaxes(axs[row][col])

    # plt.show()
    assert os.path.exists(dir), f"Directory {dir} does not exist"
    plt.savefig("{}/{}.png".format(dir, model_name))

    plt.close(fig)


def plot_comparisons(
    stats: list[dict],
    model_name: str,
    dir: str = "./checkpoints/graphs",
):
    num_plots = len(stats[0])
    sqrt_num_plots = math.ceil(np.sqrt(num_plots))
    fig, axs = plt.subplots(
        sqrt_num_plots,
        sqrt_num_plots,
        figsize=(10 * sqrt_num_plots, 5 * sqrt_num_plots),
        squeeze=False,
    )

    fig.suptitle("Comparison of training stats")

    for i, (key, _) in enumerate(stats[0].items()):
        row = i // sqrt_num_plots
        col = i % sqrt_num_plots
        # max_value = float("-inf")
        # min_value = float("inf")
        max_len = 0
        for s in stats:
            values = s[key]
            # print(values)
            max_len = max(max_len, len(values))
            print(max_len)
            # max_value = max(max_value, max(values))
            # min_value = min(min_value, min(values))
            if key in stat_keys_to_plot_funcs:
                stat_keys_to_plot_funcs[key](axs, key, values, {}, row, col)
                axs[row][col].set_xlim(0, max_len)
            else:
                default_plot_func(axs, key, values, {}, row, col)

        # axs[row][col].set_ylim(min_value, max_value)

    for i in range(num_plots, sqrt_num_plots**2):
        row = i // sqrt_num_plots
        col = i % sqrt_num_plots
        fig.delaxes(axs[row][col])

    # plt.show()
    os.makedirs(dir, exist_ok=True)
    plt.savefig("{}/{}.png".format(dir, model_name))

    plt.close(fig)


def prepare_kernel_initializers(kernel_initializer: str, output_layer: bool = False):
    if kernel_initializer == "pytorch_default":
        return None
    if kernel_initializer == "glorot_uniform":
        return nn.init.xavier_uniform_
    elif kernel_initializer == "glorot_normal":
        return nn.init.xavier_normal_
    elif kernel_initializer == "he_uniform":
        return nn.init.kaiming_uniform_
    elif kernel_initializer == "he_normal":
        return nn.init.kaiming_normal_
    elif kernel_initializer == "variance_baseline":
        return VarianceScaling()
    elif kernel_initializer == "variance_0.1":
        return VarianceScaling(scale=0.1)
    elif kernel_initializer == "variance_0.3":
        return VarianceScaling(scale=0.3)
    elif kernel_initializer == "variance_0.8":
        return VarianceScaling(scale=0.8)
    elif kernel_initializer == "variance_3":
        return VarianceScaling(scale=3)
    elif kernel_initializer == "variance_5":
        return VarianceScaling(scale=5)
    elif kernel_initializer == "variance_10":
        return VarianceScaling(scale=10)
    # TODO
    # elif kernel_initializer == "lecun_uniform":
    #     return LecunUniform(seed=np.random.seed())
    # elif kernel_initializer == "lecun_normal":
    #     return LecunNormal(seed=np.random.seed())
    elif kernel_initializer == "orthogonal":
        return nn.init.orthogonal_

    raise ValueError(f"Invalid kernel initializer: {kernel_initializer}")


def prepare_activations(activation: str):
    # print("Activation to prase: ", activation)
    if activation == "linear":
        return nn.Identity()
    elif activation == "relu":
        return nn.ReLU()
    elif activation == "relu6":
        return nn.ReLU6()
    elif activation == "sigmoid":
        return nn.Sigmoid()
    elif activation == "softplus":
        return nn.Softplus()
    elif activation == "soft_sign":
        return nn.Softsign()
    elif activation == "silu" or activation == "swish":
        return nn.SiLU()
    elif activation == "tanh":
        return nn.Tanh()
    # elif activation == "log_sigmoid":
    #     return nn.LogSigmoid()
    elif activation == "hard_sigmoid":
        return nn.Hardsigmoid()
    # elif activation == "hard_silu" or activation == "hard_swish":
    #     return nn.Hardswish()
    # elif activation == "hard_tanh":
    #     return nn.Hardtanh()
    elif activation == "elu":
        return nn.ELU()
    # elif activation == "celu":
    #     return nn.CELU()
    elif activation == "selu":
        return nn.SELU()
    elif activation == "gelu":
        return nn.GELU()
    # elif activation == "glu":
    #     return nn.GLU()

    raise ValueError(f"Activation {activation} not recognized")


def epsilon_greedy_policy(
    q_values: list[float], info: dict, epsilon: float, wrapper=np.argmax
):
    if np.random.rand() < epsilon:
        # print("selecting a random move")
        if "legal_moves" in info:
            # print("using legal moves")
            return random.choice(info["legal_moves"])
        else:
            q_values = q_values.reshape(-1)
            return random.choice(range(len(q_values)))
    else:
        # try:
        # print("using provided wrapper to select action")
        return wrapper(q_values, info)
    # except:
    #     return wrapper(q_values)


def add_dirichlet_noise(
    policy: list[float], dirichlet_alpha: float, exploration_fraction: float
):
    # MAKE ALPHAZERO USE THIS
    noise = np.random.dirichlet([dirichlet_alpha] * len(policy))
    frac = exploration_fraction
    for i, n in enumerate(noise):
        policy[i] = (1 - frac) * policy[i] + frac * n
    return policy


def augment_game(game, flip_y: bool = False, flip_x: bool = False, rot90: bool = False):
    # augmented_games[0] = rotate 90
    # augmented_games[1] = rotate 180
    # augmented_games[2] = rotate 270
    # augmented_games[3] = flip y (rotate 180 and flip x)
    # augmented_games[4] = rotate 90 and flip y (rotate 270 and flip x)
    # augmented_games[5] = rotate 180 and flip y (flip x)
    # augmented_games[6] = flip y and rotate 90 (rotate 270 and flip y) (rotate 90 and flip x)
    # augmented_games[7] = normal

    if (rot90 and flip_y) or (rot90 and flip_x):
        augemented_games = [copy.deepcopy(game) for _ in range(7)]
        for i in range(len(game.observation_history)):
            board = game.observation_history[i]
            policy = game.policy_history[i]
            augemented_games[0].observation_history[i] = np.rot90(board)
            augemented_games[0].policy_history[i] = np.rot90(policy)
            augemented_games[1].observation_history[i] = np.rot90(np.rot90(board))
            augemented_games[1].policy_history[i] = np.rot90(np.rot90(policy))
            augemented_games[2].observation_history[i] = np.rot90(
                np.rot90(np.rot90(board))
            )
            augemented_games[2].policy_history[i] = np.rot90(np.rot90(np.rot90(policy)))
            augemented_games[3].observation_history[i] = np.flipud(board)
            augemented_games[3].policy_history[i] = np.flipud(policy)
            augemented_games[4].observation_history[i] = np.flipud(np.rot90(board))
            augemented_games[4].policy_history[i] = np.flipud(np.rot90(policy))
            augemented_games[5].observation_history[i] = np.flipud(
                np.rot90(np.rot90(board))
            )
            augemented_games[5].policy_history[i] = np.flipud(
                np.rot90(np.rot90(policy))
            )
            augemented_games[6].observation_history[i] = np.rot90(np.flipud(board))
            augemented_games[6].policy_history[i] = np.rot90(np.flipud(policy))
    elif rot90 and not flip_y and not flip_x:
        augemented_games = [copy.deepcopy(game) for _ in range(3)]
        augemented_games[0].observation_history = [
            np.rot90(board) for board in game.observation_history
        ]
        augemented_games[0].policy_history = [
            np.rot90(policy) for policy in game.policy_history
        ]
        augemented_games[1].observation_history = [
            np.rot90(np.rot90(board)) for board in game.observation_history
        ]
        augemented_games[1].policy_history = [
            np.rot90(np.rot90(policy)) for policy in game.policy_history
        ]
        augemented_games[2].observation_history = [
            np.rot90(np.rot90(np.rot90(board))) for board in game.observation_history
        ]
        augemented_games[2].policy_history = [
            np.rot90(np.rot90(np.rot90(policy)) for policy in game.policy_history)
        ]
    elif flip_y and not rot90 and not flip_x:
        augemented_games = [copy.deepcopy(game)]
        augemented_games[0].observation_history = [
            np.flipud(board) for board in game.observation_history
        ]
        augemented_games[0].policy_history = [
            np.flipud(policy) for policy in game.policy_history
        ]

    elif flip_x and not rot90 and not flip_y:
        augemented_games = [copy.deepcopy(game) for _ in range(1)]
        augemented_games[0].observation_history = [
            np.fliplr(board) for board in game.observation_history
        ]
        augemented_games[0].policy_history = [
            np.fliplr(policy) for policy in game.policy_history
        ]

    augemented_games.append(game)
    return augemented_games


def augment_board(
    board, policy, flip_y: bool = False, flip_x: bool = False, rot90: bool = False
):
    if (rot90 and flip_y) or (rot90 and flip_x):
        augemented_boards = [copy.deepcopy(board) for _ in range(7)]
        augmented_policies = [copy.deepcopy(policy) for _ in range(7)]
        augemented_boards[0] = np.rot90(board)
        augmented_policies[0] = np.rot90(policy)
        augemented_boards[1] = np.rot90(np.rot90(board))
        augmented_policies[1] = np.rot90(np.rot90(policy))
        augemented_boards[2] = np.rot90(np.rot90(np.rot90(board)))
        augmented_policies[2] = np.rot90(np.rot90(np.rot90(policy)))
        augemented_boards[3] = np.flipud(board)
        augmented_policies[3] = np.flipud(policy)
        augemented_boards[4] = np.flipud(np.rot90(board))
        augmented_policies[4] = np.flipud(np.rot90(policy))
        augemented_boards[5] = np.flipud(np.rot90(np.rot90(board)))
        augmented_policies[5] = np.flipud(np.rot90(np.rot90(policy)))
        augemented_boards[6] = np.rot90(np.flipud(board))
        augmented_policies[6] = np.rot90(np.flipud(policy))
    elif rot90 and not flip_y and not flip_x:
        augemented_boards = [copy.deepcopy(board) for _ in range(3)]
        augmented_policies = [copy.deepcopy(policy) for _ in range(3)]
        augemented_boards[0] = np.rot90(board)
        augmented_policies[0] = np.rot90(policy)
        augemented_boards[1] = np.rot90(np.rot90(board))
        augmented_policies[1] = np.rot90(np.rot90(policy))
        augemented_boards[2] = np.rot90(np.rot90(np.rot90(board)))
        augmented_policies[2] = np.rot90(np.rot90(np.rot90(policy)))
    elif flip_y and not rot90 and not flip_x:
        augemented_boards = [copy.deepcopy(board)]
        augmented_policies = [copy.deepcopy(policy)]
        augemented_boards[0] = np.flipud(board)
        augmented_policies[0] = np.flipud(policy)
    elif flip_x and not rot90 and not flip_y:
        augemented_boards = [copy.deepcopy(board)]
        augmented_policies = [copy.deepcopy(policy)]
        augemented_boards[0] = np.fliplr(board)
        augmented_policies[0] = np.fliplr(policy)
    augemented_boards.append(board)
    augmented_policies.append(policy)
    return augemented_boards, augmented_policies


def sample_by_random_indices(
    max_index_or_1darray, batch_size: int, with_replacement=False
) -> npt.NDArray[np.int64]:
    """
    Sample from a numpy array using indices
    """
    return np.random.choice(max_index_or_1darray, batch_size, replace=with_replacement)


def sample_by_indices_probability(
    max_index_or_1darray, batch_size: int, probabilities: npt.NDArray[np.float64]
) -> npt.NDArray[np.int64]:
    """
    Sample from a numpy array using indices
    """
    return np.random.choice(max_index_or_1darray, batch_size, p=probabilities)


def sample_tree_proportional(
    tree, batch_size: int, max_size: int
) -> npt.NDArray[np.int64]:
    """
    tree: SumSegmentTree
    Sample proportionally from a sum segment tree. Used in prioritized experience replay
    """
    indices = np.zeros(batch_size, dtype=np.int64)
    total_priority = tree.sum(0, max_size - 1)
    priority_segment = total_priority / batch_size

    for i in range(batch_size):
        l = priority_segment * i
        h = priority_segment * (i + 1)
        upperbound = np.random.uniform(l, h)
        indices[i] = tree.retrieve(upperbound)
        # print(tree[indices[i]])

    return indices


def reward_clipping(reward: float, lower_bound: float = -1, upper_bound: float = 1):
    if reward < lower_bound:
        return lower_bound
    elif reward > upper_bound:
        return upper_bound
    return reward


def discounted_cumulative_sums(x, discount):
    # Discounted cumulative sums of vectors for computing rewards-to-go and advantage estimates
    return scipy.signal.lfilter([1], [1, float(-discount)], x[::-1], axis=0)[::-1]


def to_lists(l: list[Iterable]) -> list[Tuple]:
    """Convert a list of iterables to a zip of tuples

    Args:
        list (list[Iterable]): A list of iterables, e.g. [(1,1,1),(2,2,2),(3,3,3)]

    Returns:
        list[Tuple]: A list of tuples, i.e. [(1,2,3), (1,2,3), (1,2,3)]
    """

    return list(zip(*l))


def current_timestamp():
    return datetime.now().timestamp()


_epsilon = 1e-7


def categorical_crossentropy(predicted: torch.Tensor, target: torch.Tensor, axis=-1):
    # print(predicted)
    predicted = predicted / torch.sum(predicted, dim=axis, keepdim=True)
    # print(predicted)
    predicted = torch.clamp(predicted, _epsilon, 1.0 - _epsilon)
    # print(predicted)
    log_prob = torch.log(predicted)
    return -torch.sum(log_prob * target, axis=axis)


class CategoricalCrossentropyLoss:
    def __init__(self, from_logits=False, axis=-1):
        self.from_logits = from_logits
        self.axis = axis

    def __call__(self, predicted, target):
        return categorical_crossentropy(predicted, target, self.axis)


def kl_divergence(predicted: torch.Tensor, target: torch.Tensor, axis=-1):
    predicted = predicted / torch.sum(predicted, dim=axis, keepdim=True)
    predicted = torch.clamp(predicted, _epsilon, 1.0)
    target = torch.clamp(target, _epsilon, 1.0)
    return torch.sum(target * torch.log(target / predicted), axis=axis)


class KLDivergenceLoss:
    def __init__(self, from_logits=False, axis=-1):
        self.from_logits = from_logits
        self.axis = axis

    def __call__(self, predicted, target):
        return kl_divergence(predicted, target, self.axis)


def huber(predicted: torch.Tensor, target: torch.Tensor, axis=-1, delta: float = 1.0):
    diff = torch.abs(predicted - target)
    return torch.where(
        diff < delta, 0.5 * diff**2, delta * (diff - 0.5 * delta)
    ).view(-1)


class HuberLoss:
    def __init__(self, axis=-1, delta: float = 1.0):
        self.axis = axis
        self.delta = delta

    def __call__(self, predicted, target):
        return huber(predicted, target, axis=self.axis, delta=self.delta)


def mse(predicted: torch.Tensor, target: torch.Tensor):
    # print(predicted)
    # print(target)
    return (predicted - target) ** 2


class MSELoss:
    def __init__(self):
        pass

    def __call__(self, predicted, target):
        return mse(predicted, target)

 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.alphazero.alphazero_network:[11:336]
==rl-research.muzero.muzero_network:[308:635]
    def __init__(
        self,
        config: AlphaZeroConfig,
        output_size: int,
        input_shape: Tuple[int],
    ):
        assert (
            config.game.is_discrete
        ), "AlphaZero only works for discrete action space games (board games)"

        self.config = config

        super(Network, self).__init__()

        self.has_residual_layers = len(config.residual_layers) > 0
        self.has_conv_layers = len(config.conv_layers) > 0
        self.has_dense_layers = len(config.dense_layer_widths) > 0
        assert (
            self.has_conv_layers or self.has_dense_layers or self.has_residual_layers
        ), "At least one of the layers should be present."

        self.output_size = output_size

        current_shape = input_shape
        B = current_shape[0]

        # INPUTS = CONV + BATCHNORM + maybe RELU?

        if self.has_residual_layers:
            assert (
                len(input_shape) == 4
            ), "Input shape should be (B, C, H, W), got {}".format(input_shape)
            filters, kernel_sizes, strides = to_lists(config.residual_layers)

            # (B, C_in, H, W) -> (B, C_out H, W)
            self.residual_layers = ResidualStack(
                input_shape=input_shape,
                filters=filters,
                kernel_sizes=kernel_sizes,
                strides=strides,
                activation=self.config.activation,
                noisy_sigma=config.noisy_sigma,
            )
            current_shape = (
                B,
                self.residual_layers.output_channels,
                current_shape[2],
                current_shape[3],
            )

        if self.has_conv_layers:
            assert (
                len(input_shape) == 4
            ), "Input shape should be (B, C, H, W), got {}".format(input_shape)
            filters, kernel_sizes, strides = to_lists(config.conv_layers)

            # (B, C_in, H, W) -> (B, C_out H, W)
            self.conv_layers = Conv2dStack(
                input_shape=input_shape,
                filters=filters,
                kernel_sizes=kernel_sizes,
                strides=strides,
                activation=self.config.activation,
                noisy_sigma=config.noisy_sigma,
            )
            current_shape = (
                B,
                self.conv_layers.output_channels,
                current_shape[2],
                current_shape[3],
            )

        if self.has_dense_layers:
            if len(current_shape) == 4:
                initial_width = current_shape[1] * current_shape[2] * current_shape[3]
            else:
                assert len(current_shape) == 2
                initial_width = current_shape[1]

            # (B, width_in) -> (B, width_out)
            self.dense_layers = DenseStack(
                initial_width=initial_width,
                widths=self.config.dense_layer_widths,
                activation=self.config.activation,
                noisy_sigma=self.config.noisy_sigma,
            )
            current_shape = (
                B,
                self.dense_layers.output_width,
            )

        self.critic = CriticNetwork(config, current_shape)
        self.actor = ActorNetwork(config, current_shape, output_size)

    def initialize(self, initializer: Callable[[Tensor], None]) -> None:
        if self.has_residual_layers:
            self.residual_layers.initialize(initializer)
        if self.has_conv_layers:
            self.conv_layers.initialize(initializer)
        if self.has_dense_layers:
            self.dense_layers.initialize(initializer)

        self.actor.initialize(initializer)
        self.critic.initialize(initializer)

    def forward(self, inputs: Tensor):
        if self.has_conv_layers:
            assert inputs.dim() == 4

        # (B, *)
        S = inputs
        # INPUT CONV LAYERS???

        # (B, C_in, H, W) -> (B, C_out, H, W)
        if self.has_residual_layers:
            S = self.residual_layers(S)

        # (B, C_in, H, W) -> (B, C_out, H, W)
        if self.has_conv_layers:
            S = self.conv_layers(S)

        # (B, *) -> (B, dense_features_in)

        # (B, dense_features_in) -> (B, dense_features_out)
        if self.has_dense_layers:
            S = S.flatten(1, -1)
            S = self.dense_layers(S)

        return self.critic(S), self.actor(S)


class CriticNetwork(nn.Module):
    def __init__(
        self, config: AlphaZeroConfig, input_shape: Tuple[int], *args, **kwargs
    ):
        super().__init__(*args, **kwargs)
        self.config = config
        self.has_conv_layers = len(config.critic_conv_layers) > 0
        self.has_dense_layers = len(config.critic_dense_layer_widths) > 0

        current_shape = input_shape
        B = current_shape[0]
        if self.has_conv_layers:
            # WITH BATCHNORM FOR EVERY CONV LAYER
            assert len(input_shape) == 4
            filters, kernel_sizes, strides = to_lists(config.critic_conv_layers)

            # (B, C_in, H, W) -> (B, C_out H, W)
            self.conv_layers = Conv2dStack(
                input_shape=input_shape,
                filters=filters,
                kernel_sizes=kernel_sizes,
                strides=strides,
                activation=self.config.activation,
                noisy_sigma=config.noisy_sigma,
            )
            current_shape = (
                B,
                self.conv_layers.output_channels,
                current_shape[2],
                current_shape[3],
            )

        if self.has_dense_layers:
            if len(current_shape) == 4:
                initial_width = current_shape[1] * current_shape[2] * current_shape[3]
            else:
                assert len(current_shape) == 2
                initial_width = current_shape[1]

            # (B, width_in) -> (B, width_out)
            self.dense_layers = DenseStack(
                initial_width=initial_width,
                widths=self.config.critic_dense_layer_widths,
                activation=self.config.activation,
                noisy_sigma=self.config.noisy_sigma,
            )
            current_shape = (
                B,
                self.dense_layers.output_width,
            )

        if len(current_shape) == 4:
            initial_width = current_shape[1] * current_shape[2] * current_shape[3]
        else:
            assert len(current_shape) == 2
            initial_width = current_shape[1]

        self.value = build_dense(
            in_features=initial_width,
            out_features=1,
            sigma=config.noisy_sigma,
        )

    def initialize(self, initializer: Callable[[Tensor], None]) -> None:
        if self.has_conv_layers:
            self.conv_layers.initialize(initializer)
        if self.has_dense_layers:
            self.dense_layers.initialize(initializer)
        self.value.initialize(initializer)  # OUTPUT LAYER

    def forward(self, inputs: Tensor):
        if self.has_conv_layers:
            assert (
                inputs.dim() == 4
            ), "Input shape should be (B, C, H, W), got {}".format(inputs.shape)

        x = inputs
        if self.has_conv_layers:
            x = self.conv_layers(x)
        if self.has_dense_layers:
            x = x.flatten(1, -1)  # should this be batch, -1?
            x = self.dense_layers(x)
        value = self.value(x)
        return value.tanh()

    def reset_noise(self):
        if self.has_conv_layers:
            self.conv_layers.reset_noise()
        if self.has_dense_layers:
            self.dense_layers.reset_noise()
        self.value.reset_noise()


class ActorNetwork(nn.Module):
    def __init__(
        self,
        config: AlphaZeroConfig,
        input_shape: Tuple[int],
        output_size: int,
        *args,
        **kwargs
    ):
        super().__init__(*args, **kwargs)
        self.config = config
        self.has_conv_layers = len(config.actor_conv_layers) > 0
        self.has_dense_layers = len(config.actor_dense_layer_widths) > 0

        current_shape = input_shape
        B = current_shape[0]
        if self.has_conv_layers:
            # WITH BATCHNORM FOR EVERY CONV LAYER
            assert len(input_shape) == 4
            filters, kernel_sizes, strides = to_lists(config.actor_conv_layers)

            # (B, C_in, H, W) -> (B, C_out H, W)
            self.conv_layers = Conv2dStack(
                input_shape=input_shape,
                filters=filters,
                kernel_sizes=kernel_sizes,
                strides=strides,
                activation=self.config.activation,
                noisy_sigma=config.noisy_sigma,
            )
            current_shape = (
                B,
                self.conv_layers.output_channels,
                current_shape[2],
                current_shape[3],
            )

        if self.has_dense_layers:
            if len(current_shape) == 4:
                initial_width = current_shape[1] * current_shape[2] * current_shape[3]
            else:
                assert (
                    len(current_shape) == 2
                ), "Input shape should be (B, width), got {}".format(current_shape)
                initial_width = current_shape[1]

            # (B, width_in) -> (B, width_out)
            self.dense_layers = DenseStack(
                initial_width=initial_width,
                widths=self.config.actor_dense_layer_widths,
                activation=self.config.activation,
                noisy_sigma=self.config.noisy_sigma,
            )

            current_shape = (
                B,
                self.dense_layers.output_width,
            )

        if len(current_shape) == 4:
            initial_width = current_shape[1] * current_shape[2] * current_shape[3]
        else:
            assert len(current_shape) == 2
            initial_width = current_shape[1]

        self.actions = build_dense(
            in_features=initial_width,
            out_features=output_size,
            sigma=self.config.noisy_sigma,
        )

    def initialize(self, initializer: Callable[[Tensor], None]) -> None:
        if self.has_conv_layers:
            self.conv_layers.initialize(initializer)
        if self.has_dense_layers:
            self.dense_layers.initialize(initializer)
        self.actions.initialize(
            initializer
        )  # OUTPUT LAYER TO IMPLIMENT INTIALIZING WITH CONSTANT OF 0.01

    def forward(self, inputs: Tensor):
        if self.has_conv_layers:
            assert (
                inputs.dim() == 4
            ), "Input shape should be (B, C, H, W), got {}".format(inputs.shape)

        x = inputs
        if self.has_conv_layers:
            x = self.conv_layers(x)
        if self.has_dense_layers:
            x = x.flatten(1, -1)  # should this be batch, -1?
            x = self.dense_layers(x)
        actions = self.actions(x)
        return actions.softmax(dim=-1)

    def reset_noise(self):
        if self.has_conv_layers:
            self.conv_layers.reset_noise()
        if self.has_dense_layers:
            self.dense_layers.reset_noise()
        self.actions.reset_noise()

 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[2078:2380]
==rl-research.replay_buffers.base_replay_buffer:[6:306]
class BaseReplayBuffer:
    def __init__(
        self,
        max_size: int,
        batch_size: int = None,
        compressed_observations: bool = False,
    ):
        self.max_size = max_size
        self.batch_size = batch_size if batch_size is not None else max_size
        self.compressed_observations = compressed_observations

        self.clear()
        assert self.size == 0, "Replay buffer should be empty at initialization"
        assert self.max_size > 0, "Replay buffer should have a maximum size"
        assert self.batch_size > 0, "Replay buffer batch size should be greater than 0"

    def store(self, *args, **kwargs):
        raise NotImplementedError

    def sample(self, *args, **kwargs):
        raise NotImplementedError

    def sample_from_indices(self, indices: list[int]):
        raise NotImplementedError

    def clear(self):
        raise NotImplementedError

    def load(self, path):
        raise NotImplementedError

    def __len__(self):
        return self.size


class Game:
    def __init__(
        self, num_players: int
    ):  # num_actions, discount=1.0, n_step=1, gamma=0.99
        self.length = 0
        self.observation_history = []
        self.rewards = []
        self.policy_history = []
        self.value_history = []
        self.action_history = []
        self.info_history = []

        self.num_players = num_players

    def append(
        self,
        observation,
        reward: int,
        policy,
        value=None,
        action=None,
        info=None,
    ):
        self.observation_history.append(copy.deepcopy(observation))
        self.rewards.append(reward)
        self.policy_history.append(policy)
        self.value_history.append(value)
        self.action_history.append(action)
        self.info_history.append(info)
        self.length += 1

    def set_rewards(self):
        print("Initial Rewards", self.rewards)
        final_reward = self.rewards[-1]
        for i in reversed(range(self.length)):
            self.rewards[i] = (
                final_reward[i % self.num_players]
                # if i % self.num_players == (self.length - 1) % self.num_players
                # else -final_reward
            )
        print("Updated Rewards", self.rewards)

    def __len__(self):
        return self.length


class BaseGameReplayBuffer(BaseReplayBuffer):
    def __init__(
        self,
        max_size: int,
        batch_size: int,
    ):
        super().__init__(max_size=max_size, batch_size=batch_size)

    def store(self, game: Game):
        if len(self.buffer) >= self.max_size:
            self.buffer.pop(0)
        self.buffer.append(game)
        self.size += 1

    def sample(self):
        move_sum = float(sum([len(game) for game in self.buffer]))
        games: list[Game] = np.random.choice(
            self.buffer,
            self.batch_size,
            p=[len(game) / move_sum for game in self.buffer],
        )

        return [(game, np.random.randint(len(game))) for game in games]

    def clear(self):
        self.buffer: list[Game] = []
        self.size = 0


class BaseDQNReplayBuffer(BaseReplayBuffer):
    def __init__(
        self,
        observation_dimensions: tuple,
        observation_dtype: np.dtype,
        max_size: int,
        batch_size: int = 32,
        compressed_observations: bool = False,
    ):
        self.observation_dimensions = observation_dimensions
        self.observation_dtype = observation_dtype
        print(observation_dtype)
        super().__init__(
            max_size=max_size,
            batch_size=batch_size,
            compressed_observations=compressed_observations,
        )

    def store(
        self,
        observation,
        info: dict,
        action,
        reward: float,
        next_observation,
        next_info: dict,
        done: bool,
        id=None,
    ):
        # compute n-step return and store
        self.id_buffer[self.pointer] = id
        self.observation_buffer[self.pointer] = observation
        self.action_buffer[self.pointer] = action
        self.reward_buffer[self.pointer] = reward
        self.next_observation_buffer[self.pointer] = next_observation
        self.done_buffer[self.pointer] = done
        self.info_buffer[self.pointer] = info
        self.next_info_buffer[self.pointer] = next_info

        self.pointer = (self.pointer + 1) % self.max_size
        self.size = min(self.size + 1, self.max_size)

    def clear(self):
        if self.compressed_observations:
            self.observation_buffer = np.zeros(self.max_size, dtype=np.object_)
            self.next_observation_buffer = np.zeros(self.max_size, dtype=np.object_)
        else:
            observation_buffer_shape = (self.max_size,) + self.observation_dimensions
            self.observation_buffer = np.zeros(
                observation_buffer_shape, self.observation_dtype
            )
            self.next_observation_buffer = np.zeros(
                observation_buffer_shape, dtype=self.observation_dtype
            )

        self.id_buffer = np.zeros(self.max_size, dtype=np.object_)
        self.action_buffer = np.zeros(self.max_size, dtype=np.uint8)
        self.reward_buffer = np.zeros(self.max_size, dtype=np.float16)
        self.done_buffer = np.zeros(self.max_size, dtype=np.bool_)
        self.info_buffer = np.zeros(self.max_size, dtype=np.object_)
        self.next_info_buffer = np.zeros(self.max_size, dtype=np.object_)
        self.pointer = 0
        self.size = 0

    def sample(self):
        indices = np.random.choice(self.size, self.batch_size, replace=False)

        return dict(
            observations=self.observation_buffer[indices],
            next_observations=self.next_observation_buffer[indices],
            actions=self.action_buffer[indices],
            rewards=self.reward_buffer[indices],
            dones=self.done_buffer[indices],
            ids=self.id_buffer[indices],
            info=self.info_buffer[indices],
            next_info=self.next_info_buffer[indices],
        )

    def sample_from_indices(self, indices: list[int]):
        return dict(
            observations=self.observation_buffer[indices],
            next_observations=self.next_observation_buffer[indices],
            actions=self.action_buffer[indices],
            rewards=self.reward_buffer[indices],
            dones=self.done_buffer[indices],
            ids=self.id_buffer[indices],
            infos=self.info_buffer[indices],
            next_infos=self.next_info_buffer[indices],
        )

    def __check_id__(self, index: int, id: str) -> bool:
        return self.id_buffer[index] == id


class BasePPOReplayBuffer(BaseReplayBuffer):
    def __init__(
        self,
        observation_dimensions,
        observation_dtype: np.dtype,
        max_size: int,
        gamma: float = 0.99,
        gae_lambda: float = 0.95,
        compressed_observations: bool = False,
    ):
        self.observation_dimensions = observation_dimensions
        self.observation_dtype = observation_dtype
        self.gamma = gamma
        self.gae_lambda = gae_lambda
        super().__init__(
            max_size=max_size, compressed_observations=compressed_observations
        )

    def store(
        self,
        observation,
        info: dict,
        action,
        value: float,
        log_probability: float,
        reward: float,
        id=None,
    ):
        self.observation_buffer[self.pointer] = observation
        self.action_buffer[self.pointer] = action
        self.reward_buffer[self.pointer] = reward
        self.value_buffer[self.pointer] = value
        self.log_probability_buffer[self.pointer] = log_probability
        self.info_buffer[self.pointer] = info

        self.pointer = (self.pointer + 1) % self.max_size
        self.size = min(self.size + 1, self.max_size)

    def sample(self):
        self.pointer, self.trajectory_start_index = 0, 0
        advantage_mean = np.mean(self.advantage_buffer)
        advantage_std = np.std(self.advantage_buffer)
        self.advantage_buffer = (self.advantage_buffer - advantage_mean) / (
            advantage_std + 1e-10
        )  # avoid division by zero
        return dict(
            observations=self.observation_buffer,
            actions=self.action_buffer,
            advantages=self.advantage_buffer,
            returns=self.return_buffer,
            log_probabilities=self.log_probability_buffer,
            infos=self.info_buffer,
        )

    def clear(self):
        if self.compressed_observations:
            self.observation_buffer = np.zeros(self.max_size, dtype=np.object_)
            self.next_observation_buffer = np.zeros(self.max_size, dtype=np.object_)
        else:
            observation_buffer_shape = (self.max_size,) + self.observation_dimensions
            self.observation_buffer = np.zeros(
                observation_buffer_shape, self.observation_dtype
            )
            self.next_observation_buffer = np.zeros(
                observation_buffer_shape, dtype=self.observation_dtype
            )
        self.action_buffer = np.zeros(self.max_size, dtype=np.int8)
        self.reward_buffer = np.zeros(self.max_size, dtype=np.float16)
        self.advantage_buffer = np.zeros(self.max_size, dtype=np.float16)
        self.return_buffer = np.zeros(self.max_size, dtype=np.float16)
        self.value_buffer = np.zeros(self.max_size, dtype=np.float16)
        self.log_probability_buffer = np.zeros(self.max_size, dtype=np.float16)
        self.info_buffer = np.zeros(self.max_size, dtype=np.object_)

        self.pointer = 0
        self.trajectory_start_index = 0
        self.size = 0

    def finish_trajectory(self, last_value: float = 0):
        path_slice = slice(self.trajectory_start_index, self.pointer)
        rewards = np.append(self.reward_buffer[path_slice], last_value)
        values = np.append(self.value_buffer[path_slice], last_value)

        deltas = rewards[:-1] + self.gamma * values[1:] - values[:-1]

        self.advantage_buffer[path_slice] = discounted_cumulative_sums(
            deltas, self.gamma * self.gae_lambda
        )
        self.return_buffer[path_slice] = discounted_cumulative_sums(
            rewards, self.gamma
        )[:-1]
        # print(discounted_cumulative_sums(deltas, self.gamma * self.gae_lambda))
        # print(discounted_cumulative_sums(deltas, self.gamma * self.gae_lambda)[:-1])
        # print(self.advantage_buffer)

        self.trajectory_start_index = self.pointer

 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[2470:2779]
==rl-research.replay_buffers.prioritized_n_step_replay_buffer:[7:314]
class PrioritizedNStepReplayBuffer(NStepReplayBuffer):
    def __init__(
        self,
        observation_dimensions,
        observation_dtype: np.dtype,
        max_size: int,
        batch_size: int = 32,
        max_priority: float = 1.0,
        alpha: float = 0.6,
        beta: float = 0.4,
        # epsilon=0.01,
        n_step: float = 1,
        gamma: float = 0.99,
        compressed_observations: bool = False,
        num_players: int = 1,
    ):
        assert alpha >= 0 and alpha <= 1
        assert beta >= 0 and beta <= 1
        assert n_step >= 1
        assert gamma > 0 and gamma <= 1

        self.initial_max_priority = max_priority
        super(PrioritizedNStepReplayBuffer, self).__init__(
            observation_dimensions,
            observation_dtype,
            max_size,
            batch_size,
            n_step=n_step,
            gamma=gamma,
            compressed_observations=compressed_observations,
            num_players=num_players,
        )

        self.alpha = alpha  # Hyperparameter that we use to make a tradeoff between taking only exp with high priority and sampling randomly
        self.beta = beta
        # self.epsilon = epsilon

    def store(
        self,
        observation,
        info: dict,
        action,
        reward: float,
        next_observation,
        next_info: dict,
        done: bool,
        id=None,
        priority: float = None,
        player: int = 0,
    ):
        transition = super().store(
            observation,
            info,
            action,
            reward,
            next_observation,
            next_info,
            done,
            id,
            player=player,
        )

        if priority is None:
            priority = self.max_priority**self.alpha
            self.max_priority = max(
                self.max_priority, priority
            )  # could remove and clip priorities in experience replay isntead

        if transition:
            self.sum_tree[self.tree_pointer] = priority**self.alpha
            self.min_tree[self.tree_pointer] = priority**self.alpha
            self.tree_pointer = (self.tree_pointer + 1) % self.max_size

        return transition

    def set_beta(self, beta: float):
        self.beta = beta

    def store_batch(self, batch):
        (
            observations,
            infos,
            actions,
            rewards,
            next_observations,
            next_infos,
            dones,
            ids,
            priorities,
        ) = batch
        for i in range(len(observations)):
            self.store(
                observations[i],
                infos[i],
                actions[i],
                rewards[i],
                next_observations[i],
                next_infos[i],
                dones[i],
                ids[i],
                priorities[i],
            )

    def sample(self, throw_exception=True) -> dict:
        if len(self) < self.batch_size:
            if throw_exception:
                raise "Only {} elements in buffer expected at least {}".format(
                    len(self), self.batch_size
                )
            else:
                return None

        if self.alpha != 0.0:
            indices = self._sample_proportional()
        else:
            indices = np.random.choice(self.size, size=self.batch_size, replace=False)
            # print(indices)
        weights = np.array([self._calculate_weight(i) for i in indices])

        n_step_samples = self.sample_from_indices(indices)
        # print(n_step_samples)
        n_step_samples.update(dict(weights=weights, indices=indices))
        # print(n_step_samples)

        return n_step_samples

    def clear(self):
        super().clear()
        self.max_priority = self.initial_max_priority  # (initial) priority
        self.tree_pointer = 0

        tree_capacity = 1
        while tree_capacity < self.max_size:
            tree_capacity *= 2

        self.sum_tree = SumSegmentTree(tree_capacity)
        self.min_tree = MinSegmentTree(tree_capacity)

    def update_priorities(self, indices: list[int], priorities: list[float], ids=None):
        # necessary for shared replay buffer
        if ids is not None:
            assert len(priorities) == len(ids) == len(indices)
            assert priorities.shape == ids.shape == indices.shape

            for index, id, priority in zip(indices, ids, priorities):
                assert (
                    priority > 0
                ), "Negative priority: {} \n All priorities {}".format(
                    priority, priorities
                )
                assert 0 <= index < len(self)

                if self.id_buffer[index] != id:
                    continue

                self.sum_tree[index] = priority**self.alpha
                self.min_tree[index] = priority**self.alpha
                self.max_priority = max(self.max_priority, priority)
        else:
            assert len(indices) == len(priorities)
            for index, priority in zip(indices, priorities):
                assert priority > 0, "Negative priority: {}".format(priority)
                assert 0 <= index < len(self)

                self.sum_tree[index] = priority**self.alpha
                self.min_tree[index] = priority**self.alpha
                self.max_priority = max(
                    self.max_priority, priority
                )  # could remove and clip priorities in experience replay isntead

        return priorities**self.alpha

    def _sample_proportional(self):
        indices = []
        total_priority = self.sum_tree.sum(0, len(self) - 1)
        priority_segment = total_priority / self.batch_size

        for i in range(self.batch_size):
            a = priority_segment * i
            b = priority_segment * (i + 1)
            upperbound = np.random.uniform(a, b)
            index = self.sum_tree.retrieve(upperbound)
            indices.append(index)

        return indices

    def _calculate_weight(self, index: int):
        min_priority = self.min_tree.min() / self.sum_tree.sum()
        max_weight = (min_priority * len(self)) ** (-self.beta)
        priority_sample = self.sum_tree[index] / self.sum_tree.sum()
        weight = (priority_sample * len(self)) ** (-self.beta)
        weight = weight / max_weight

        return weight


class FastPrioritizedReplayBuffer(NStepReplayBuffer):
    def __init__(
        self,
        observation_dimensions,
        max_size: int,
        batch_size: int = 32,
        max_priority: float = 1.0,
        alpha: float = 0.6,
        beta: float = 0.4,
        # epsilon=0.01,
        n_step: int = 1,
        gamma: float = 0.99,
    ):
        assert alpha >= 0 and alpha <= 1
        assert beta >= 0 and beta <= 1
        assert n_step >= 1
        assert gamma > 0 and gamma <= 1

        super(FastPrioritizedReplayBuffer, self).__init__(
            observation_dimensions, max_size, batch_size, n_step=n_step, gamma=gamma
        )

        self.max_priority = max_priority  # (initial) priority
        self.min_priority = max_priority
        self.tree_pointer = 0

        self.alpha = alpha  # Hyperparameter that we use to make a tradeoff between taking only exp with high priority and sampling randomly
        self.beta = beta
        # self.epsilon = epsilon

        self.tree = FastSumTree(self.max_size)

    def store(
        self,
        observation,
        action,
        reward: float,
        next_observation,
        done: bool,
    ):
        transition = super().store(observation, action, reward, next_observation, done)

        # max_priority = np.max(self.tree.tree[-self.tree.capacity :])
        # if max_priority == 0:
        #     max_priority = self.max_priority

        if transition:
            self.tree.add(self.tree_pointer, self.max_priority)
            self.tree_pointer = (self.tree_pointer + 1) % self.max_size

        return transition

    def sample(self):
        assert len(self) >= self.batch_size

        priority_segment = self.tree.total_priority / self.batch_size
        indices, weights = np.empty((self.batch_size,), dtype=np.int32), np.empty(
            (self.batch_size, 1), dtype=np.float32
        )
        for i in range(self.batch_size):
            a, b = priority_segment * i, priority_segment * (i + 1)
            value = np.random.uniform(a, b)
            index, priority = self.tree.retrieve(value)
            sampling_probabilities = priority / self.tree.total_priority
            # weights[i, 0] = (self.batch_size * sampling_probabilities) ** -beta
            weights[i, 0] = (len(self) * sampling_probabilities) ** -self.beta
            indices[i] = index - self.tree.capacity + 1
            indices[i] = index - self.tree.capacity + 1

        # max_weight = max(weights)
        max_weight = (
            len(self) * self.min_priority / self.tree.total_priority
        ) ** -self.beta
        weights = weights / max_weight

        # print(weights)
        # print("Getting Indices from PrioritizedReplayBuffer Sum Tree Time ", time() - time1)
        # print("Retrieving Data from PrioritizedReplayBuffer Data Arrays")
        # time2 = 0
        # time2 = time()
        observations = self.observation_buffer[indices]
        next_observations = self.next_observation_buffer[indices]
        actions = self.action_buffer[indices]
        rewards = self.reward_buffer[indices]
        dones = self.done_buffer[indices]
        # weights = np.array([self._calculate_weight(i, beta) for i in indices])
        # print("Retrieving Data from PrioritizedReplayBuffer Data Arrays Time ", time() - time2)

        # print("Sampling from PrioritizedReplayBuffer Time ", time() - time1)
        return dict(
            observations=observations,
            next_observations=next_observations,
            actions=actions,
            rewards=rewards,
            dones=dones,
            weights=weights,
            indices=indices,
        )

    def update_priorities(self, indices: list[int], priorities: list[float]):
        assert len(indices) == len(priorities)
        # priorities += self.epsilon

        for index, priority in zip(indices, priorities):
            assert priority > 0, "Negative priority: {}".format(priority)
            # assert 0 <= index < len(self)
            # self.tree[index] = priority ** self.alpha
            self.max_priority = max(self.max_priority, priority**self.alpha)
            self.min_priority = min(self.min_priority, priority**self.alpha)
            # priority = np.clip(priority, self.epsilon, self.max_priority)
            self.tree.update(index + self.tree.capacity - 1, priority**self.alpha)

 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[929:1227]
==utils.utils.utils:[907:1205]
Loss = Callable[[torch.Tensor, torch.Tensor], torch.Tensor]


def calculate_padding(i: int, k: int, s: int) -> Tuple[int, int]:
    """Calculate both padding sizes along 1 dimension for a given input length, kernel length, and stride

    Args:
        i (int): input length
        k (int): kernel length
        s (int): stride

    Returns:
        (p_1, p_2): where p_1 = p_2 - 1 for uneven padding and p_1 == p_2 for even padding
    """

    p = (i - 1) * s - i + k
    p_1 = p // 2
    p_2 = (p + 1) // 2
    return (p_1, p_2)


def generate_layer_widths(widths: list[int], max_num_layers: int) -> list[Tuple[int]]:
    """Create all possible combinations of widths for a given number of layers"""
    width_combinations = []

    for i in range(0, max_num_layers):
        width_combinations.extend(itertools.combinations_with_replacement(widths, i))

    return width_combinations


def hyperopt_analysis(
    data_dir: str,
    file_name: str,
    viable_trial_threshold: int,
    step: int,
    final_trial: int = 0,
    eval_method: str = "final_score",
):
    trials = pickle.load(open(f"{data_dir}/{file_name}.p", "rb"))
    if final_trial > 0:
        print("Number of trials: {}".format(final_trial))
    else:
        print("Number of trials: {}".format(len(trials.trials)))
    # losses.sort()
    # print(len(os.listdir(f"{data_dir}/checkpoints")) - 1)
    # print(len(trials.trials))

    checkpoints = os.listdir(f"{data_dir}/checkpoints")
    checkpoints.remove("videos") if "videos" in checkpoints else None
    checkpoints.remove(".DS_Store") if ".DS_Store" in checkpoints else None
    checkpoints.sort(key=lambda x: int(x.split("_")[-1]))
    if final_trial > 0:
        checkpoints = checkpoints[:final_trial]

    viable_throughout_trials = []
    final_rolling_averages = []
    final_std_devs = []
    scores = []
    losses = []
    failed_trials = 0
    for i, trial in enumerate(trials.trials):
        losses.append(trial["result"]["loss"])
        if final_trial > 0 and i >= final_trial:
            break
        # print(trial["result"]["status"])
        if trial["result"]["status"] == "fail":
            failed_trials += 1
            final_rolling_averages.append(trial["result"]["loss"])
            scores.append(trial["result"]["loss"])
            final_std_devs.append(trial["result"]["loss"])
        else:
            # print(checkpoints[i - failed_trials])
            # print(failed_trials)
            # if os.path.exists(
            #     f"{data_dir}/checkpoints/{checkpoints[i - failed_trials]}/step_{step}/graphs_stats/stats.pkl"
            # ):
            stats = pickle.load(
                open(
                    f"{data_dir}/checkpoints/{checkpoints[i - failed_trials]}/step_{step}/graphs_stats/stats.pkl",
                    "rb",
                )
            )
            max_score = 0

            # print([stat_dict["score"] for stat_dict in stats["test_score"][-5:]])
            final_rolling_averages.append(
                np.around(
                    np.mean(
                        [stat_dict["score"] for stat_dict in stats["test_score"][-5:]]
                    ),
                    1,
                )
            )

            final_std_devs.append(
                np.around(
                    np.std(
                        [stat_dict["score"] for stat_dict in stats["test_score"][-5:]]
                    ),
                    1,
                )
            )

            for stat_dict in stats["test_score"]:
                if stat_dict["max_score"] > max_score:
                    max_score = stat_dict["max_score"]

            if max_score > viable_trial_threshold:
                viable_throughout_trials.append(max_score)

            if eval_method == "final_score":
                score = -trial["result"]["loss"]
            elif (
                eval_method == "rolling_average"
                or eval_method == "final_score_rolling_average"
            ):
                score = stats["test_score"][-1]["score"]
            scores.append(score)

    plot_trials(
        scores,
        file_name,
        final_trial=final_trial,
    )

    res = [
        list(x)
        for x in zip(
            *sorted(
                zip(losses, scores, final_rolling_averages, final_std_devs),
                key=itemgetter(0),
            )
        )
    ]
    losses = res[0]
    scores = res[1]
    final_rolling_averages = res[2]
    final_std_devs = res[3]
    viable_trials = [score for score in scores if score > viable_trial_threshold]

    print("Failed trials: ~{}%".format(round(failed_trials / len(scores) * 100)))

    print(
        "Viable trials (based on final score): ~{}%".format(
            round(len(viable_trials) / len(scores) * 100)
        )
    )
    print(
        "Viable trials (throughout training): ~{}%".format(
            round(len(viable_throughout_trials) / len(scores) * 100)
        )
    )

    print("Losses: {}".format(losses))
    print("Scores: {}".format(scores))
    print("Final rolling averages: {}".format(final_rolling_averages))
    print("Final standard deviations: {}".format(final_std_devs))

    print("Max loss: {}".format(max(losses)))
    print("Max score: {}".format(max(scores)))
    print("Max final rolling average: {}".format(max(final_rolling_averages)))
    print("Max final standard deviation: {}".format(max(final_std_devs)))

    print("Average loss: {}".format(np.mean(losses)))
    print("Average score: {}".format(np.mean(scores)))
    print("Average final rolling average: {}".format(np.mean(final_rolling_averages)))
    print("Average final standard deviation: {}".format(np.mean(final_std_devs)))

    viable_final_rolling_averages = [
        final_rolling_averages[i]
        for i, loss in enumerate(scores)
        if loss > viable_trial_threshold
    ]

    viable_std_devs = [
        final_std_devs[i]
        for i, loss in enumerate(scores)
        if loss > viable_trial_threshold
    ]

    print(
        "Average score of viable trials (based on final score): {}".format(
            np.mean(viable_trials)
        )
    )
    print(
        "Average final rolling average of viable trials (based on final score): {}".format(
            np.mean(viable_final_rolling_averages)
        )
    )
    print(
        "Average final standard deviation of viable trials (based on final score): {}".format(
            np.mean(viable_std_devs)
        )
    )


def graph_hyperparameter_importance(
    data_dir: str, trials_file: str, search_space_file: str, viable_trial_threshold: int
):
    with open(f"{data_dir}/{trials_file}", "rb") as f:
        trials = pickle.load(f)
    print(trials)

    search_space = pickle.load(open(f"./search_spaces/{search_space_file}", "rb"))

    values_dict = defaultdict(list)
    scores = []
    for trial in trials.trials:
        for key, value in space_eval(trial["misc"]["vals"], search_space).items():
            values_dict[key].append(value[0])
        scores.append(-trial["result"]["loss"])

    df = pd.DataFrame(values_dict)
    x_cols = df.columns
    df["scores"] = scores
    # print(df)
    df = df[df["scores"] > viable_trial_threshold]

    for col in x_cols:
        if col == "loss_function":
            continue
        plt = df.plot(x=col, y="scores", kind="scatter")
        grouped = df.groupby(col)["scores"]
        medians = grouped.median()
        means = grouped.mean()
        stddev = grouped.std()

        if not (col == "kernel_initializer" or col == "activation"):
            # plt.fill_between(medians.index, medians.values-stddev, medians.values+stddev, color="#00F0F0")
            plt.plot(means.index, means.values, color="#00FFFF")
        else:
            plt.scatter(means.index, means.values, c="#00FFFF")
        # plt.add_line


def calc_units(shape):
    shape = tuple(shape)
    if len(shape) == 1:
        return shape + shape
    if len(shape) == 2:
        # dense layer -> (in_channels, out_channels)
        return shape
    else:
        # conv_layer (Assuming convolution kernels (2D, 3D, or more).
        # kernel shape: (input_depth, depth, ...)
        in_units = shape[1]
        out_units = shape[0]
        c = 1
        for dim in shape[2:]:
            c *= dim
        return (c * in_units, c * out_units)


class VarianceScaling:
    def __init__(self, scale=0.1, mode="fan_in", distribution="uniform"):
        self.scale = scale
        self.mode = mode
        self.distribution = distribution

        assert mode == "fan_in" or mode == "fan_out" or mode == "fan_avg"
        assert distribution == "uniform", "only uniform distribution is supported"

    def __call__(self, tensor: Tensor) -> None:
        with torch.no_grad():
            scale = self.scale
            shape = tensor.shape
            in_units, out_units = calc_units(shape)
            if self.mode == "fan_in":
                scale /= in_units
            elif self.mode == "fan_out":
                scale /= out_units
            else:
                scale /= (in_units + out_units) / 2

            limit = math.sqrt(3.0 * scale)
            return tensor.uniform_(-limit, limit)


def isiterable(o):
    try:
        it = iter(o)
    except TypeError:
        return False
    return True


def tointlists(list):
    ret = []
    for x in list:
        if isiterable(x):
            ret.append(tointlists(x))
        else:
            ret.append(int(x))
    return ret

 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[3249:3499]
==rainbow.rainbow_network:[19:267]
    ):
        super().__init__(*args, **kwargs)
        self.config = config
        self.has_residual_layers = len(config.residual_layers) > 0
        self.has_conv_layers = len(config.conv_layers) > 0
        self.has_dense_layers = len(config.dense_layer_widths) > 0
        assert (
            self.has_conv_layers or self.has_dense_layers or self.has_residual_layers
        ), "At least one of the layers should be present."

        self.has_value_hidden_layers = len(config.value_hidden_layer_widths) > 0
        self.has_advantage_hidden_layers = len(config.advantage_hidden_layer_widths) > 0
        if not self.config.dueling:
            assert not (
                self.has_value_hidden_layers or self.has_advantage_hidden_layers
            ), "Value or Advantage hidden layers are only used in dueling networks"

        self.output_size = output_size

        current_shape = input_shape
        B = current_shape[0]

        if self.has_residual_layers:
            assert (
                len(input_shape) == 4
            ), "Input shape should be (B, C, H, W), got {}".format(input_shape)
            filters, kernel_sizes, strides = to_lists(config.residual_layers)

            # (B, C_in, H, W) -> (B, C_out H, W)
            self.residual_layers = ResidualStack(
                input_shape=input_shape,
                filters=filters,
                kernel_sizes=kernel_sizes,
                strides=strides,
                activation=self.config.activation,
                noisy_sigma=config.noisy_sigma,
            )
            current_shape = (
                B,
                self.residual_layers.output_channels,
                current_shape[2],
                current_shape[3],
            )

        if self.has_conv_layers:
            assert (
                len(input_shape) == 4
            ), "Input shape should be (B, C, H, W), got {}".format(input_shape)
            filters, kernel_sizes, strides = to_lists(config.conv_layers)

            # (B, C_in, H, W) -> (B, C_out H, W)
            self.conv_layers = Conv2dStack(
                input_shape=input_shape,
                filters=filters,
                kernel_sizes=kernel_sizes,
                strides=strides,
                activation=self.config.activation,
                noisy_sigma=config.noisy_sigma,
            )
            current_shape = (
                B,
                self.conv_layers.output_channels,
                current_shape[2],
                current_shape[3],
            )

        if self.has_dense_layers:
            if len(current_shape) == 4:
                initial_width = current_shape[1] * current_shape[2] * current_shape[3]
            else:
                assert len(current_shape) == 2
                initial_width = current_shape[1]

            # (B, width_in) -> (B, width_out)
            self.dense_layers = DenseStack(
                initial_width=initial_width,
                widths=self.config.dense_layer_widths,
                activation=self.config.activation,
                noisy_sigma=self.config.noisy_sigma,
            )
            current_shape = (
                B,
                self.dense_layers.output_width,
            )

        if len(current_shape) == 4:
            initial_width = current_shape[1] * current_shape[2] * current_shape[3]
        else:
            assert (
                len(current_shape) == 2
            ), "Input shape should be (B, width), got {}".format(current_shape)
            initial_width = current_shape[1]

        if self.config.dueling:
            if self.has_value_hidden_layers:
                # (B, width_in) -> (B, value_in_features) -> (B, atom_size)
                self.value_hidden_layers = DenseStack(
                    initial_width=initial_width,
                    widths=self.config.value_hidden_layer_widths,
                    activation=self.config.activation,
                    noisy_sigma=self.config.noisy_sigma,
                )
                value_in_features = self.value_hidden_layers.output_width
            else:
                value_in_features = initial_width
            # (B, value_in_features) -> (B, atom_size)
            self.value_layer = build_dense(
                in_features=value_in_features,
                out_features=config.atom_size,
                sigma=config.noisy_sigma,
            )

            if self.has_advantage_hidden_layers:
                # (B, width_in) -> (B, advantage_in_features)
                self.advantage_hidden_layers = DenseStack(
                    initial_width=initial_width,
                    widths=self.config.advantage_hidden_layer_widths,
                    activation=self.config.activation,
                    noisy_sigma=self.config.noisy_sigma,
                )
                advantage_in_features = self.advantage_hidden_layers.output_width
            else:
                advantage_in_features = initial_width
            # (B, advantage_in_features) -> (B, output_size * atom_size)
            self.advantage_layer = build_dense(
                in_features=advantage_in_features,
                out_features=output_size * config.atom_size,
                sigma=self.config.noisy_sigma,
            )
        else:
            self.distribution_layer = build_dense(
                in_features=initial_width,
                out_features=self.output_size * self.config.atom_size,
                sigma=self.config.noisy_sigma,
            )

    def initialize(self, initializer: Callable[[Tensor], None]) -> None:
        if self.has_residual_layers:
            self.residual_layers.initialize(initializer)
        if self.has_conv_layers:
            self.conv_layers.initialize(initializer)
        if self.has_dense_layers:
            self.dense_layers.initialize(initializer)
        if self.has_value_hidden_layers:
            self.value_hidden_layers.initialize(initializer)
        if self.has_advantage_hidden_layers:
            self.advantage_hidden_layers.initialize(initializer)
        if self.config.dueling:
            self.value_layer.initialize(initializer)
            self.advantage_layer.initialize(initializer)

    def forward(self, inputs: Tensor) -> Tensor:
        if self.has_conv_layers:
            assert inputs.dim() == 4

        # (B, *)
        S = inputs
        # (B, C_in, H, W) -> (B, C_out, H, W)
        if self.has_residual_layers:
            S = self.residual_layers(S)

        # (B, C_in, H, W) -> (B, C_out, H, W)
        if self.has_conv_layers:
            S = self.conv_layers(S)

        # (B, *) -> (B, dense_features_in)
        S = S.flatten(1, -1)

        # (B, dense_features_in) -> (B, dense_features_out)
        if self.has_dense_layers:
            S = self.dense_layers(S)

        if self.config.dueling:
            # (B, value_hidden_in) -> (B, value_hidden_out)
            if self.has_value_hidden_layers:
                v = self.value_hidden_layers(S)
            else:
                v = S

            # (B, value_hidden_in || dense_features_out) -> (B, atom_size) -> (B, 1, atom_size)
            v: Tensor = self.value_layer(v).view(-1, 1, self.config.atom_size)

            # (B, adv_hidden_in) -> (B, adv_hidden_out)
            if self.has_advantage_hidden_layers:
                A = self.advantage_hidden_layers(S)
            else:
                A = S

            # (B, adv_hidden_out || dense_features_out) -> (B, output_size * atom_size) -> (B, output_size, atom_size)
            A: Tensor = self.advantage_layer(A).view(
                -1, self.output_size, self.config.atom_size
            )

            # (B, output_size, atom_size) -[mean(1)]-> (B, 1, atom_size)
            a_mean = A.mean(1, keepdim=True)

            # (B, 1, atom_size) +
            # (B, output_size, atom_size) +
            # (B, 1, atom_size)
            # is valid broadcasting operation
            Q = v + A - a_mean

            # -[softmax(2)]-> turns the atom dimension into a valid p.d.f.
            # ONLY CLIP FOR CATEGORICAL CROSS ENTROPY LOSS TO PREVENT NAN
            # MIGHT BE ABLE TO REMOVE CLIPPING ENTIRELY SINCE I DONT THINK THE TENSORFLOW LOSSES CAN RETURN NaN
            # q.clip(1e-3, 1)
        else:
            # (B, dense_features_out) -> (B, output_size, atom_size)
            Q = self.distribution_layer(S).view(
                -1, self.output_size, self.config.atom_size
            )

        if self.config.atom_size == 1:
            return Q.squeeze(-1)
        else:
            return Q.softmax(dim=-1)

    def reset_noise(self):
        if self.config.noisy_sigma != 0:
            if self.has_residual_layers:
                self.residual_layers.reset_noise()
            if self.has_conv_layers:
                self.conv_layers.reset_noise()
            if self.has_dense_layers:
                self.dense_layers.reset_noise()
            if self.has_value_hidden_layers:
                self.value_hidden_layers.reset_noise()
            if self.has_advantage_hidden_layers:
                self.advantage_hidden_layers.reset_noise()
            if self.config.dueling:
                self.value_layer.reset_noise()
                self.advantage_layer.reset_noise()

    def remove_noise(self):
        if self.config.noisy_sigma != 0:
            if self.has_residual_layers:
                self.residual_layers.remove_noise()
            if self.has_conv_layers:
                self.conv_layers.remove_noise()
            if self.has_dense_layers:
                self.dense_layers.remove_noise()
            if self.has_value_hidden_layers:
                self.value_hidden_layers.remove_noise()
            if self.has_advantage_hidden_layers:
                self.advantage_hidden_layers.remove_noise()
            if self.config.dueling:
                self.value_layer.remove_noise()
                self.advantage_layer.remove_noise() (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==dense:[6:184]
==pacman:[2912:3091]
class Dense(nn.Module):
    def __init__(
        self, in_features: int, out_features: int, bias: bool = True, *args, **kwargs
    ):
        super(Dense, self).__init__(*args, **kwargs)
        self.layer = nn.Linear(
            in_features=in_features, out_features=out_features, bias=bias
        )

    def initialize(self, initializer: Callable[[Tensor], None]) -> None:
        initializer(self.layer.weight)

    def forward(self, inputs: Tensor) -> Tensor:
        return self.layer(inputs)

    def extra_repr(self) -> str:
        return self.layer.extra_repr()


class NoisyDense(nn.Module):
    """See https://arxiv.org/pdf/1706.10295."""

    @staticmethod
    def f(x: Tensor):
        return x.sgn() * (x.abs().sqrt())

    def __init__(
        self,
        in_features: int,
        out_features: int,
        bias: bool = True,
        initial_sigma: float = 0.5,
        use_factorized: bool = True,
    ):
        super().__init__()
        self.in_features = in_features
        self.out_features = out_features
        self.initial_sigma = initial_sigma
        self.use_factorized = use_factorized
        self.use_bias = bias

        self.mu_w = nn.Parameter(torch.empty(out_features, in_features))
        self.sigma_w = nn.Parameter(torch.empty(out_features, in_features))
        self.eps_w = self.register_buffer(
            "eps_w", torch.empty(out_features, in_features)
        )
        if self.use_bias:
            self.mu_b = nn.Parameter(torch.empty(out_features))
            self.sigma_b = nn.Parameter(torch.empty(out_features))
            self.eps_b = self.register_buffer("eps_b", torch.empty(out_features))
        else:
            self.register_parameter("mu_b", None)
            self.register_parameter("sigma_b", None)
            self.eps_b = self.register_buffer("eps_b", None)

        self.reset_parameters()
        self.reset_noise()

    def reset_noise(self) -> None:
        if self.use_factorized:
            eps_i = torch.randn(1, self.in_features).to(self.mu_w.device)
            eps_j = torch.randn(self.out_features, 1).to(self.mu_w.device)
            self.eps_w = self.f(eps_j) @ self.f(eps_i)
            self.eps_b = self.f(eps_j).reshape(self.out_features)
        else:
            self.eps_w = self.f(torch.randn(self.mu_w.shape)).to(self.mu_w.device)
            if self.use_bias:
                self.eps_b = self.f(torch.randn(size=self.mu_b.shape)).to(
                    self.mu_w.device
                )

    def remove_noise(self) -> None:
        self.eps_w = torch.zeros_like(self.mu_w).to(self.mu_w.device)
        if self.use_bias:
            self.eps_b = torch.zeros_like(self.mu_b).to(self.mu_w.device)

    def reset_parameters(self) -> None:
        p = self.in_features
        if self.use_factorized:
            mu_init = 1.0 / (p**0.5)
            sigma_init = self.initial_sigma / (p**0.5)
        else:
            mu_init = (3.0 / p) ** 0.5
            sigma_init = 0.017

        nn.init.constant_(self.sigma_w, sigma_init)
        nn.init.uniform_(self.mu_w, -mu_init, mu_init)
        if self.use_bias:
            nn.init.constant_(self.sigma_b, sigma_init)
            nn.init.uniform_(self.mu_b, -mu_init, mu_init)

    @property
    def weight(self):
        return self.mu_w + self.sigma_w * self.eps_w

    @property
    def bias(self):
        if self.use_bias:
            return self.mu_b + self.sigma_b * self.eps_b
        else:
            return None

    def initialize(self, initializer: Callable[[Tensor], None]) -> None:
        pass

    def forward(self, input: Tensor) -> Tensor:
        return functional.F.linear(input, self.weight, self.bias)

    def extra_repr(self) -> str:
        return f"in_features={self.in_features}, out_features={self.out_features}, bias={self.bias is not None}, initial_sigma={self.initial_sigma}, use_factorized={self.use_factorized}"


def build_dense(in_features: int, out_features: int, sigma: float = 0):
    if sigma == 0:
        return Dense(in_features, out_features)
    else:
        return NoisyDense(in_features, out_features)


class DenseStack(nn.Module):
    def __init__(
        self,
        initial_width: int,
        widths: list[int],
        activation: nn.Module = nn.ReLU(),
        noisy_sigma: float = 0,
    ):
        super(DenseStack, self).__init__()
        self.dense_layers: nn.ModuleList = nn.ModuleList()
        self.activation = activation

        assert len(widths) > 0
        self.noisy = noisy_sigma != 0

        current_input_width = initial_width
        for i in range(len(widths)):
            layer = build_dense(
                in_features=current_input_width,
                out_features=widths[i],
                sigma=noisy_sigma,
            )
            self.dense_layers.append(layer)
            current_input_width = widths[i]

        self.initial_width = initial_width
        self._output_len = current_input_width

    def initialize(self, initializer: Callable[[Tensor], None]) -> None:
        for layer in self.dense_layers:
            layer.initialize(initializer)

    def forward(self, inputs: Tensor) -> Tensor:
        x = inputs
        for layer in self.dense_layers:
            x = self.activation(layer(x))
        return x

    def reset_noise(self) -> None:
        assert self.noisy

        for layer in self.dense_layers:
            layer.reset_noise()
        return

    def remove_noise(self) -> None:
        assert self.noisy

        for layer in self.dense_layers:
            layer.remove_noise()
        return

    def extra_repr(self) -> str:
        return f"in_features={self.initial_width}, out_width={self.output_width}, noisy={self.noisy}"

    @property
    def output_width(self):
        return self._output_len

 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[3091:3241]
==residual:[6:154]
class ResidualStack(nn.Module):
    def __init__(
        self,
        input_shape: tuple[int],
        filters: list[int],
        kernel_sizes: list[int | Tuple[int, int]],
        strides: list[int | Tuple[int, int]],
        activation: nn.Module = nn.ReLU(),
        noisy_sigma: float = 0,
    ):
        """A sequence of residual layers with the activation function applied after each layer.
        Always applies the minimum zero-padding that ensures the output shape is equal to the input shape.
        Input shape in "BCHW" form, i.e. (batch_size, input_channels, height, width)
        """
        super(ResidualStack, self).__init__()
        self.residual_layers = nn.ModuleList()

        self.activation = activation

        # [B, C_in, H, W]
        assert (
            len(input_shape) == 4
            and len(filters) == len(kernel_sizes) == len(strides)
            and len(filters) > 0
        )

        self.noisy = noisy_sigma != 0
        if self.noisy:
            print("warning: Noisy convolutions not implemented yet")
            # raise NotImplementedError("")

        current_input_channels = input_shape[1]

        for i in range(len(filters)):
            print(current_input_channels)
            layer = Residual(
                in_channels=current_input_channels,
                out_channels=filters[i],
                kernel_size=kernel_sizes[i],
                stride=strides[i],
            )
            self.residual_layers.append(layer)
            current_input_channels = filters[i]

        self._output_len = current_input_channels

    def initialize(self, initializer: Callable[[Tensor], None]) -> None:
        def initialize_if_conv(m: nn.Module):
            if isinstance(m, nn.Conv2d):
                initializer(m.weight)

        self.apply(initialize_if_conv)

    def forward(self, inputs):
        x = inputs
        for layer in self.residual_layers:
            x = self.activation(layer(x))
        return x

    def reset_noise(self):
        assert self.noisy

        # noisy not implemented

        # for layer in self.conv_layers:
        #     # layer.reset_noise()
        # return

    def remove_noise(self):
        assert self.noisy

        # noisy not implemented

        # for layer in self.conv_layers:
        #     # layer.reset_noise()
        # return

    @property
    def output_channels(self):
        return self._output_len


class Residual(nn.Module):
    def __init__(
        self,
        in_channels,
        out_channels,
        kernel_size,
        stride,
    ):
        super(Residual, self).__init__()
        self.conv1 = nn.Conv2d(
            in_channels=in_channels,
            out_channels=out_channels,
            kernel_size=kernel_size,
            stride=stride,
            padding="same",
        )

        # REGULARIZATION?
        self.bn1 = nn.BatchNorm2d(
            num_features=out_channels,
        )

        self.conv2 = nn.Conv2d(
            in_channels=out_channels,
            out_channels=out_channels,
            kernel_size=kernel_size,
            stride=stride,
            padding="same",
        )

        # REGULARIZATION?
        self.bn2 = nn.BatchNorm2d(
            num_features=out_channels,
        )

        self.relu = nn.ReLU()
        self.downsample = None
        if in_channels != out_channels:
            self.downsample = nn.Sequential(
                nn.Conv2d(
                    in_channels=in_channels,
                    out_channels=out_channels,
                    kernel_size=kernel_size,
                    padding="same",
                    bias=False,
                ),
                nn.BatchNorm2d(out_channels),
            )

    def initialize(self, initializer: Callable[[Tensor], None]) -> None:
        def initialize_if_conv(m: nn.Module):
            if isinstance(m, nn.Conv2d):
                initializer(m.weight)

        self.apply(initialize_if_conv)

    def forward(self, inputs):
        residual = self.downsample(inputs) if self.downsample else inputs

        x = self.conv1(inputs)
        x = self.bn1(x)
        x = self.relu(x)
        x = self.conv2(x)
        x = self.bn2(x)
        x = self.relu(x + residual)
        return x (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==ape_x.hyperopt_local:[138:261]
==ape_x.hyperparameter_optimization:[140:263]
        logger.info("cleaning up finished")


def objective(params):
    logger.info(f"Params: {params}")
    logger.info("Making environments")
    environments_list = [
        gym.make("CartPole-v1", render_mode="rgb_array"),
        # gym.make("Acrobot-v1", render_mode="rgb_array"),
        # gym.make("MountainCar-v0", render_mode="rgb_array"),
    ]

    if os.path.exists("./classiccontrol_trials.p"):
        trials = pickle.load(open("./classiccontrol_trials.p", "rb"))
        name = "classiccontrol_{}".format(len(trials.trials) + 1)
    else:
        name = "classiccontrol_1"
    # name = datetime.datetime.now().timestamp()
    params["model_name"] = name
    entry = pd.DataFrame.from_dict(
        params,
        orient="index",
    ).T

    entry.to_csv(
        "classiccontrol_results.csv",
        mode="a",
        header=False,
    )

    status = STATUS_OK
    try:
        # add other illegal hyperparameter combinations here
        assert params["min_replay_buffer_size"] >= params["minibatch_size"]
        assert params["replay_buffer_size"] > params["min_replay_buffer_size"]
    except AssertionError as e:
        status = STATUS_FAIL
        logger.info(f"exited due to invalid hyperparameter combination: {e}")
        return {"status": status, "loss": 0}

    if status != STATUS_FAIL:
        loss_list = list()
        for env in environments_list:
            res_dict = run_training(params, env, name)
            if res_dict["status"] == STATUS_FAIL:
                return res_dict
            else:
                loss_list.append(res_dict["loss"])

    print("training done with loss {} and status {}".format(np.sum(loss_list), status))
    return {"loss": np.sum(loss_list), "status": status}


from hyperopt.pyll.base import scope
import math


def create_search_space():
    search_space = {
        # "activation": hp.choice("activation", ["relu"]),
        "kernel_initializer": hp.choice(
            "kernel_initializer",
            [
                "pytorch_default",
                "he_uniform",
                "he_normal",
                "glorot_uniform",
                "glorot_normal",
                "orthogonal",
                "variance_baseline",
                "variance_0.1",
                "variance_0.3",
                "variance_0.8",
                "variance_3",
                "variance_5",
                "variance_10",
                # "lecun_uniform",
                # "lecun_normal",
            ],
        ),
        #### not actually used in apex, just to prevent the configs from throwing errors
        "loss_function": hp.choice(
            "loss_function",
            [utils.CategoricalCrossentropyLoss()],#, utils.KLDivergenceLoss()],
        ),
        ###
        "learning_rate": hp.loguniform("learning_rate", math.log(1e-5), math.log(1e-1)),
        "adam_epsilon": hp.loguniform("adam_epsilon", math.log(1e-9), math.log(1e-6)),
        "clipnorm": hp.loguniform("clipnorm", math.log(0.1), math.log(1000)),
        "transfer_interval": scope.int(hp.quniform("transfer_interval", 20, 1000, 20)),
        "minibatch_size": scope.int(
            hp.loguniform("minibatch_size", math.log(2**3), math.log(2**10))
        ),
        "replay_buffer_size": scope.int(
            hp.loguniform("replay_buffer_size", math.log(1e5), math.log(1e7))
        ),
        "actor_buffer_size": scope.int(hp.quniform("actor_buffer_size", 100, 1000, 25)),
        "min_replay_buffer_size": scope.int(
            hp.quniform("min_replay_buffer_size", 100, 2000, 100)
        ),
        "n_step": scope.int(hp.quniform("n_step", 3, 10, 1)),
        "discount_factor": hp.loguniform(
            "discount_factor", math.log(0.9), math.log(0.999)
        ),
        "atom_size": hp.choice("atom_size", [41, 51, 61, 71, 81]),
        "dense_layers_widths": hp.choice(
            "dense_layers_widths", [[32], [64], [128], [256], [512], [1024]]
        ),
        "advantage_hidden_layers_widths": hp.choice(
            "advantage_hidden_layers_widths", [[32], [64], [128], [256], [512], [1024]]
        ),
        "value_hidden_layers_widths": hp.choice(
            "value_hidden_layers_widths", [[32], [64], [128], [256], [512], [1024]]
        ),
        "per_epsilon": hp.loguniform("per_epsilon", math.log(1e-8), math.log(1e-1)),
        "per_alpha": hp.quniform("per_alpha", 0.05, 1, 0.05),
        "per_beta": hp.quniform("per_beta", 0.05, 1, 0.05),
        "push_params_interval": scope.int(hp.quniform("push_params_interval", 2, 12, 1)),
        "updates_queue_size": scope.int(hp.quniform("updates_queue_size", 2, 12, 1)),
        "samples_queue_size": scope.int(hp.quniform("samples_queue_size", 2, 12, 1)),
        "poll_params_interval": scope.int(
            hp.quniform("poll_params_interval", 50, 500, 10)
        ), (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[3664:3806]
==rainbow.rainbow_agent:[202:344]
                self.config.loss_function, CategoricalCrossentropyLoss
            ), "Only KLDivergenceLoss and CategoricalCrossentropyLoss are supported for atom_size > 1, recieved {}".format(
                self.config.loss_function
            )
            target_predictions = self.compute_target_distributions(samples)
        else:
            # print("using default dqn loss")
            assert isinstance(self.config.loss_function, HuberLoss) or isinstance(
                self.config.loss_function, MSELoss
            ), "Only HuberLoss or MSELoss are supported for atom_size = 1, recieved {}".format(
                self.config.loss_function
            )
            next_observations, rewards, dones = (
                torch.from_numpy(samples["next_observations"]).to(self.device),
                torch.from_numpy(samples["rewards"]).to(self.device),
                torch.from_numpy(samples["dones"]).to(self.device),
            )
            next_infos = samples["next_infos"]
            target_predictions = self.predict_target(next_observations)  # next q values
            # print("Next q values", target_predictions)
            # print("Current q values", online_predictions)
            # print(self.predict(next_observations))
            next_actions = self.select_actions(
                self.predict(next_observations),  # current q values
                info=next_infos,
                mask_actions=self.config.game.has_legal_moves,
            )
            # print("Next actions", next_actions)
            target_predictions = target_predictions[
                range(self.config.minibatch_size), next_actions
            ]  # this might not work
            # print(target_predictions)
            target_predictions = (
                rewards + self.config.discount_factor * (~dones) * target_predictions
            )
            # print(target_predictions)

        # print("predicted", online_distributions)
        # print("target", target_distributions)

        weights_cuda = torch.from_numpy(weights).to(torch.float32).to(self.device)
        # (B)
        elementwise_loss = self.config.loss_function(
            online_predictions, target_predictions
        )
        # print("Loss", elementwise_loss.mean())
        assert torch.all(elementwise_loss) >= 0, "Elementwise Loss: {}".format(
            elementwise_loss
        )
        assert (
            elementwise_loss.shape == weights_cuda.shape
        ), "Loss Shape: {}, Weights Shape: {}".format(
            elementwise_loss.shape, weights_cuda.shape
        )
        loss = elementwise_loss * weights_cuda
        self.optimizer.zero_grad()
        loss.mean().backward()
        if self.config.clipnorm > 0:
            # print("clipnorm", self.config.clipnorm)
            clip_grad_norm_(self.model.parameters(), self.config.clipnorm)

        self.optimizer.step()
        self.update_replay_priorities(
            samples=samples,
            priorities=elementwise_loss.detach().to("cpu").numpy()
            + self.config.per_epsilon,
        )
        self.model.reset_noise()
        self.target_model.reset_noise()
        return loss.detach().to("cpu").mean().item()

    def update_replay_priorities(self, samples, priorities):
        self.replay_buffer.update_priorities(samples["indices"], priorities)

    def compute_target_distributions(self, samples):
        # print("computing target distributions")
        with torch.no_grad():
            discount_factor = self.config.discount_factor**self.config.n_step
            delta_z = (self.config.v_max - self.config.v_min) / (
                self.config.atom_size - 1
            )
            next_observations, rewards, dones = (
                samples["next_observations"],
                torch.from_numpy(samples["rewards"]).to(self.device).view(-1, 1),
                torch.from_numpy(samples["dones"]).to(self.device).view(-1, 1),
            )
            online_distributions = self.predict(next_observations)
            target_distributions = self.predict_target(next_observations)

            # print(samples["next_infos"])
            next_actions = self.select_actions(
                online_distributions,
                info=samples["next_infos"],
                mask_actions=self.config.game.has_legal_moves,
            )  # {} is the info but we are not doing action masking yet
            # (B, outputs, atom_size) -[index by [0..B-1, a_0..a_B-1]]> (B, atom_size)
            probabilities = target_distributions[
                range(self.config.minibatch_size), next_actions
            ]
            # print(probabilities)

            # (B, 1) + k(B, atom_size) * (B, atom_size) -> (B, atom_size)
            Tz = (rewards + discount_factor * (~dones) * self.support).clamp(
                self.config.v_min, self.config.v_max
            )
            # print("Tz", Tz)

            # all elementwise
            b: torch.Tensor = (Tz - self.config.v_min) / delta_z
            l, u = (
                torch.clamp(b.floor().long(), 0, self.config.atom_size - 1),
                torch.clamp(b.ceil().long(), 0, self.config.atom_size - 1),
            )
            # print("b", b)
            # print("l", l)
            # print("u", u)

            # Fix disappearing probability mass when l = b = u (b is int)
            l[(u > 0) * (l == u)] -= 1
            u[(l < (self.config.atom_size - 1)) * (l == u)] += 1
            # print("fixed l", l)
            # print("fixed u", u)
            # dones = dones.squeeze()
            # masked_probs = torch.ones_like(probabilities) / self.config.atom_size
            # masked_probs[~dones] = probabilities[~dones]

            m = torch.zeros_like(probabilities)
            m.scatter_add_(dim=1, index=l, src=probabilities * ((u.float()) - b))
            m.scatter_add_(dim=1, index=u, src=probabilities * ((b - l.float())))
            # print("old_m", (m * self.support).sum(-1))

            # projected_distribution = torch.zeros_like(probabilities)
            # projected_distribution.scatter_add_(
            #     dim=1, index=l, src=masked_probs * (u.float() - b)
            # )
            # projected_distribution.scatter_add_(
            #     dim=1, index=u, src=masked_probs * (b - l.float())
            # )
            # print("m", (projected_distribution * self.support).sum(-1))
            return m

    def fill_replay_buffer(self): (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==agent_configs.agent_configs.base_config:[8:124]
==pacman:[1341:1458]
)


class ConfigBase:
    def parse_field(
        self, field_name, default=None, wrapper=None, required=True, dtype=None
    ):
        if field_name in self.config_dict:
            val = self.config_dict[field_name]
            # print("value: ", val)
            print(f"Using         {field_name:30}: {val}")
            if wrapper is not None:
                return wrapper(val)
            return self.config_dict[field_name]

        if default is not None:
            print(f"Using default {field_name:30}: {default}")
            if wrapper is not None:
                return wrapper(default)
            return default

        if required:
            raise ValueError(
                f"Missing required field without default value: {field_name}"
            )
        else:
            print(f"Using         {field_name:30}: {default}")

        if field_name in self._parsed_fields:
            print("warning: duplicate field: ", field_name)
        self._parsed_fields.add(field_name)

    def __init__(self, config_dict: dict):
        self.config_dict = config_dict
        self._parsed_fields = set()

    @classmethod
    def load(cls, filepath: str):
        with open(filepath, "r") as f:
            o = yaml.load(f, yaml.Loader)
            print(o)
            a = cls(config_dict=o["config_dict"])

        return a

    def dump(self, filepath: str):
        to_dump = dict(config_dict=self.config_dict)

        with open(filepath, "w") as f:
            yaml.dump(to_dump, f, yaml.Dumper)


class Config(ConfigBase):
    @classmethod
    def load(cls, filepath: str):
        with open(filepath, "r") as f:
            o = yaml.load(f, yaml.Loader)
            print(o)
            a = cls(config_dict=o["config_dict"], game_config=o["game"])

        return a

    def dump(self, filepath: str):
        to_dump = dict(config_dict=self.config_dict, game=self.game)

        with open(filepath, "w") as f:
            yaml.dump(to_dump, f, yaml.Dumper)

    def __init__(self, config_dict: dict, game_config: GameConfig) -> None:
        super().__init__(config_dict)
        # could take in a game config and set an action space and observation shape here
        # OR DO THAT IN BASE AGENT?
        self.game = game_config

        self._verify_game()

        # not hyperparameters but utility things
        self.save_intermediate_weights: bool = self.parse_field(
            "save_intermediate_weights", False
        )

        # ADD LEARNING RATE SCHEDULES
        self.training_steps: int = self.parse_field(
            "training_steps", 10000, wrapper=int
        )

        self.adam_epsilon: float = self.parse_field("adam_epsilon", 1e-6)
        self.momentum = self.parse_field("momentum", 0.9)
        self.learning_rate: float = self.parse_field("learning_rate", 0.001)
        self.clipnorm: int = self.parse_field("clipnorm", 0)
        self.optimizer: torch.optim.Optimizer = self.parse_field(
            "optimizer", torch.optim.Adam
        )
        self.weight_decay: float = self.parse_field("weight_decay", 0.0)
        self.loss_function: Loss = self.parse_field("loss_function", required=True)
        self.activation = self.parse_field(
            "activation", "relu", wrapper=prepare_activations
        )
        self.kernel_initializer = self.parse_field(
            "kernel_initializer",
            None,
            required=False,
            wrapper=kernel_initializer_wrapper,
        )

        self.minibatch_size: int = self.parse_field("minibatch_size", 64, wrapper=int)
        self.replay_buffer_size: int = self.parse_field(
            "replay_buffer_size", 5000, wrapper=int
        )
        self.min_replay_buffer_size: int = self.parse_field(
            "min_replay_buffer_size", self.minibatch_size, wrapper=int
        )
        self.num_minibatches: int = self.parse_field("num_minibatches", 1, wrapper=int)
        self.training_iterations: int = self.parse_field(
            "training_iterations", 1, wrapper=int
        ) (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==conv:[6:137]
==pacman:[2779:2912]
def unpack(x: int | Tuple):
    if isinstance(x, Tuple):
        assert len(x) == 2
        return x
    else:
        try:
            x = int(x)
            return x, x
        except Exception as e:
            print(f"error converting {x} to int: ", e)


class Conv2dStack(nn.Module):
    @staticmethod
    def calculate_same_padding(i, k, s) -> Tuple[None | Tuple[int], None | str | Tuple]:
        """Calculate pytorch inputs for same padding
        Args:
            i (int, int) or int: (h, w) or (w, w)
            k (int, int) or int: (k_h, k_w) or (k, k)
            s (int, int) or int: (s_h, s_w) or (s, s)
        Returns:
            Tuple[manual_pad_padding, torch_conv2d_padding_input]: Either the manual padding that must be applied (first element of tuple) or the input to the torch padding argument of the Conv2d layer
        """

        if s == 1:
            return None, "same"
        h, w = unpack(i)
        k_h, k_w = unpack(k)
        s_h, s_w = unpack(s)
        p_h = calculate_padding(h, k_h, s_h)
        p_w = calculate_padding(w, k_w, s_w)
        if p_h[0] == p_h[1] and p_w[0] == p_w[1]:
            return None, (p_h[0], p_w[0])
        else:
            # not torch compatiable, manually pad with torch.nn.functional.pad
            return (*p_w, *p_h), None

    def __init__(
        self,
        input_shape: tuple[int],
        filters: list[int],
        kernel_sizes: list[int | Tuple[int, int]],
        strides: list[int | Tuple[int, int]],
        activation: nn.Module = nn.ReLU(),
        noisy_sigma: float = 0,
    ):
        """A sequence of convolution layers with the activation function applied after each layer.
        Always applies the minimum zero-padding that ensures the output shape is equal to the input shape.
        Input shape in "BCHW" form, i.e. (batch_size, input_channels, height, width)
        """
        super(Conv2dStack, self).__init__()
        self.conv_layers = nn.ModuleList()

        self.activation = activation

        # [B, C_in, H, W]
        assert len(input_shape) == 4
        assert len(filters) == len(kernel_sizes) == len(strides)
        assert len(filters) > 0

        self.noisy = noisy_sigma != 0
        if self.noisy:
            print("warning: Noisy convolutions not implemented yet")
            # raise NotImplementedError("")

        current_input_channels = input_shape[1]
        for i in range(len(filters)):

            h, w = input_shape[2], input_shape[3]
            manual_padding, torch_padding = self.calculate_same_padding(
                (h, w), kernel_sizes[i], strides[i]
            )

            if not torch_padding is None:
                layer = nn.Conv2d(
                    in_channels=current_input_channels,
                    out_channels=filters[i],
                    kernel_size=kernel_sizes[i],
                    stride=strides[i],
                    padding=torch_padding,
                )
            else:
                layer = nn.Sequential(
                    nn.ZeroPad2d(manual_padding),
                    nn.Conv2d(
                        in_channels=current_input_channels,
                        out_channels=filters[i],
                        kernel_size=kernel_sizes[i],
                        stride=strides[i],
                    ),
                )

            self.conv_layers.append(layer)
            current_input_channels = filters[i]

        self._output_len = current_input_channels

    def initialize(self, initializer: Callable[[Tensor], None]) -> None:
        def initialize_if_conv(m: nn.Module):
            if isinstance(m, nn.Conv2d):
                initializer(m.weight)

        self.apply(initialize_if_conv)

    def forward(self, inputs):
        x = inputs
        for layer in self.conv_layers:
            x = self.activation(layer(x))
        return x

    def reset_noise(self):
        assert self.noisy

        # noisy not implemented

        # for layer in self.conv_layers:
        #     # layer.reset_noise()
        # return

    def remove_noise(self):
        assert self.noisy

        # noisy not implemented

        # for layer in self.conv_layers:
        #     # layer.reset_noise()
        # return

    @property
    def output_channels(self):
        return self._output_len

 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==a2c_network:[47:135]
==rl-research.ppo.ppo_network:[33:121]
        super().__init__(*args, **kwargs)
        self.config = config
        self.has_conv_layers = len(config.critic_conv_layers) > 0
        self.has_dense_layers = len(config.critic_dense_layer_widths) > 0

        current_shape = input_shape
        B = current_shape[0]
        if self.has_conv_layers:
            assert len(input_shape) == 4
            filters, kernel_sizes, strides = to_lists(config.critic_conv_layers)

            # (B, C_in, H, W) -> (B, C_out H, W)
            self.conv_layers = Conv2dStack(
                input_shape=input_shape,
                filters=filters,
                kernel_sizes=kernel_sizes,
                strides=strides,
                activation=self.config.activation,
                noisy_sigma=config.noisy_sigma,
            )
            current_shape = (
                B,
                self.conv_layers.output_channels,
                current_shape[2],
                current_shape[3],
            )

        if self.has_dense_layers:
            if len(current_shape) == 4:
                initial_width = current_shape[1] * current_shape[2] * current_shape[3]
            else:
                assert len(current_shape) == 2
                initial_width = current_shape[1]

            # (B, width_in) -> (B, width_out)
            self.dense_layers = DenseStack(
                initial_width=initial_width,
                widths=self.config.critic_dense_layer_widths,
                activation=self.config.activation,
                noisy_sigma=self.config.noisy_sigma,
            )
            current_shape = (
                B,
                self.dense_layers.output_width,
            )

        if len(current_shape) == 4:
            initial_width = current_shape[1] * current_shape[2] * current_shape[3]
        else:
            assert len(current_shape) == 2
            initial_width = current_shape[1]

        self.value = build_dense(
            in_features=initial_width,
            out_features=1,
            sigma=config.noisy_sigma,
        )

    def initialize(self, initializer: Callable[[Tensor], None]) -> None:
        if self.has_conv_layers:
            self.conv_layers.initialize(initializer)
        if self.has_dense_layers:
            self.dense_layers.initialize(initializer)
        self.value.initialize(initializer)  # OUTPUT LAYER

    def forward(self, inputs: Tensor):
        if self.has_conv_layers:
            assert inputs.dim() == 4

        x = inputs
        if self.has_conv_layers:
            x = self.conv_layers(x)
        if self.has_dense_layers:
            x = self.dense_layers(x)
        value = self.value(x)
        return value

    def reset_noise(self):
        if self.has_conv_layers:
            self.conv_layers.reset_noise()
        if self.has_dense_layers:
            self.dense_layers.reset_noise()
        self.value.reset_noise()


class ActorNetwork(nn.Module):
    def __init__(
        self, (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[2380:2470]
==rl-research.replay_buffers.n_step_replay_buffer:[6:94]
class NStepReplayBuffer(BaseDQNReplayBuffer):
    def __init__(
        self,
        observation_dimensions: tuple,
        observation_dtype: np.dtype,
        max_size: int,
        batch_size: int = 32,
        n_step: int = 1,
        gamma: float = 0.99,
        compressed_observations: bool = False,
        num_players: int = 1,
    ):
        self.n_step = n_step
        self.gamma = gamma
        self.num_players = num_players
        super().__init__(
            observation_dimensions=observation_dimensions,
            observation_dtype=observation_dtype,
            max_size=max_size,
            batch_size=batch_size,
            compressed_observations=compressed_observations,
        )

    def store(
        self,
        observation,
        info: dict,
        action,
        reward: float,
        next_observation,
        next_info: dict,
        done: bool,
        id=None,
        player: int = 0,
    ):
        """Store a (s_t, a, r, s_t+1) transtion to the replay buffer.
           Returns a valid generated n-step transition (s_t-n, a, r, s_t) with the
           inputted observation as the next_observation (s_t)

        Returns:
            (s_t-n, a, r, s_t): where r is the n-step return calculated with the replay buffer's gamma
        """
        transition = (
            observation,
            info,
            action,
            reward,
            next_observation,
            next_info,
            done,
        )
        # print("store t:", transition)
        self.n_step_buffers[player].append(transition)
        if len(self.n_step_buffers[player]) < self.n_step:
            return None

        # compute n-step return and store
        reward, next_observation, next_info, done = self._get_n_step_info(player)
        observation, info, action = self.n_step_buffers[player][0][:3]
        n_step_transition = (
            observation,
            info,
            action,
            reward,
            next_observation,
            next_info,
            done,
        )
        super().store(*n_step_transition, id=id)
        return n_step_transition

    def clear(self):
        super().clear()
        self.n_step_buffers = [
            deque(maxlen=self.n_step) for q in range(self.num_players)
        ]

    def _get_n_step_info(self, player: int = 0):
        reward, next_observation, next_info, done = self.n_step_buffers[player][-1][-4:]

        for transition in reversed(list(self.n_step_buffers[player])[:-1]):
            r, n_o, n_i, d = transition[-4:]
            reward = r + self.gamma * reward * (1 - d)
            next_observation, next_info, done = (
                (n_o, n_i, d) if d else (next_observation, next_info, done)
            )

        return reward, next_observation, next_info, done

 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[1887:2024]
==rl-research.replay_buffers.segment_tree:[7:142]
class SegmentTree:
    """Create SegmentTree.

    Taken from OpenAI baselines github repository:
    https://github.com/openai/baselines/blob/master/baselines/common/segment_tree.py

    Attributes:
        capacity (int)
        tree (list)
        operation (function)

    """

    def __init__(self, capacity: int, operation: Callable, init_value: float):
        """Initialization.

        Args:
            capacity (int)
            operation (function)
            init_value (float)

        """
        assert (
            capacity > 0 and capacity & (capacity - 1) == 0
        ), "capacity must be positive and a power of 2."
        self.capacity = capacity
        self.tree = [init_value for _ in range(2 * capacity)]
        self.operation = operation

    def _operate_helper(
        self, start: int, end: int, node: int, node_start: int, node_end: int
    ) -> float:
        """Returns result of operation in segment."""
        if start == node_start and end == node_end:
            return self.tree[node]
        mid = (node_start + node_end) // 2
        if end <= mid:
            return self._operate_helper(start, end, 2 * node, node_start, mid)
        else:
            if mid + 1 <= start:
                return self._operate_helper(start, end, 2 * node + 1, mid + 1, node_end)
            else:
                return self.operation(
                    self._operate_helper(start, mid, 2 * node, node_start, mid),
                    self._operate_helper(mid + 1, end, 2 * node + 1, mid + 1, node_end),
                )

    def operate(self, start: int = 0, end: int = 0) -> float:
        """Returns result of applying `self.operation`."""
        if end <= 0:
            end += self.capacity
        end -= 1

        return self._operate_helper(start, end, 1, 0, self.capacity - 1)

    def __setitem__(self, idx: int, val: float):
        """Set value in tree."""
        idx += self.capacity
        self.tree[idx] = val

        idx //= 2
        while idx >= 1:
            self.tree[idx] = self.operation(self.tree[2 * idx], self.tree[2 * idx + 1])
            idx //= 2

    def __getitem__(self, idx: int) -> float:
        """Get real value in leaf node of tree."""
        assert 0 <= idx < self.capacity

        return self.tree[self.capacity + idx]


class SumSegmentTree(SegmentTree):
    """Create SumSegmentTree.

    Taken from OpenAI baselines github repository:
    https://github.com/openai/baselines/blob/master/baselines/common/segment_tree.py

    """

    def __init__(self, capacity: int):
        """Initialization.

        Args:
            capacity (int)

        """
        super(SumSegmentTree, self).__init__(
            capacity=capacity, operation=operator.add, init_value=0.0
        )

    def sum(self, start: int = 0, end: int = 0) -> float:
        """Returns arr[start] + ... + arr[end]."""
        return super(SumSegmentTree, self).operate(start, end)

    def retrieve(self, upperbound: float) -> int:
        """Find the highest index `i` about upper bound in the tree"""
        # TODO: Check assert case and fix bug
        assert 0 <= upperbound <= self.sum() + 1e-5, "upperbound: {}".format(upperbound)

        idx = 1

        while idx < self.capacity:  # while non-leaf
            left = 2 * idx
            right = left + 1
            if self.tree[left] > upperbound:
                idx = 2 * idx
            else:
                upperbound -= self.tree[left]
                idx = right
        return idx - self.capacity


class MinSegmentTree(SegmentTree):
    """Create SegmentTree.

    Taken from OpenAI baselines github repository:
    https://github.com/openai/baselines/blob/master/baselines/common/segment_tree.py

    """

    def __init__(self, capacity: int):
        """Initialization.

        Args:
            capacity (int)

        """
        super(MinSegmentTree, self).__init__(
            capacity=capacity, operation=min, init_value=float("inf")
        )

    def min(self, start: int = 0, end: int = 0) -> float:
        """Returns min(arr[start], ...,  arr[end])."""
        return super(MinSegmentTree, self).operate(start, end)

 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==a2c_network:[46:114]
==rl-research.alphazero.alphazero_network:[145:214]
    ):
        super().__init__(*args, **kwargs)
        self.config = config
        self.has_conv_layers = len(config.critic_conv_layers) > 0
        self.has_dense_layers = len(config.critic_dense_layer_widths) > 0

        current_shape = input_shape
        B = current_shape[0]
        if self.has_conv_layers:
            # WITH BATCHNORM FOR EVERY CONV LAYER
            assert len(input_shape) == 4
            filters, kernel_sizes, strides = to_lists(config.critic_conv_layers)

            # (B, C_in, H, W) -> (B, C_out H, W)
            self.conv_layers = Conv2dStack(
                input_shape=input_shape,
                filters=filters,
                kernel_sizes=kernel_sizes,
                strides=strides,
                activation=self.config.activation,
                noisy_sigma=config.noisy_sigma,
            )
            current_shape = (
                B,
                self.conv_layers.output_channels,
                current_shape[2],
                current_shape[3],
            )

        if self.has_dense_layers:
            if len(current_shape) == 4:
                initial_width = current_shape[1] * current_shape[2] * current_shape[3]
            else:
                assert len(current_shape) == 2
                initial_width = current_shape[1]

            # (B, width_in) -> (B, width_out)
            self.dense_layers = DenseStack(
                initial_width=initial_width,
                widths=self.config.critic_dense_layer_widths,
                activation=self.config.activation,
                noisy_sigma=self.config.noisy_sigma,
            )
            current_shape = (
                B,
                self.dense_layers.output_width,
            )

        if len(current_shape) == 4:
            initial_width = current_shape[1] * current_shape[2] * current_shape[3]
        else:
            assert len(current_shape) == 2
            initial_width = current_shape[1]

        self.value = build_dense(
            in_features=initial_width,
            out_features=1,
            sigma=config.noisy_sigma,
        )

    def initialize(self, initializer: Callable[[Tensor], None]) -> None:
        if self.has_conv_layers:
            self.conv_layers.initialize(initializer)
        if self.has_dense_layers:
            self.dense_layers.initialize(initializer)
        self.value.initialize(initializer)  # OUTPUT LAYER

    def forward(self, inputs: Tensor):
        if self.has_conv_layers: (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[3266:3334]
==rl-research.muzero.muzero_network:[329:399]
        self.output_size = output_size

        current_shape = input_shape
        B = current_shape[0]

        # INPUTS = CONV + BATCHNORM + maybe RELU?

        if self.has_residual_layers:
            assert (
                len(input_shape) == 4
            ), "Input shape should be (B, C, H, W), got {}".format(input_shape)
            filters, kernel_sizes, strides = to_lists(config.residual_layers)

            # (B, C_in, H, W) -> (B, C_out H, W)
            self.residual_layers = ResidualStack(
                input_shape=input_shape,
                filters=filters,
                kernel_sizes=kernel_sizes,
                strides=strides,
                activation=self.config.activation,
                noisy_sigma=config.noisy_sigma,
            )
            current_shape = (
                B,
                self.residual_layers.output_channels,
                current_shape[2],
                current_shape[3],
            )

        if self.has_conv_layers:
            assert (
                len(input_shape) == 4
            ), "Input shape should be (B, C, H, W), got {}".format(input_shape)
            filters, kernel_sizes, strides = to_lists(config.conv_layers)

            # (B, C_in, H, W) -> (B, C_out H, W)
            self.conv_layers = Conv2dStack(
                input_shape=input_shape,
                filters=filters,
                kernel_sizes=kernel_sizes,
                strides=strides,
                activation=self.config.activation,
                noisy_sigma=config.noisy_sigma,
            )
            current_shape = (
                B,
                self.conv_layers.output_channels,
                current_shape[2],
                current_shape[3],
            )

        if self.has_dense_layers:
            if len(current_shape) == 4:
                initial_width = current_shape[1] * current_shape[2] * current_shape[3]
            else:
                assert len(current_shape) == 2
                initial_width = current_shape[1]

            # (B, width_in) -> (B, width_out)
            self.dense_layers = DenseStack(
                initial_width=initial_width,
                widths=self.config.dense_layer_widths,
                activation=self.config.activation,
                noisy_sigma=self.config.noisy_sigma,
            )
            current_shape = (
                B,
                self.dense_layers.output_width,
            )
 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.alphazero.alphazero_network:[146:214]
==rl-research.ppo.ppo_network:[33:100]
        super().__init__(*args, **kwargs)
        self.config = config
        self.has_conv_layers = len(config.critic_conv_layers) > 0
        self.has_dense_layers = len(config.critic_dense_layer_widths) > 0

        current_shape = input_shape
        B = current_shape[0]
        if self.has_conv_layers:
            assert len(input_shape) == 4
            filters, kernel_sizes, strides = to_lists(config.critic_conv_layers)

            # (B, C_in, H, W) -> (B, C_out H, W)
            self.conv_layers = Conv2dStack(
                input_shape=input_shape,
                filters=filters,
                kernel_sizes=kernel_sizes,
                strides=strides,
                activation=self.config.activation,
                noisy_sigma=config.noisy_sigma,
            )
            current_shape = (
                B,
                self.conv_layers.output_channels,
                current_shape[2],
                current_shape[3],
            )

        if self.has_dense_layers:
            if len(current_shape) == 4:
                initial_width = current_shape[1] * current_shape[2] * current_shape[3]
            else:
                assert len(current_shape) == 2
                initial_width = current_shape[1]

            # (B, width_in) -> (B, width_out)
            self.dense_layers = DenseStack(
                initial_width=initial_width,
                widths=self.config.critic_dense_layer_widths,
                activation=self.config.activation,
                noisy_sigma=self.config.noisy_sigma,
            )
            current_shape = (
                B,
                self.dense_layers.output_width,
            )

        if len(current_shape) == 4:
            initial_width = current_shape[1] * current_shape[2] * current_shape[3]
        else:
            assert len(current_shape) == 2
            initial_width = current_shape[1]

        self.value = build_dense(
            in_features=initial_width,
            out_features=1,
            sigma=config.noisy_sigma,
        )

    def initialize(self, initializer: Callable[[Tensor], None]) -> None:
        if self.has_conv_layers:
            self.conv_layers.initialize(initializer)
        if self.has_dense_layers:
            self.dense_layers.initialize(initializer)
        self.value.initialize(initializer)  # OUTPUT LAYER

    def forward(self, inputs: Tensor):
        if self.has_conv_layers: (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rainbow.rainbow_network:[36:104]
==rl-research.alphazero.alphazero_network:[32:102]
        self.output_size = output_size

        current_shape = input_shape
        B = current_shape[0]

        if self.has_residual_layers:
            assert (
                len(input_shape) == 4
            ), "Input shape should be (B, C, H, W), got {}".format(input_shape)
            filters, kernel_sizes, strides = to_lists(config.residual_layers)

            # (B, C_in, H, W) -> (B, C_out H, W)
            self.residual_layers = ResidualStack(
                input_shape=input_shape,
                filters=filters,
                kernel_sizes=kernel_sizes,
                strides=strides,
                activation=self.config.activation,
                noisy_sigma=config.noisy_sigma,
            )
            current_shape = (
                B,
                self.residual_layers.output_channels,
                current_shape[2],
                current_shape[3],
            )

        if self.has_conv_layers:
            assert (
                len(input_shape) == 4
            ), "Input shape should be (B, C, H, W), got {}".format(input_shape)
            filters, kernel_sizes, strides = to_lists(config.conv_layers)

            # (B, C_in, H, W) -> (B, C_out H, W)
            self.conv_layers = Conv2dStack(
                input_shape=input_shape,
                filters=filters,
                kernel_sizes=kernel_sizes,
                strides=strides,
                activation=self.config.activation,
                noisy_sigma=config.noisy_sigma,
            )
            current_shape = (
                B,
                self.conv_layers.output_channels,
                current_shape[2],
                current_shape[3],
            )

        if self.has_dense_layers:
            if len(current_shape) == 4:
                initial_width = current_shape[1] * current_shape[2] * current_shape[3]
            else:
                assert len(current_shape) == 2
                initial_width = current_shape[1]

            # (B, width_in) -> (B, width_out)
            self.dense_layers = DenseStack(
                initial_width=initial_width,
                widths=self.config.dense_layer_widths,
                activation=self.config.activation,
                noisy_sigma=self.config.noisy_sigma,
            )
            current_shape = (
                B,
                self.dense_layers.output_width,
            )
 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.alphazero.alphazero_network:[28:87]
==rl-research.imitation_learning.supervised_network:[17:74]
        assert (
            self.has_conv_layers or self.has_dense_layers or self.has_residual_layers
        ), "At least one of the layers should be present."

        self.output_size = output_size

        current_shape = input_shape
        B = current_shape[0]

        if self.has_residual_layers:
            assert (
                len(input_shape) == 4
            ), "Input shape should be (B, C, H, W), got {}".format(input_shape)
            filters, kernel_sizes, strides = to_lists(config.residual_layers)

            # (B, C_in, H, W) -> (B, C_out H, W)
            self.residual_layers = ResidualStack(
                input_shape=input_shape,
                filters=filters,
                kernel_sizes=kernel_sizes,
                strides=strides,
                activation=self.config.activation,
                noisy_sigma=config.noisy_sigma,
            )
            current_shape = (
                B,
                self.residual_layers.output_channels,
                current_shape[2],
                current_shape[3],
            )

        if self.has_conv_layers:
            assert (
                len(input_shape) == 4
            ), "Input shape should be (B, C, H, W), got {}".format(input_shape)
            filters, kernel_sizes, strides = to_lists(config.conv_layers)

            # (B, C_in, H, W) -> (B, C_out H, W)
            self.conv_layers = Conv2dStack(
                input_shape=input_shape,
                filters=filters,
                kernel_sizes=kernel_sizes,
                strides=strides,
                activation=self.config.activation,
                noisy_sigma=config.noisy_sigma,
            )
            current_shape = (
                B,
                self.conv_layers.output_channels,
                current_shape[2],
                current_shape[3],
            )

        if self.has_dense_layers:
            if len(current_shape) == 4:
                initial_width = current_shape[1] * current_shape[2] * current_shape[3]
            else: (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[1816:1887]
==rainbow_config:[4:69]
class RainbowConfig(Config):
    def __init__(self, config_dict: dict, game_config):
        super(RainbowConfig, self).__init__(config_dict, game_config)
        print("RainbowConfig")
        self.residual_layers: list = self.parse_field("residual_layers", [])
        self.conv_layers: list = self.parse_field("conv_layers", [])
        self.dense_layer_widths: int = self.parse_field(
            "dense_layer_widths", [128], tointlists
        )
        self.value_hidden_layer_widths = self.parse_field(
            "value_hidden_layer_widths", [], tointlists
        )
        self.advantage_hidden_layer_widths: int = self.parse_field(
            "advantage_hidden_layer_widths", [], tointlists
        )

        self.noisy_sigma: float = self.parse_field("noisy_sigma", 0.5)
        self.eg_epsilon: float = self.parse_field("eg_epsilon", 0.00)
        self.eg_epsilon_final: float = self.parse_field("eg_epsilon_final", 0.00)
        self.eg_epsilon_decay_type: str = self.parse_field(
            "eg_epsilon_decay_type", "linear"
        )
        self.eg_epsilon_final_step: int = self.parse_field(
            "eg_epsilon_final_step", self.training_steps
        )

        self.dueling: bool = self.parse_field("dueling", True)
        self.discount_factor: float = self.parse_field("discount_factor", 0.99)
        self.soft_update: bool = self.parse_field("soft_update", False)
        self.transfer_interval: int = self.parse_field(
            "transfer_interval", 512, wrapper=int
        )
        self.ema_beta: float = self.parse_field("ema_beta", 0.99)
        self.replay_interval: int = self.parse_field("replay_interval", 1, wrapper=int)
        self.per_alpha: float = self.parse_field("per_alpha", 0.6)
        self.per_beta: float = self.parse_field("per_beta", 0.5)
        self.per_beta_final: float = self.parse_field("per_beta_final", 1.0)
        self.per_epsilon: float = self.parse_field("per_epsilon", 1e-6)
        self.n_step: int = self.parse_field("n_step", 3)
        self.atom_size: int = self.parse_field("atom_size", 51, wrapper=int)
        # assert (
        #     self.atom_size > 1
        # ), "Atom size must be greater than 1, as softmax and Q distribution to Q value calculation requires more than 1 atom"

        # assert not (
        #     self.game.is_image
        #     and len(self.conv_layers) == 0
        #     and len(self.residual_layers) == 0
        # ), "Convolutional layers must be defined for image based games"

        if len(self.conv_layers) > 0:
            assert len(self.conv_layers[0]) == 3

        # maybe don't use a game config, since if tuning for multiple games this should be the same regardless of the game <- (it is really a hyper parameter if you are tuning for multiple games or a game with unknown bounds)

        # could use a MuZero min-max config and just constantly update the suport size (would this break the model?) <- might mean this is not in the config but just a part of the model

        self.v_min = game_config.min_score
        self.v_max = game_config.max_score

        if self.atom_size != 1:
            assert self.v_min != None and self.v_max != None

    def _verify_game(self):
        assert self.game.is_discrete, "Rainbow only supports discrete action spaces" (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[3516:3567]
==rainbow.rainbow_agent:[49:100]
    ):
        super(RainbowAgent, self).__init__(env, config, name, device=device)
        self.model = RainbowNetwork(
            config=config,
            output_size=self.num_actions,
            input_shape=(self.config.minibatch_size,) + self.observation_dimensions,
        )
        self.target_model = RainbowNetwork(
            config=config,
            output_size=self.num_actions,
            input_shape=(self.config.minibatch_size,) + self.observation_dimensions,
        )

        if not self.config.kernel_initializer == None:
            self.model.initialize(self.config.kernel_initializer)

        self.model.to(device)
        self.target_model.to(device)
        self.target_model.load_state_dict(self.model.state_dict())
        self.target_model.eval()

        if self.config.optimizer == Adam:
            self.optimizer: torch.optim.Optimizer = self.config.optimizer(
                params=self.model.parameters(),
                lr=self.config.learning_rate,
                eps=self.config.adam_epsilon,
                weight_decay=self.config.weight_decay,
            )
        elif self.config.optimizer == SGD:
            print("Warning: SGD does not use adam_epsilon param")
            self.optimizer: torch.optim.Optimizer = self.config.optimizer(
                params=self.model.parameters(),
                lr=self.config.learning_rate,
                momentum=self.config.momentum,
                weight_decay=self.config.weight_decay,
            )

        self.replay_buffer = PrioritizedNStepReplayBuffer(
            observation_dimensions=self.observation_dimensions,
            observation_dtype=self.env.observation_space.dtype,
            max_size=self.config.replay_buffer_size,
            batch_size=self.config.minibatch_size,
            max_priority=1.0,
            alpha=self.config.per_alpha,
            beta=self.config.per_beta,
            # epsilon=config["per_epsilon"],
            n_step=self.config.n_step,
            gamma=self.config.discount_factor,
            compressed_observations=(
                self.env.lz4_compress if hasattr(self.env, "lz4_compress") else False
            ), (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rainbow.rainbow_network:[36:89]
==rl-research.imitation_learning.supervised_network:[21:74]
        self.output_size = output_size

        current_shape = input_shape
        B = current_shape[0]

        if self.has_residual_layers:
            assert (
                len(input_shape) == 4
            ), "Input shape should be (B, C, H, W), got {}".format(input_shape)
            filters, kernel_sizes, strides = to_lists(config.residual_layers)

            # (B, C_in, H, W) -> (B, C_out H, W)
            self.residual_layers = ResidualStack(
                input_shape=input_shape,
                filters=filters,
                kernel_sizes=kernel_sizes,
                strides=strides,
                activation=self.config.activation,
                noisy_sigma=config.noisy_sigma,
            )
            current_shape = (
                B,
                self.residual_layers.output_channels,
                current_shape[2],
                current_shape[3],
            )

        if self.has_conv_layers:
            assert (
                len(input_shape) == 4
            ), "Input shape should be (B, C, H, W), got {}".format(input_shape)
            filters, kernel_sizes, strides = to_lists(config.conv_layers)

            # (B, C_in, H, W) -> (B, C_out H, W)
            self.conv_layers = Conv2dStack(
                input_shape=input_shape,
                filters=filters,
                kernel_sizes=kernel_sizes,
                strides=strides,
                activation=self.config.activation,
                noisy_sigma=config.noisy_sigma,
            )
            current_shape = (
                B,
                self.conv_layers.output_channels,
                current_shape[2],
                current_shape[3],
            )

        if self.has_dense_layers:
            if len(current_shape) == 4:
                initial_width = current_shape[1] * current_shape[2] * current_shape[3]
            else: (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==a2c_network:[272:322]
==rl-research.ppo.ppo_network:[134:183]
        current_shape = input_shape
        B = current_shape[0]
        if self.has_conv_layers:
            assert len(input_shape) == 4
            filters, kernel_sizes, strides = to_lists(config.actor_conv_layers)

            # (B, C_in, H, W) -> (B, C_out H, W)
            self.conv_layers = Conv2dStack(
                input_shape=input_shape,
                filters=filters,
                kernel_sizes=kernel_sizes,
                strides=strides,
                activation=self.config.activation,
                noisy_sigma=config.noisy_sigma,
            )
            current_shape = (
                B,
                self.conv_layers.output_channels,
                current_shape[2],
                current_shape[3],
            )

        if self.has_dense_layers:
            if len(current_shape) == 4:
                initial_width = current_shape[1] * current_shape[2] * current_shape[3]
            else:
                assert (
                    len(current_shape) == 2
                ), "Input shape should be (B, width), got {}".format(current_shape)
                initial_width = current_shape[1]

            # (B, width_in) -> (B, width_out)
            self.dense_layers = DenseStack(
                initial_width=initial_width,
                widths=self.config.actor_dense_layer_widths,
                activation=self.config.activation,
                noisy_sigma=self.config.noisy_sigma,
            )
            current_shape = (
                B,
                self.dense_layers.output_width,
            )

        if len(current_shape) == 4:
            initial_width = current_shape[1] * current_shape[2] * current_shape[3]
        else:
            assert len(current_shape) == 2
            initial_width = current_shape[1]
 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==a2c_network:[148:197]
==rl-research.alphazero.alphazero_network:[249:300]
        current_shape = input_shape
        B = current_shape[0]
        if self.has_conv_layers:
            # WITH BATCHNORM FOR EVERY CONV LAYER
            assert len(input_shape) == 4
            filters, kernel_sizes, strides = to_lists(config.actor_conv_layers)

            # (B, C_in, H, W) -> (B, C_out H, W)
            self.conv_layers = Conv2dStack(
                input_shape=input_shape,
                filters=filters,
                kernel_sizes=kernel_sizes,
                strides=strides,
                activation=self.config.activation,
                noisy_sigma=config.noisy_sigma,
            )
            current_shape = (
                B,
                self.conv_layers.output_channels,
                current_shape[2],
                current_shape[3],
            )

        if self.has_dense_layers:
            if len(current_shape) == 4:
                initial_width = current_shape[1] * current_shape[2] * current_shape[3]
            else:
                assert (
                    len(current_shape) == 2
                ), "Input shape should be (B, width), got {}".format(current_shape)
                initial_width = current_shape[1]

            # (B, width_in) -> (B, width_out)
            self.dense_layers = DenseStack(
                initial_width=initial_width,
                widths=self.config.actor_dense_layer_widths,
                activation=self.config.activation,
                noisy_sigma=self.config.noisy_sigma,
            )

            current_shape = (
                B,
                self.dense_layers.output_width,
            )

        if len(current_shape) == 4:
            initial_width = current_shape[1] * current_shape[2] * current_shape[3]
        else:
            assert len(current_shape) == 2
            initial_width = current_shape[1]
 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[1243:1301]
==utils.utils.utils:[1225:1281]
class TrainingStepStoppingCritiera(StoppingCriteria):
    def __init__(self, max_training_steps=100000):
        self.max_training_steps = max_training_steps

    def should_stop(self, details: dict) -> bool:
        return details["training_step"] > self.max_training_steps


class EpisodesStoppingCriteria(StoppingCriteria):
    def __init__(self, max_episodes=100000):
        self.max_episodes = max_episodes

    def should_stop(self, details: dict) -> bool:
        return details["max_episodes"] > self.max_episodes


class AverageScoreStoppingCritera(StoppingCriteria):
    def __init__(self, min_avg_score: float, last_scores_length: int):
        self.min_avg_score = min_avg_score
        self.last_scores_length = last_scores_length
        self.last_scores = deque(maxlen=last_scores_length)

    def add_score(self, score: float):
        self.last_scores.append(score)

    def should_stop(self, details: dict) -> bool:
        if len(self.last_scores) < self.last_scores_length:
            return False

        return np.average(self.last_scores) < self.min_avg_score


class ApexLearnerStoppingCriteria(StoppingCriteria):
    def __init__(self):
        self.criterias: dict[str, StoppingCriteria] = {
            "time": TimeStoppingCriteria(max_runtime_sec=1.5 * 60 * 60),
            "training_step": TrainingStepStoppingCritiera(max_training_steps=10000),
            "avg_score": AverageScoreStoppingCritera(
                min_avg_score=15, last_scores_length=10
            ),
        }

    def should_stop(self, details: dict) -> bool:
        if self.criterias["time"].should_stop(details):
            return True

        if details["training_step"] < 10000:
            return False

        return self.criterias["training_step"].should_stop(details) or self.criterias[
            "avg_score"
        ].should_stop(details)

    def add_score(self, score: float):
        tc: AverageScoreStoppingCritera = self.criterias["avg_score"]
        tc.add_score(score) (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[2024:2078]
==rl-research.replay_buffers.fast_sum_tree:[3:55]
class FastSumTree(object):
    # https://medium.com/free-code-camp/improvements-in-deep-q-learning-dueling-double-dqn-prioritized-experience-replay-and-fixed-58b130cc5682

    def __init__(self, capacity: int):
        self.capacity = (
            capacity  # number of leaf nodes (final nodes) that contains experiences
        )

        self.tree = np.zeros(2 * self.capacity - 1)  # sub tree
        # self.data = np.zeros(self.capacity, object)  # contains the experiences

    def add(self, idx: int, val: float):
        """Set value in tree."""
        tree_index = idx + self.capacity - 1
        # self.data[self.data_pointer] = data
        self.update(tree_index, val)

    def __getitem__(self, idx: int) -> float:
        """Get real value in leaf node of tree."""
        assert 0 <= idx < self.capacity

        return self.tree[self.capacity + idx]

    def update(self, tree_index: int, val: float):
        change = val - self.tree[tree_index]
        # print("change", change)
        self.tree[tree_index] = val
        while tree_index != 0:
            tree_index = (tree_index - 1) // 2
            self.tree[tree_index] += change
            # print("new value", self.tree[tree_index])

    def retrieve(self, v: float):
        parent_index = 0
        while True:
            left_child_index = 2 * parent_index + 1
            right_child_index = left_child_index + 1
            if left_child_index >= len(self.tree):
                leaf_index = parent_index
                break
            else:
                if v <= self.tree[left_child_index]:
                    parent_index = left_child_index
                else:
                    v -= self.tree[left_child_index]
                    parent_index = right_child_index

        return leaf_index, self.tree[leaf_index]

    @property
    def total_priority(self):
        return self.tree[0]

 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==game_configs.game_configs.game_config:[0:41]
==pacman:[1301:1344]
class GameConfig:
    def __init__(
        self,
        max_score,
        min_score,
        is_discrete,
        is_image,
        is_deterministic,
        has_legal_moves,
        perfect_information,
        multi_agent,
        num_players,
    ):
        self.max_score = max_score
        self.min_score = min_score
        self.is_discrete = is_discrete  # can just check the action space type instead of setting manually if the env is passed in (ALSO COULD DO THIS IN THE BASE GAME CONFIG)
        # self.num_actions = num_actions
        # self.observation_space = observation_space
        self.is_image = is_image
        self.is_deterministic = is_deterministic
        # self.num_players = num_players (might not need this idk) <- it would likely be for muzero but could also be for rainbow and stuff when they play multiplayer games (like connect 4)
        self.has_legal_moves = has_legal_moves
        self.perfect_information = perfect_information
        self.multi_agent = multi_agent
        self.num_players = num_players

    def __eq__(self, o: object) -> bool:
        if not isinstance(o, GameConfig):
            return False

        return (
            self.max_score == o.max_score
            and self.min_score == o.min_score
            and self.is_discrete == o.is_discrete
            and self.is_image == o.is_image
            and self.is_deterministic == o.is_deterministic
            and self.has_legal_moves == o.has_legal_moves
            and self.perfect_information == o.perfect_information
            and self.multi_agent == o.multi_agent
            and self.num_players == o.num_players
        )

 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[3610:3661]
==rainbow.rainbow_agent:[150:201]
        assert info is not None if mask_actions else True, "Need info to mask actions"
        # print(info)
        if self.config.atom_size > 1:
            q_values = distribution * self.support
            q_values = q_values.sum(2, keepdim=False)
        else:
            q_values = distribution
        if mask_actions:
            legal_moves = get_legal_moves(info)
            q_values = action_mask(
                q_values, legal_moves, mask_value=-float("inf"), device=self.device
            )
        # print("Q Values", q_values)
        # q_values with argmax ties
        # selected_actions = torch.stack(
        #     [
        #         torch.tensor(np.random.choice(np.where(x.cpu() == x.cpu().max())[0]))
        #         for x in q_values
        #     ]
        # )
        # print(selected_actions)
        selected_actions = q_values.argmax(1, keepdim=False)
        return selected_actions

    def learn(self) -> np.ndarray:
        losses = np.zeros(self.config.training_iterations)
        for i in range(self.config.training_iterations):
            samples = self.replay_buffer.sample()
            loss = self.learn_from_sample(samples)
            losses[i] = loss
        return losses

    def learn_from_sample(self, samples: dict):
        observations, weights, actions = (
            samples["observations"],
            samples["weights"],
            torch.from_numpy(samples["actions"]).to(self.device).long(),
        )
        # print("actions", actions)

        # print("Observations", observations)
        # (B, outputs, atom_size) -[index action dimension by actions]> (B, atom_size)
        online_predictions = self.predict(observations)[
            range(self.config.minibatch_size), actions
        ]
        # for param in self.model.parameters():
        #     print(param)
        # print(self.predict(observations))
        # print(online_predictions)
        # (B, atom_size)
        if self.config.atom_size > 1: (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.custom_gym_envs.custom_gym_envs.envs.grid_world:[134:171]
==rl-research.custom_gym_envs.custom_gym_envs.envs.tictactoe:[179:217]
                    )

        # Finally, add some gridlines
        for x in range(self.size + 1):
            pygame.draw.line(
                canvas,
                0,
                (0, pix_square_size * x),
                (self.window_size, pix_square_size * x),
                width=3,
            )
            pygame.draw.line(
                canvas,
                0,
                (pix_square_size * x, 0),
                (pix_square_size * x, self.window_size),
                width=3,
            )

        if self.render_mode == "human":
            # The following line copies our drawings from `canvas` to the visible window
            self.window.blit(canvas, canvas.get_rect())
            pygame.event.pump()
            pygame.display.update()

            # We need to ensure that human-rendering occurs at the predefined framerate.
            # The following line will automatically add a delay to keep the framerate stable.
            self.clock.tick(self.metadata["render_fps"])
        else:  # rgb_array
            return np.transpose(
                np.array(pygame.surfarray.pixels3d(canvas)), axes=(1, 0, 2)
            )

    def close(self):
        if self.window is not None:
            pygame.display.quit()
            pygame.quit()
 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==ape_x.hyperopt_local:[268:303]
==ape_x.hyperparameter_optimization:[278:311]
    search_space, initial_best_config = create_search_space()
    max_trials = 64
    trials_step = 64  # how many additional trials to do after loading the last ones

    try:  # try to load an already saved trials object, and increase the max
        trials = pickle.load(open("./classiccontrol_trials.p", "rb"))
        logger.info("Found saved Trials! Loading...")
        max_trials = max(len(trials.trials) + trials_step, max_trials + trials_step)
        logger.info(
            f"Rerunning from {len(trials.trials)} trials to {max_trials} (+{trials_step}) trials"
        )
    except:  # create a new trials object and start searching
        # trials = Trials()
        trials = None

    best = fmin(
        fn=objective,  # Objective Function to optimize
        space=search_space,  # Hyperparameter's Search Space
        algo=tpe.suggest,  # Optimization algorithm (representative TPE)
        max_evals=max_trials,  # Number of optimization attempts
        trials=trials,  # Record the results
        # early_stop_fn=no_progress_loss(5, 1),
        trials_save_file="./classiccontrol_trials.p",
        points_to_evaluate=initial_best_config,
        show_progressbar=False,
    )

    logger.info(best)
    best_trial = space_eval(search_space, best)


# objective function - needs to launch

if __name__ == "__main__":
    main() (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[3883:3911]
==rainbow.rainbow_agent:[426:454]
                    )
                    done = terminated or truncated
                    # print("State", state)
                    self.replay_buffer.store(
                        state, info, action, reward, next_state, next_info, done
                    )
                    state = next_state
                    info = next_info
                    score += reward
                    self.replay_buffer.set_beta(
                        update_per_beta(
                            self.replay_buffer.beta,
                            self.config.per_beta_final,
                            self.training_steps,
                            self.config.per_beta,
                        )
                    )

                    if done:
                        state, info = self.env.reset()
                        score_dict = {
                            "score": score,
                            "target_model_updated": target_model_updated[0],
                        }
                        self.stats["score"].append(score_dict)
                        target_model_updated = (False, target_model_updated[1])
                        score = 0
 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==agent:[324:353]
==pacman:[1748:1777]
    def test(self, num_trials, step, dir="./checkpoints") -> None:
        if num_trials == 0:
            return
        with torch.no_grad():
            """Test the agent."""
            average_score = 0
            max_score = float("-inf")
            min_score = float("inf")
            # self.test_env.reset()
            if self.test_env.render_mode == "rgb_array":
                self.test_env.episode_trigger = lambda x: (x + 1) % num_trials == 0
                self.test_env.video_folder = "{}/videos/{}/{}".format(
                    dir, self.model_name, step
                )
                if not os.path.exists(self.test_env.video_folder):
                    os.makedirs(self.test_env.video_folder)
            for trials in range(num_trials):
                state, info = self.test_env.reset()

                done = False
                score = 0

                while not done:
                    prediction = self.predict(
                        state, info, env=self.test_env
                    )  # env = self.test_env is there for alpha_zero which needs to use the test env here instead of the normal env for the tree search (might be able to just use the regular env still)
                    action = self.select_actions(
                        prediction, info, self.config.game.has_legal_moves
                    ).item() (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==agent:[105:173]
==pacman:[1549:1617]
    def preprocess(self, states) -> torch.Tensor:
        """Applies necessary preprocessing steps to a batch of environment observations or a single environment observation
        Does not alter the input state parameter, instead creating a new Tensor on the inputted device (default cpu)

        Args:
            state (Any): A or a list of state returned from self.env.step
        Returns:
            Tensor: The preprocessed state, a tensor of floats. If the input was a single environment step,
                    the returned tensor is returned as outputed as if a batch of states with a length of a batch size of 1
        """

        # always convert to np.array first for performance, recoommnded by pytorchx
        # special case: list of compressed images (which are LazyFrames)
        if isinstance(states[0], gym.wrappers.frame_stack.LazyFrames):
            np_states = np.array([np.array(state) for state in states])
        else:
            # single observation, could be compressed or not compressed
            # print("Single state")
            np_states = np.array(states)

        # print("Numpyified States", np_states)
        prepared_state = (
            torch.from_numpy(
                np_states,
            )
            .to(torch.float32)
            .to(self.device)
        )
        # if self.config.game.is_image:
        # normalize_images(prepared_state)

        # if the state is a single number, add a dimension (not the batch dimension!, just wrapping it in []s basically)
        if prepared_state.shape == torch.Size([]):
            prepared_state = prepared_state.unsqueeze(0)

        if prepared_state.shape == self.observation_dimensions:
            prepared_state = make_stack(prepared_state)
        return prepared_state

    def predict(
        self, state: torch.Tensor, *args
    ) -> torch.Tensor:  # args is for info for player counts or legal move masks
        """Run inference on 1 or a batch of environment states, applying necessary preprocessing steps

        Returns:
            Tensor: The predicted values, e.g. Q values for DQN or Q distributions for Categorical DQN
        """
        raise NotImplementedError

    def select_actions(self, predicted, info, mask_actions=False) -> torch.Tensor:
        """Return actions determined from the model output, appling postprocessing steps such as masking beforehand

        Args:
            state (_type_): _description_
            legal_moves (_type_, optional): _description_. Defaults to None.

        Raises:
            NotImplementedError: _description_

        Returns:
            Tensor: _description_
        """
        raise NotImplementedError

    def learn(self):
        # raise NotImplementedError, "Every agent should have a learn method. (Previously experience_replay)"
        pass
 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rainbow.rainbow_network:[70:95]
==rl-research.ppo.ppo_network:[45:70]
            self.conv_layers = Conv2dStack(
                input_shape=input_shape,
                filters=filters,
                kernel_sizes=kernel_sizes,
                strides=strides,
                activation=self.config.activation,
                noisy_sigma=config.noisy_sigma,
            )
            current_shape = (
                B,
                self.conv_layers.output_channels,
                current_shape[2],
                current_shape[3],
            )

        if self.has_dense_layers:
            if len(current_shape) == 4:
                initial_width = current_shape[1] * current_shape[2] * current_shape[3]
            else:
                assert len(current_shape) == 2
                initial_width = current_shape[1]

            # (B, width_in) -> (B, width_out)
            self.dense_layers = DenseStack(
                initial_width=initial_width, (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==a2c_network:[59:84]
==rl-research.alphazero.alphazero_network:[68:93]
            self.conv_layers = Conv2dStack(
                input_shape=input_shape,
                filters=filters,
                kernel_sizes=kernel_sizes,
                strides=strides,
                activation=self.config.activation,
                noisy_sigma=config.noisy_sigma,
            )
            current_shape = (
                B,
                self.conv_layers.output_channels,
                current_shape[2],
                current_shape[3],
            )

        if self.has_dense_layers:
            if len(current_shape) == 4:
                initial_width = current_shape[1] * current_shape[2] * current_shape[3]
            else:
                assert len(current_shape) == 2
                initial_width = current_shape[1]

            # (B, width_in) -> (B, width_out)
            self.dense_layers = DenseStack(
                initial_width=initial_width, (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[279:305]
==utils.utils.utils:[195:221]
    has_target_model_updates = "target_model_updated" in values[0]
    has_model_updates = "model_updated" in values[0]

    if has_target_model_updates:
        weight_updates = [value["target_model_updated"] for value in values]
        for i, weight_update in enumerate(weight_updates):
            if weight_update:
                axs[row][col].axvline(
                    x=i,
                    color="black",
                    linestyle="dotted",
                    # label="Target Model Weight Update",
                )

    if has_model_updates:
        weight_updates = [value["model_updated"] for value in values]
        for i, weight_update in enumerate(weight_updates):
            if weight_update:
                axs[row][col].axvline(
                    x=i,
                    color="gray",
                    linestyle="dotted",
                    # label="Model Weight Update",
                )

    axs[row][col].set_title( (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[219:245]
==utils.utils.utils:[255:281]
    has_target_model_updates = "target_model_updated" in values[0]
    has_model_updates = "model_updated" in values[0]

    if has_target_model_updates:
        weight_updates = [value["target_model_updated"] for value in values]
        for i, weight_update in enumerate(weight_updates):
            if weight_update:
                axs[row][col].axvline(
                    x=i,
                    color="black",
                    linestyle="dotted",
                    # label="Target Model Weight Update",
                )

    if has_model_updates:
        weight_updates = [value["model_updated"] for value in values]
        for i, weight_update in enumerate(weight_updates):
            if weight_update:
                axs[row][col].axvline(
                    x=i,
                    color="gray",
                    linestyle="dotted",
                    # label="Model Weight Update",
                )

    axs[row][col].set_title( (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[340:365]
==utils.utils.utils:[195:220]
    has_target_model_updates = "target_model_updated" in values[0]
    has_model_updates = "model_updated" in values[0]

    if has_target_model_updates:
        weight_updates = [value["target_model_updated"] for value in values]
        for i, weight_update in enumerate(weight_updates):
            if weight_update:
                axs[row][col].axvline(
                    x=i,
                    color="black",
                    linestyle="dotted",
                    # label="Target Model Weight Update",
                )

    if has_model_updates:
        weight_updates = [value["model_updated"] for value in values]
        for i, weight_update in enumerate(weight_updates):
            if weight_update:
                axs[row][col].axvline(
                    x=i,
                    color="gray",
                    linestyle="dotted",
                    # label="Model Weight Update",
                )
 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[219:244]
==utils.utils.utils:[316:341]
    has_target_model_updates = "target_model_updated" in values[0]
    has_model_updates = "model_updated" in values[0]

    if has_target_model_updates:
        weight_updates = [value["target_model_updated"] for value in values]
        for i, weight_update in enumerate(weight_updates):
            if weight_update:
                axs[row][col].axvline(
                    x=i,
                    color="black",
                    linestyle="dotted",
                    # label="Target Model Weight Update",
                )

    if has_model_updates:
        weight_updates = [value["model_updated"] for value in values]
        for i, weight_update in enumerate(weight_updates):
            if weight_update:
                axs[row][col].axvline(
                    x=i,
                    color="gray",
                    linestyle="dotted",
                    # label="Model Weight Update",
                )
 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.custom_gym_envs.custom_gym_envs.envs.checkers:[496:523]
==rl-research.custom_gym_envs.custom_gym_envs.envs.connect4:[185:212]
            pygame.draw.line(
                canvas,
                (0, 0, 0),
                (j * pix_square_size, 0),
                (j * pix_square_size, self.window_size[1]),
            )

        if self.render_mode == "human":
            # The following line copies our drawings from `canvas` to the visible window
            self.window.blit(canvas, canvas.get_rect())
            pygame.event.pump()
            pygame.display.update()

            # We need to ensure that human-rendering occurs at the predefined framerate.
            # The following line will automatically add a delay to keep the framerate stable.
            self.clock.tick(self.metadata["render_fps"])
        else:  # rgb_array
            return np.transpose(
                np.array(pygame.surfarray.pixels3d(canvas)), axes=(1, 0, 2)
            )

    def close(self):
        if self.window is not None:
            pygame.display.quit()
            pygame.quit()

    def winner(self): (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.muzero.muzero_network:[554:573]
==rl-research.ppo.ppo_network:[45:64]
            self.conv_layers = Conv2dStack(
                input_shape=input_shape,
                filters=filters,
                kernel_sizes=kernel_sizes,
                strides=strides,
                activation=self.config.activation,
                noisy_sigma=config.noisy_sigma,
            )
            current_shape = (
                B,
                self.conv_layers.output_channels,
                current_shape[2],
                current_shape[3],
            )

        if self.has_dense_layers:
            if len(current_shape) == 4:
                initial_width = current_shape[1] * current_shape[2] * current_shape[3]
            else: (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rainbow.rainbow_network:[70:89]
==rl-research.ppo.ppo_network:[141:160]
            self.conv_layers = Conv2dStack(
                input_shape=input_shape,
                filters=filters,
                kernel_sizes=kernel_sizes,
                strides=strides,
                activation=self.config.activation,
                noisy_sigma=config.noisy_sigma,
            )
            current_shape = (
                B,
                self.conv_layers.output_channels,
                current_shape[2],
                current_shape[3],
            )

        if self.has_dense_layers:
            if len(current_shape) == 4:
                initial_width = current_shape[1] * current_shape[2] * current_shape[3]
            else: (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rainbow.rainbow_network:[48:67]
==rl-research.muzero.muzero_network:[197:216]
            self.residual_layers = ResidualStack(
                input_shape=input_shape,
                filters=filters,
                kernel_sizes=kernel_sizes,
                strides=strides,
                activation=self.config.activation,
                noisy_sigma=config.noisy_sigma,
            )
            current_shape = (
                B,
                self.residual_layers.output_channels,
                current_shape[2],
                current_shape[3],
            )

        if self.has_conv_layers:
            assert (
                len(input_shape) == 4
            ), "Input shape should be (B, C, H, W), got {}".format(input_shape) (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[3812:3835]
==rainbow.rainbow_agent:[355:378]
                action = self.env.action_space.sample()
                next_state, reward, terminated, truncated, next_info = self.env.step(
                    action
                )
                done = terminated or truncated
                # print(state)
                self.replay_buffer.store(
                    state, info, action, reward, next_state, next_info, done
                )
                # print(self.replay_buffer.observation_buffer[0])
                state = next_state
                info = next_info
                if done:
                    state, info = self.env.reset()
                # gc.collect()

    def update_target_model(self):
        if self.config.soft_update:
            for wt, wp in zip(self.target_model.parameters(), self.model.parameters()):
                wt.copy_(self.config.ema_beta * wt + (1 - self.config.ema_beta) * wp)
        else:
            self.target_model.load_state_dict(self.model.state_dict())
 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.alphazero.alphazero_network:[46:65]
==rl-research.muzero.muzero_network:[49:68]
            self.residual_layers = ResidualStack(
                input_shape=input_shape,
                filters=filters,
                kernel_sizes=kernel_sizes,
                strides=strides,
                activation=self.config.activation,
                noisy_sigma=config.noisy_sigma,
            )
            current_shape = (
                B,
                self.residual_layers.output_channels,
                current_shape[2],
                current_shape[3],
            )

        if self.has_conv_layers:
            assert (
                len(input_shape) == 4
            ), "Input shape should be (B, C, H, W), got {}".format(input_shape) (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==a2c_network:[279:298]
==rl-research.alphazero.alphazero_network:[159:178]
            self.conv_layers = Conv2dStack(
                input_shape=input_shape,
                filters=filters,
                kernel_sizes=kernel_sizes,
                strides=strides,
                activation=self.config.activation,
                noisy_sigma=config.noisy_sigma,
            )
            current_shape = (
                B,
                self.conv_layers.output_channels,
                current_shape[2],
                current_shape[3],
            )

        if self.has_dense_layers:
            if len(current_shape) == 4:
                initial_width = current_shape[1] * current_shape[2] * current_shape[3]
            else: (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==a2c_network:[155:174]
==rl-research.alphazero.alphazero_network:[68:87]
            self.conv_layers = Conv2dStack(
                input_shape=input_shape,
                filters=filters,
                kernel_sizes=kernel_sizes,
                strides=strides,
                activation=self.config.activation,
                noisy_sigma=config.noisy_sigma,
            )
            current_shape = (
                B,
                self.conv_layers.output_channels,
                current_shape[2],
                current_shape[3],
            )

        if self.has_dense_layers:
            if len(current_shape) == 4:
                initial_width = current_shape[1] * current_shape[2] * current_shape[3]
            else: (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==a2c_network:[59:78]
==rl-research.alphazero.alphazero_network:[257:276]
            self.conv_layers = Conv2dStack(
                input_shape=input_shape,
                filters=filters,
                kernel_sizes=kernel_sizes,
                strides=strides,
                activation=self.config.activation,
                noisy_sigma=config.noisy_sigma,
            )
            current_shape = (
                B,
                self.conv_layers.output_channels,
                current_shape[2],
                current_shape[3],
            )

        if self.has_dense_layers:
            if len(current_shape) == 4:
                initial_width = current_shape[1] * current_shape[2] * current_shape[3]
            else: (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[3568:3595]
==rainbow.rainbow_agent:[101:128]
        )

        # could use a MuZero min-max config and just constantly update the suport size (would this break the model?)
        # self.v_min = self.config.v_min
        # self.v_max = self.config.v_max

        self.support = torch.linspace(
            self.config.v_min,
            self.config.v_max,
            self.config.atom_size,
            device=device,
        ).to(device)
        """row vector Tensor(atom_size)
        """

        self.eg_epsilon = self.config.eg_epsilon

        self.stats = {
            "score": [],
            "loss": [],
            "test_score": [],
        }
        self.targets = {
            "score": self.env.spec.reward_threshold,
            "test_score": self.env.spec.reward_threshold,
        }
 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==ape_x.hyperopt_local:[20:43]
==ape_x.hyperparameter_optimization:[20:43]
def recv_stop_msg(msg):
    global stop_chan
    stop_chan.put(msg)


import logging

logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)
fh = logging.FileHandler("hyperopt.log", mode="w")
ch = logging.StreamHandler()
ch.setFormatter(logging.Formatter("%(message)s"))

logger.addHandler(fh)
logger.addHandler(ch)

logging.basicConfig(
    level=logging.DEBUG,
    handlers=[fh, ch],
    format="%(asctime)s %(name)s %(threadName)s %(levelname)s: %(message)s",
)

 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==dqn_config:[8:31]
==noisy_dqn_config:[7:30]
        self.deuling: bool = False

        self.soft_update: bool = False
        self.transfer_interval: int = 1
        self.per_alpha: float = 0
        self.per_beta: float = 0
        self.per_epsilon: float = 0
        self.n_step: int = 1
        self.atom_size: int = 1

        assert not (
            self.game.is_image and len(self.conv_layers) == 0
        ), "Convolutional layers must be defined for image based games"

        # maybe don't use a game config, since if tuning for multiple games this should be the same regardless of the game <- (it is really a hyper parameter if you are tuning for multiple games or a game with unknown bounds)

        # could use a MuZero min-max config and just constantly update the suport size (would this break the model?) <- might mean this is not in the config but just a part of the model

        self.v_min = game_config.min_score
        self.v_max = game_config.max_score

    def _verify_game(self):
        assert self.game.is_discrete, "Rainbow only supports discrete action spaces" (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[3499:3515]
==rainbow.rainbow_agent:[32:48]
class RainbowAgent(BaseAgent):
    def __init__(
        self,
        env,
        config: RainbowConfig,
        name=f"rainbow_{current_timestamp():.1f}",
        device: torch.device = (
            torch.device("cuda")
            if torch.cuda.is_available()
            # MPS is sometimes useful for M2 instances, but only for large models/matrix multiplications otherwise CPU is faster
            else (
                torch.device("mps")
                if torch.backends.mps.is_available() and torch.backends.mps.is_built()
                else torch.device("cpu")
            )
        ), (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==ape_x.hyperopt_local:[112:128]
==ape_x.hyperparameter_optimization:[121:136]
        learner.run()
        logger.info("Training complete")
        loss = -learner.test(num_trials=10, step=0)["score"]
        return {"status": STATUS_OK, "loss": loss}
    except KeyboardInterrupt:
        logger.info("learner interrupted, cleaning up")
        loss = -learner.test(num_trials=10, step=0)["score"]
        return {"status": STATUS_OK, "loss": loss}
    except Exception as e:
        logger.exception(f"learner failed due to error {e}")
        return {
            "status": STATUS_FAIL,
            "loss": 100000,
        }  # make this high since some games have negative rewards (mountain car and acrobot) and 0 would actually be a perfect score
    finally: (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.custom_gym_envs.custom_gym_envs.envs.grid_world:[101:120]
==rl-research.custom_gym_envs.custom_gym_envs.envs.tictactoe:[132:151]
    def render(self):
        if self.render_mode == "rgb_array":
            return self._render_frame()

    def _render_frame(self):
        if self.window is None and self.render_mode == "human":
            pygame.init()
            pygame.display.init()
            self.window = pygame.display.set_mode((self.window_size, self.window_size))
        if self.clock is None and self.render_mode == "human":
            self.clock = pygame.time.Clock()

        canvas = pygame.Surface((self.window_size, self.window_size))
        canvas.fill((255, 255, 255))
        pix_square_size = (
            self.window_size / self.size
        )  # The size of a single grid square in pixels

        # First we draw the target (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.custom_gym_envs.custom_gym_envs.envs.checkers:[501:523]
==rl-research.custom_gym_envs.custom_gym_envs.envs.tictactoe:[196:218]
            )

        if self.render_mode == "human":
            # The following line copies our drawings from `canvas` to the visible window
            self.window.blit(canvas, canvas.get_rect())
            pygame.event.pump()
            pygame.display.update()

            # We need to ensure that human-rendering occurs at the predefined framerate.
            # The following line will automatically add a delay to keep the framerate stable.
            self.clock.tick(self.metadata["render_fps"])
        else:  # rgb_array
            return np.transpose(
                np.array(pygame.surfarray.pixels3d(canvas)), axes=(1, 0, 2)
            )

    def close(self):
        if self.window is not None:
            pygame.display.quit()
            pygame.quit()

    def winner(self): (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==agent:[24:40]
==pacman:[1482:1498]
class BaseAgent:
    def __init__(
        self,
        env: gym.Env,
        config: Config,
        name,
        device: torch.device = (
            torch.device("cuda")
            if torch.cuda.is_available()
            # MPS is sometimes useful for M2 instances, but only for large models/matrix multiplications otherwise CPU is faster
            else (
                torch.device("mps")
                if torch.backends.mps.is_available() and torch.backends.mps.is_built()
                else torch.device("cpu")
            )
        ), (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rainbow.rainbow_agent:[70:86]
==rl-research.alphazero.alphazero_agent:[64:80]
        if self.config.optimizer == Adam:
            self.optimizer: torch.optim.Optimizer = self.config.optimizer(
                params=self.model.parameters(),
                lr=self.config.learning_rate,
                eps=self.config.adam_epsilon,
                weight_decay=self.config.weight_decay,
            )
        elif self.config.optimizer == SGD:
            print("Warning: SGD does not use adam_epsilon param")
            self.optimizer: torch.optim.Optimizer = self.config.optimizer(
                params=self.model.parameters(),
                lr=self.config.learning_rate,
                momentum=self.config.momentum,
                weight_decay=self.config.weight_decay,
            )
 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==a2c_network:[136:258]
==rl-research.ppo.ppo_network:[122:242]
        input_shape: Tuple[int],
        output_size: int,
        discrete: bool,
        *args,
        **kwargs
    ):
        super().__init__(*args, **kwargs)
        self.config = config
        self.has_conv_layers = len(config.actor_conv_layers) > 0
        self.has_dense_layers = len(config.actor_dense_layer_widths) > 0
        self.discrete = discrete

        current_shape = input_shape
        B = current_shape[0]
        if self.has_conv_layers:
            assert len(input_shape) == 4
            filters, kernel_sizes, strides = to_lists(config.actor_conv_layers)

            # (B, C_in, H, W) -> (B, C_out H, W)
            self.conv_layers = Conv2dStack(
                input_shape=input_shape,
                filters=filters,
                kernel_sizes=kernel_sizes,
                strides=strides,
                activation=self.config.activation,
                noisy_sigma=config.noisy_sigma,
            )
            current_shape = (
                B,
                self.conv_layers.output_channels,
                current_shape[2],
                current_shape[3],
            )

        if self.has_dense_layers:
            if len(current_shape) == 4:
                initial_width = current_shape[1] * current_shape[2] * current_shape[3]
            else:
                assert (
                    len(current_shape) == 2
                ), "Input shape should be (B, width), got {}".format(current_shape)
                initial_width = current_shape[1]

            # (B, width_in) -> (B, width_out)
            self.dense_layers = DenseStack(
                initial_width=initial_width,
                widths=self.config.actor_dense_layer_widths,
                activation=self.config.activation,
                noisy_sigma=self.config.noisy_sigma,
            )
            current_shape = (
                B,
                self.dense_layers.output_width,
            )

        if len(current_shape) == 4:
            initial_width = current_shape[1] * current_shape[2] * current_shape[3]
        else:
            assert len(current_shape) == 2
            initial_width = current_shape[1]

        if self.discrete:
            self.actions = build_dense(
                in_features=initial_width,
                out_features=output_size,
                sigma=self.config.noisy_sigma,
            )
        else:
            self.mean = build_dense(
                in_features=initial_width,
                out_features=output_size,
                sigma=self.config.noisy_sigma,
            )

            self.std = build_dense(
                in_features=initial_width,
                out_features=output_size,
                sigma=self.config.noisy_sigma,
            )

    def initialize(self, initializer: Callable[[Tensor], None]) -> None:
        if self.has_conv_layers:
            self.conv_layers.initialize(initializer)
        if self.has_dense_layers:
            self.dense_layers.initialize(initializer)
        if self.discrete:
            self.actions.initialize(
                initializer
            )  # OUTPUT LAYER TO IMPLIMENT INTIALIZING WITH CONSTANT OF 0.01
        else:
            self.mean.initialize(initializer)  # OUTPUT LAYER
            self.std.initialize(initializer)  # OUTPUT LAYER

    def forward(self, inputs: Tensor):
        if self.has_conv_layers:
            assert inputs.dim() == 4

        x = inputs
        if self.has_conv_layers:
            x = self.conv_layers(x)
        if self.has_dense_layers:
            x = self.dense_layers(x)
        if self.discrete:
            actions = self.actions(x)
            return actions.softmax(dim=-1)
        else:
            mean = self.mean(x).tanh(dim=-1)
            std = self.std(x).softplus(dim=-1)
            return mean, std

    def reset_noise(self):
        if self.has_conv_layers:
            self.conv_layers.reset_noise()
        if self.has_dense_layers:
            self.dense_layers.reset_noise()
        if self.discrete:
            self.actions.reset_noise()
        else:
            self.mean.reset_noise()
            self.std.reset_noise() (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==can_test:[123:137]
==healers:[26:40]
                torch.tensor([0.8, 0], device=device, dtype=torch.float32),
                torch.tensor(
                    [0.8 * math.cos(torch.pi / 5), 0.8 * math.sin(torch.pi / 5)],
                    device=device,
                    dtype=torch.float32,
                ),
                torch.tensor(
                    [
                        0.8 * math.cos(torch.pi / 2 - math.pi / 5),
                        0.8 * math.sin(torch.pi / 2 - math.pi / 5),
                    ],
                    device=device,
                    dtype=torch.float32,
                ), (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[2201:2216]
==rl-research.replay_buffers.n_step_replay_buffer:[24:39]
            max_size=max_size,
            batch_size=batch_size,
            compressed_observations=compressed_observations,
        )

    def store(
        self,
        observation,
        info: dict,
        action,
        reward: float,
        next_observation,
        next_info: dict,
        done: bool,
        id=None, (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[2398:2413]
==rl-research.replay_buffers.base_replay_buffer:[129:144]
            max_size=max_size,
            batch_size=batch_size,
            compressed_observations=compressed_observations,
        )

    def store(
        self,
        observation,
        info: dict,
        action,
        reward: float,
        next_observation,
        next_info: dict,
        done: bool,
        id=None, (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[3836:3851]
==rainbow.rainbow_agent:[379:394]
        if self.config.eg_epsilon_decay_type == "linear":
            # print("decaying eg epsilon linearly")
            self.eg_epsilon = update_linear_schedule(
                self.config.eg_epsilon_final,
                self.config.eg_epsilon_final_step,
                self.config.eg_epsilon,
                training_step,
            )
        elif self.config.eg_epsilon_decay_type == "inverse_sqrt":
            self.eg_epsilon = update_inverse_sqrt_schedule(
                self.config.eg_epsilon,
                training_step,
            )
        else:
            raise ValueError( (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==ape_x.learner:[516:532]
==rainbow.rainbow_agent:[256:273]
        loss = elementwise_loss * weights_cuda
        self.optimizer.zero_grad()
        loss.mean().backward()
        if self.config.clipnorm > 0:
            # print("clipnorm", self.config.clipnorm)
            clip_grad_norm_(self.model.parameters(), self.config.clipnorm)

        self.optimizer.step()
        self.update_replay_priorities(
            samples=samples,
            priorities=elementwise_loss.detach().to("cpu").numpy()
            + self.config.per_epsilon,
        )
        self.model.reset_noise()
        self.target_model.reset_noise()
        return loss.detach().to("cpu").mean().item() (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.custom_gym_envs.custom_gym_envs.envs.checkers:[501:522]
==rl-research.custom_gym_envs.custom_gym_envs.envs.grid_world:[151:171]
            )

        if self.render_mode == "human":
            # The following line copies our drawings from `canvas` to the visible window
            self.window.blit(canvas, canvas.get_rect())
            pygame.event.pump()
            pygame.display.update()

            # We need to ensure that human-rendering occurs at the predefined framerate.
            # The following line will automatically add a delay to keep the framerate stable.
            self.clock.tick(self.metadata["render_fps"])
        else:  # rgb_array
            return np.transpose(
                np.array(pygame.surfarray.pixels3d(canvas)), axes=(1, 0, 2)
            )

    def close(self):
        if self.window is not None:
            pygame.display.quit()
            pygame.quit() (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.custom_gym_envs.custom_gym_envs.envs.armed_bandits:[25:45]
==rl-research.custom_gym_envs.custom_gym_envs.envs.nonstationary_armed_bandits:[28:48]
        assert render_mode is None

    def _get_obs(self):
        return 0

    def _get_info(self):
        return {}

    def reset(self, seed=None, options=None):
        # We need the following line to seed self.np_random
        super().reset(seed=seed)  # might not set tfp seed

        self.current_step = 0
        observation = self._get_obs()
        info = self._get_info()
        return observation, info

    def step(self, action):
        self.current_step += 1
        reward = np.random.normal(self.means[action], self.std_devs[action]) (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==agent:[355:376]
==pacman:[1779:1801]
                    )
                    # self.test_env.render()
                    done = terminated or truncated
                    state = next_state
                    score += reward[0] if isinstance(reward, list) else reward
                average_score += score
                max_score = max(max_score, score)
                min_score = min(min_score, score)
                print("score: ", score)

            # reset
            # if self.test_env.render_mode != "rgb_array":
            #     self.test_env.render()
            # self.test_env.close()
            average_score /= num_trials
            return {
                "score": average_score,
                "max_score": max_score,
                "min_score": min_score,
            }
 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==a2c_agent:[141:159]
==rl-research.ppo.ppo_agent:[128:142]
        value = self.model.critic(inputs=state_input)
        if self.discrete_action_space:
            policy = self.model.actor(inputs=state_input)[0]
            if mask_actions:
                legal_moves = get_legal_moves(info)
                policy = action_mask(
                    policy, legal_moves, mask_value=0, device=self.device
                )
                policy = clip_low_prob_actions(policy, self.config.clip_low_prob)
                policy = normalize_policies(policy)
            distribution = torch.distributions.Categorical(probs=policy)
        else:
            mean, std = self.model.actor(inputs=state_input)
            distribution = torch.distributions.Normal(mean, std) (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==game_configs.game_configs.atari_config:[3:16]
==pacman:[1801:1816]
class AtariConfig(GameConfig):
    def __init__(self):
        super(AtariConfig, self).__init__(
            max_score=10,  # FROM CATEGORICAL DQN PAPER
            min_score=-10,
            is_discrete=True,
            is_image=True,
            is_deterministic=False,  # if no frameskip, then deterministic
            has_legal_moves=False,
            perfect_information=True,  # although it is not deterministic, it is so close to it that it is considered perfect information
            multi_agent=False,
            num_players=1,
        ) (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.custom_gym_envs.custom_gym_envs.envs.connect4:[113:139]
==rl-research.custom_gym_envs.custom_gym_envs.envs.tictactoe:[115:140]
        terminated = self.winner()
        truncated = len(self._legal_moves) == 0
        if terminated:
            if self._current_player == 0:
                reward = [-1, 1]
            else:
                reward = [1, -1]
        else:
            reward = [0, 0]

        observation = self._get_obs()
        info = self._get_info()

        if self.render_mode == "human":
            self._render_frame()

        return observation, reward, terminated, truncated, info

    def render(self):
        if self.render_mode == "rgb_array":
            return self._render_frame()

    def _render_frame(self):
        if self.window is None and self.render_mode == "human":
            pygame.init()
            pygame.display.init() (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.custom_gym_envs.custom_gym_envs.envs.checkers:[503:522]
==rl-research.custom_gym_envs.custom_gym_envs.envs.mississippi_marbles:[709:727]
        if self.render_mode == "human":
            # The following line copies our drawings from `canvas` to the visible window
            self.window.blit(canvas, canvas.get_rect())
            pygame.event.pump()
            pygame.display.update()

            # We need to ensure that human-rendering occurs at the predefined framerate.
            # The following line will automatically add a delay to keep the framerate stable.
            self.clock.tick(self.metadata["render_fps"])
        else:  # rgb_array
            return np.transpose(
                np.array(pygame.surfarray.pixels3d(canvas)), axes=(1, 0, 2)
            )

    def close(self):
        if self.window is not None:
            pygame.display.quit()
            pygame.quit()
 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==dueling_dqn_config:[17:36]
==noisy_dqn_config:[11:30]
        self.per_alpha: float = 0
        self.per_beta: float = 0
        self.per_epsilon: float = 0
        self.n_step: int = 1
        self.atom_size: int = 1

        assert not (
            self.game.is_image and len(self.conv_layers) == 0
        ), "Convolutional layers must be defined for image based games"

        # maybe don't use a game config, since if tuning for multiple games this should be the same regardless of the game <- (it is really a hyper parameter if you are tuning for multiple games or a game with unknown bounds)

        # could use a MuZero min-max config and just constantly update the suport size (would this break the model?) <- might mean this is not in the config but just a part of the model

        self.v_min = game_config.min_score
        self.v_max = game_config.max_score

    def _verify_game(self):
        assert self.game.is_discrete, "Rainbow only supports discrete action spaces" (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==double_dqn_config:[10:29]
==dqn_config:[12:31]
        self.per_alpha: float = 0
        self.per_beta: float = 0
        self.per_epsilon: float = 0
        self.n_step: int = 1
        self.atom_size: int = 1

        assert not (
            self.game.is_image and len(self.conv_layers) == 0
        ), "Convolutional layers must be defined for image based games"

        # maybe don't use a game config, since if tuning for multiple games this should be the same regardless of the game <- (it is really a hyper parameter if you are tuning for multiple games or a game with unknown bounds)

        # could use a MuZero min-max config and just constantly update the suport size (would this break the model?) <- might mean this is not in the config but just a part of the model

        self.v_min = game_config.min_score
        self.v_max = game_config.max_score

    def _verify_game(self):
        assert self.game.is_discrete, "Rainbow only supports discrete action spaces" (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[2336:2348]
==rl-research.replay_buffers.base_replay_buffer:[158:171]
    def clear(self):
        if self.compressed_observations:
            self.observation_buffer = np.zeros(self.max_size, dtype=np.object_)
            self.next_observation_buffer = np.zeros(self.max_size, dtype=np.object_)
        else:
            observation_buffer_shape = (self.max_size,) + self.observation_dimensions
            self.observation_buffer = np.zeros(
                observation_buffer_shape, self.observation_dtype
            )
            self.next_observation_buffer = np.zeros(
                observation_buffer_shape, dtype=self.observation_dtype
            )
 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[2230:2243]
==rl-research.replay_buffers.base_replay_buffer:[264:276]
    def clear(self):
        if self.compressed_observations:
            self.observation_buffer = np.zeros(self.max_size, dtype=np.object_)
            self.next_observation_buffer = np.zeros(self.max_size, dtype=np.object_)
        else:
            observation_buffer_shape = (self.max_size,) + self.observation_dimensions
            self.observation_buffer = np.zeros(
                observation_buffer_shape, self.observation_dtype
            )
            self.next_observation_buffer = np.zeros(
                observation_buffer_shape, dtype=self.observation_dtype
            )
 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==B:[59:72]
==ape_x.remote_worker:[79:92]
    try:
        rpc.init_rpc(
            name=args.name,
            rank=args.rank,
            world_size=args.world_size,
            rpc_backend_options=options,
        )
    except Exception as e:
        logger.exception(f"[{args.name}] error initializing rpc: {e}")
    logger.info(f"[{args.name}] rpc initialized.")

    logger.info("waiting for stop signal")
    stop_chan.get() (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==ape_x.learner:[340:353]
==classes:[208:222]
                ).then(
                    lambda x: logger.info(
                        f"online model succesfully updated in {time.time() - t} s"
                    )
                )
                return
            except Exception as e:
                logger.exception(
                    f"try {attempt+1} of {attempts}: error setting weights: {e}"
                )
                time.sleep(1)
        logger.info(f"failed to store weights after {attempts} tries")

 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==a2c_network:[85:99]
==rl-research.imitation_learning.supervised_network:[83:97]
                activation=self.config.activation,
                noisy_sigma=self.config.noisy_sigma,
            )
            current_shape = (
                B,
                self.dense_layers.output_width,
            )

        if len(current_shape) == 4:
            initial_width = current_shape[1] * current_shape[2] * current_shape[3]
        else:
            assert len(current_shape) == 2
            initial_width = current_shape[1]
 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.muzero.muzero_network:[582:597]
==rl-research.ppo.ppo_network:[71:85]
                activation=self.config.activation,
                noisy_sigma=self.config.noisy_sigma,
            )
            current_shape = (
                B,
                self.dense_layers.output_width,
            )

        if len(current_shape) == 4:
            initial_width = current_shape[1] * current_shape[2] * current_shape[3]
        else:
            assert len(current_shape) == 2
            initial_width = current_shape[1]
 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rainbow.rainbow_agent:[38:50]
==rl-research.imitation_learning.policy_imitation_agent:[17:29]
        device: torch.device = (
            torch.device("cuda")
            if torch.cuda.is_available()
            # MPS is sometimes useful for M2 instances, but only for large models/matrix multiplications otherwise CPU is faster
            else (
                torch.device("mps")
                if torch.backends.mps.is_available() and torch.backends.mps.is_built()
                else torch.device("cpu")
            )
        ),
        from_checkpoint=False,
    ): (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[3867:3881]
==rainbow.rainbow_agent:[410:424]
            with torch.no_grad():
                for _ in range(self.config.replay_interval):
                    values = self.predict(state)
                    # print(values)
                    action = epsilon_greedy_policy(
                        values,
                        info,
                        self.eg_epsilon,
                        wrapper=lambda values, info: self.select_actions(
                            values, info
                        ).item(),
                    )
                    # print("Action", action)
                    # print("Epislon Greedy Epsilon", self.eg_epsilon) (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==ape_x.actor:[27:42]
==classes:[222:237]
from replay_buffers.n_step_replay_buffer import NStepReplayBuffer


class Batch(NamedTuple):
    observations: np.ndarray
    infos: np.ndarray
    actions: np.ndarray
    rewards: np.ndarray
    next_observations: np.ndarray
    next_infos: np.ndarray
    dones: np.ndarray
    ids: np.ndarray
    priorities: np.ndarray

 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.custom_gym_envs.custom_gym_envs.envs.connect4:[53:71]
==rl-research.custom_gym_envs.custom_gym_envs.envs.tictactoe:[60:78]
        self._grid[2, :, :] = 0  # It's player 1's turn
        self._current_player = 0

        self._step_count = 0

        # Reset legal moves
        self._legal_moves = np.array(list(range(self.action_space.n)))

        observation = self._get_obs()
        info = self._get_info()

        if self.render_mode == "human":
            self._render_frame()

        return observation, info

    def step(self, action):
        illegal_move = False (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.alphazero.alphazero_network:[315:327]
==rl-research.muzero.muzero_network:[509:521]
    def forward(self, inputs: Tensor):
        if self.has_conv_layers:
            assert (
                inputs.dim() == 4
            ), "Input shape should be (B, C, H, W), got {}".format(inputs.shape)

        x = inputs
        if self.has_conv_layers:
            x = self.conv_layers(x)
        if self.has_dense_layers:
            x = x.flatten(1, -1)  # should this be batch, -1?
            x = self.dense_layers(x) (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.alphazero.alphazero_network:[212:224]
==rl-research.muzero.muzero_network:[612:624]
    def forward(self, inputs: Tensor):
        if self.has_conv_layers:
            assert (
                inputs.dim() == 4
            ), "Input shape should be (B, C, H, W), got {}".format(inputs.shape)

        x = inputs
        if self.has_conv_layers:
            x = self.conv_layers(x)
        if self.has_dense_layers:
            x = x.flatten(1, -1)  # should this be batch, -1?
            x = self.dense_layers(x) (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.alphazero.alphazero_network:[116:139]
==rl-research.muzero.muzero_network:[133:158]
    def forward(self, inputs: Tensor):
        if self.has_conv_layers:
            assert inputs.dim() == 4

        # (B, *)
        S = inputs
        # INPUT CONV LAYERS???

        # (B, C_in, H, W) -> (B, C_out, H, W)
        if self.has_residual_layers:
            S = self.residual_layers(S)

        # (B, C_in, H, W) -> (B, C_out, H, W)
        if self.has_conv_layers:
            S = self.conv_layers(S)

        # (B, *) -> (B, dense_features_in)

        # (B, dense_features_in) -> (B, dense_features_out)
        if self.has_dense_layers:
            S = S.flatten(1, -1)
            S = self.dense_layers(S)
 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.alphazero.alphazero_network:[11:25]
==rl-research.muzero.muzero_network:[12:26]
    def __init__(
        self,
        config: AlphaZeroConfig,
        output_size: int,
        input_shape: Tuple[int],
    ):
        assert (
            config.game.is_discrete
        ), "AlphaZero only works for discrete action space games (board games)"

        self.config = config

        super(Network, self).__init__()
 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==a2c_network:[307:322]
==rl-research.muzero.muzero_network:[482:496]
                activation=self.config.activation,
                noisy_sigma=self.config.noisy_sigma,
            )
            current_shape = (
                B,
                self.dense_layers.output_width,
            )

        if len(current_shape) == 4:
            initial_width = current_shape[1] * current_shape[2] * current_shape[3]
        else:
            assert len(current_shape) == 2
            initial_width = current_shape[1]

 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==a2c_network:[183:197]
==rl-research.alphazero.alphazero_network:[185:199]
                activation=self.config.activation,
                noisy_sigma=self.config.noisy_sigma,
            )
            current_shape = (
                B,
                self.dense_layers.output_width,
            )

        if len(current_shape) == 4:
            initial_width = current_shape[1] * current_shape[2] * current_shape[3]
        else:
            assert len(current_shape) == 2
            initial_width = current_shape[1]
 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==a2c_network:[85:99]
==rl-research.alphazero.alphazero_network:[285:300]
                activation=self.config.activation,
                noisy_sigma=self.config.noisy_sigma,
            )

            current_shape = (
                B,
                self.dense_layers.output_width,
            )

        if len(current_shape) == 4:
            initial_width = current_shape[1] * current_shape[2] * current_shape[3]
        else:
            assert len(current_shape) == 2
            initial_width = current_shape[1]
 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==a2c_agent:[32:44]
==agent:[30:42]
        device: torch.device = (
            torch.device("cuda")
            if torch.cuda.is_available()
            # MPS is sometimes useful for M2 instances, but only for large models/matrix multiplications otherwise CPU is faster
            else (
                torch.device("mps")
                if torch.backends.mps.is_available() and torch.backends.mps.is_built()
                else torch.device("cpu")
            )
        ),
        from_checkpoint=False,
    ): (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==game_configs.game_configs.connect4_config:[6:16]
==game_configs.game_configs.tictactoe_config:[6:16]
            max_score=1,
            min_score=-1,
            is_discrete=True,
            is_image=True,
            is_deterministic=True,
            has_legal_moves=True,
            perfect_information=True,
            multi_agent=True,
            num_players=2,
        ) (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.imitation_learning.supervised_network:[17:30]
==rl-research.muzero.muzero_network:[179:194]
        assert (
            self.has_conv_layers or self.has_dense_layers or self.has_residual_layers
        ), "At least one of the layers should be present."

        self.output_size = output_size

        current_shape = input_shape
        B = current_shape[0]

        if self.has_residual_layers:
            assert (
                len(input_shape) == 4
            ), "Input shape should be (B, C, H, W), got {}".format(input_shape) (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[2206:2216]
==rl-research.replay_buffers.prioritized_n_step_replay_buffer:[44:54]
    def store(
        self,
        observation,
        info: dict,
        action,
        reward: float,
        next_observation,
        next_info: dict,
        done: bool,
        id=None, (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[2507:2517]
==rl-research.replay_buffers.base_replay_buffer:[134:144]
    def store(
        self,
        observation,
        info: dict,
        action,
        reward: float,
        next_observation,
        next_info: dict,
        done: bool,
        id=None, (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==agent_configs.agent_configs.base_config:[126:138]
==pacman:[1458:1482]
    def _verify_game(self):
        raise NotImplementedError


def kernel_initializer_wrapper(x):
    if x is None:
        return x
    elif isinstance(x, str):
        return prepare_kernel_initializers(x)
    else:
        assert callable(x)
        return x (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.custom_gym_envs.custom_gym_envs.envs.checkers:[415:425]
==rl-research.custom_gym_envs.custom_gym_envs.envs.connect4:[154:164]
                    pygame.draw.circle(
                        canvas,
                        (255, 0, 0),
                        (
                            j * pix_square_size + pix_square_size // 2,
                            i * pix_square_size + pix_square_size // 2,
                        ),
                        pix_square_size // 3,
                        width=3,
                    ) (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.alphazero.alphazero_network:[28:43]
==rl-research.muzero.muzero_network:[29:44]
        assert (
            self.has_conv_layers or self.has_dense_layers or self.has_residual_layers
        ), "At least one of the layers should be present."

        self.output_size = output_size

        current_shape = input_shape
        B = current_shape[0]

        # INPUTS = CONV + BATCHNORM + maybe RELU?

        if self.has_residual_layers:
            assert (
                len(input_shape) == 4
            ), "Input shape should be (B, C, H, W), got {}".format(input_shape) (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==a2c_network:[183:194]
==pacman:[3326:3337]
                activation=self.config.activation,
                noisy_sigma=self.config.noisy_sigma,
            )
            current_shape = (
                B,
                self.dense_layers.output_width,
            )

        if len(current_shape) == 4:
            initial_width = current_shape[1] * current_shape[2] * current_shape[3]
        else: (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==a2c_network:[85:96]
==rainbow.rainbow_network:[96:107]
                activation=self.config.activation,
                noisy_sigma=self.config.noisy_sigma,
            )
            current_shape = (
                B,
                self.dense_layers.output_width,
            )

        if len(current_shape) == 4:
            initial_width = current_shape[1] * current_shape[2] * current_shape[3]
        else: (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==NFSP.nfsp_agent_clean:[61:72]
==a2c_agent:[32:43]
        device: torch.device = (
            torch.device("cuda")
            if torch.cuda.is_available()
            # MPS is sometimes useful for M2 instances, but only for large models/matrix multiplications otherwise CPU is faster
            else (
                torch.device("mps")
                if torch.backends.mps.is_available() and torch.backends.mps.is_built()
                else torch.device("cpu")
            )
        ),
        from_checkpoint=False, (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==game_configs.game_configs.tictactoe_config:[3:12]
==lib.tictactoe_config:[3:12]
class TicTacToeConfig(GameConfig):
    def __init__(self):
        super(TicTacToeConfig, self).__init__(
            max_score=1,
            min_score=-1,
            is_discrete=True,
            is_image=True,
            is_deterministic=True,
            has_legal_moves=True, (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==game_configs.game_configs.connect4_config:[3:12]
==lib.connect4_config:[3:12]
class Connect4Config(GameConfig):
    def __init__(self):
        super(Connect4Config, self).__init__(
            max_score=1,
            min_score=-1,
            is_discrete=True,
            is_image=True,
            is_deterministic=True,
            has_legal_moves=True, (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==game_configs.game_configs.cartpole_config:[3:12]
==lib.cartpole_config:[3:12]
class CartPoleConfig(GameConfig):
    def __init__(self):
        super(CartPoleConfig, self).__init__(
            max_score=500,
            min_score=0,
            is_discrete=True,
            is_image=False,
            is_deterministic=True,  # i think it is deterministic (pretty sure if you input the same actions the same thing will happen, it just has a random start state)
            has_legal_moves=False, (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==double_dqn_config:[13:29]
==per_dqn_config:[12:28]
        self.n_step: int = 1
        self.atom_size: int = 1

        assert not (
            self.game.is_image and len(self.conv_layers) == 0
        ), "Convolutional layers must be defined for image based games"

        # maybe don't use a game config, since if tuning for multiple games this should be the same regardless of the game <- (it is really a hyper parameter if you are tuning for multiple games or a game with unknown bounds)

        # could use a MuZero min-max config and just constantly update the suport size (would this break the model?) <- might mean this is not in the config but just a part of the model

        self.v_min = game_config.min_score
        self.v_max = game_config.max_score

    def _verify_game(self):
        assert self.game.is_discrete, "Rainbow only supports discrete action spaces" (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==agent_configs.agent_configs.a2c_config:[59:72]
==agent_configs.agent_configs.ppo_config:[74:86]
        self.critic_coefficient = self.parse_field("critic_coefficient", 0.5)

        self.clip_low_prob = self.parse_field("clip_low_prob", 0.00)


        assert not (
            self.game.is_image
            and self.actor_conv_layers is not None
            and self.critic_conv_layers is not None
        ), "Convolutional layers must be defined for image based games"

    def _verify_game(self):
        pass (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.muzero.muzero_network:[524:535]
==rl-research.ppo.ppo_network:[110:121]
    def reset_noise(self):
        if self.has_conv_layers:
            self.conv_layers.reset_noise()
        if self.has_dense_layers:
            self.dense_layers.reset_noise()
        self.value.reset_noise()


class ActorNetwork(nn.Module):
    def __init__(
        self, (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[2200:2210]
==rl-research.replay_buffers.nfsp_reservoir_buffer:[20:30]
        super().__init__(
            max_size=max_size,
            batch_size=batch_size,
            compressed_observations=compressed_observations,
        )

    def store(
        self,
        observation,
        info: dict, (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==lib.game_config:[0:9]
==pacman:[1301:1310]
class GameConfig:
    def __init__(
        self,
        max_score,
        min_score,
        is_discrete,
        is_image,
        is_deterministic,
        has_legal_moves, (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[2886:2912]
==residual:[62:88]
            x = self.activation(layer(x))
        return x

    def reset_noise(self):
        assert self.noisy

        # noisy not implemented

        # for layer in self.conv_layers:
        #     # layer.reset_noise()
        # return

    def remove_noise(self):
        assert self.noisy

        # noisy not implemented

        # for layer in self.conv_layers:
        #     # layer.reset_noise()
        # return

    @property
    def output_channels(self):
        return self._output_len

 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[2872:2885]
==residual:[48:61]
            current_input_channels = filters[i]

        self._output_len = current_input_channels

    def initialize(self, initializer: Callable[[Tensor], None]) -> None:
        def initialize_if_conv(m: nn.Module):
            if isinstance(m, nn.Conv2d):
                initializer(m.weight)

        self.apply(initialize_if_conv)

    def forward(self, inputs):
        x = inputs (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[2816:2829]
==residual:[7:20]
    def __init__(
        self,
        input_shape: tuple[int],
        filters: list[int],
        kernel_sizes: list[int | Tuple[int, int]],
        strides: list[int | Tuple[int, int]],
        activation: nn.Module = nn.ReLU(),
        noisy_sigma: float = 0,
    ):
        """A sequence of convolution layers with the activation function applied after each layer.
        Always applies the minimum zero-padding that ensures the output shape is equal to the input shape.
        Input shape in "BCHW" form, i.e. (batch_size, input_channels, height, width)
        """ (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==conv:[113:137]
==pacman:[3147:3173]
            x = self.activation(layer(x))
        return x

    def reset_noise(self):
        assert self.noisy

        # noisy not implemented

        # for layer in self.conv_layers:
        #     # layer.reset_noise()
        # return

    def remove_noise(self):
        assert self.noisy

        # noisy not implemented

        # for layer in self.conv_layers:
        #     # layer.reset_noise()
        # return

    @property
    def output_channels(self):
        return self._output_len

 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==conv:[99:112]
==pacman:[3133:3146]
            current_input_channels = filters[i]

        self._output_len = current_input_channels

    def initialize(self, initializer: Callable[[Tensor], None]) -> None:
        def initialize_if_conv(m: nn.Module):
            if isinstance(m, nn.Conv2d):
                initializer(m.weight)

        self.apply(initialize_if_conv)

    def forward(self, inputs):
        x = inputs (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==conv:[43:56]
==pacman:[3092:3105]
    def __init__(
        self,
        input_shape: tuple[int],
        filters: list[int],
        kernel_sizes: list[int | Tuple[int, int]],
        strides: list[int | Tuple[int, int]],
        activation: nn.Module = nn.ReLU(),
        noisy_sigma: float = 0,
    ):
        """A sequence of residual layers with the activation function applied after each layer.
        Always applies the minimum zero-padding that ensures the output shape is equal to the input shape.
        Input shape in "BCHW" form, i.e. (batch_size, input_channels, height, width)
        """ (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rainbow.rainbow_network:[71:80]
==rl-research.muzero.muzero_network:[344:353]
                input_shape=input_shape,
                filters=filters,
                kernel_sizes=kernel_sizes,
                strides=strides,
                activation=self.config.activation,
                noisy_sigma=config.noisy_sigma,
            )
            current_shape = (
                B, (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rainbow.rainbow_network:[152:162]
==rl-research.imitation_learning.supervised_network:[100:110]
                sigma=self.config.noisy_sigma,
            )

    def initialize(self, initializer: Callable[[Tensor], None]) -> None:
        if self.has_residual_layers:
            self.residual_layers.initialize(initializer)
        if self.has_conv_layers:
            self.conv_layers.initialize(initializer)
        if self.has_dense_layers:
            self.dense_layers.initialize(initializer) (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[3913:3925]
==rainbow.rainbow_agent:[456:468]
            for minibatch in range(self.config.num_minibatches):
                if len(self.replay_buffer) < self.config.min_replay_buffer_size:
                    break
                losses = self.learn()
                # print(losses)
                loss_mean = losses.mean()
                # could do things other than taking the mean here
                self.stats["loss"].append(
                    {"loss": loss_mean, "target_model_updated": target_model_updated[1]}
                )
                target_model_updated = (target_model_updated[0], False)
 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[3813:3824]
==rainbow.rainbow_agent:[424:434]
                    next_state, reward, terminated, truncated, next_info = self.env.step(
                        action
                    )
                    done = terminated or truncated
                    # print("State", state)
                    self.replay_buffer.store(
                        state, info, action, reward, next_state, next_info, done
                    )
                    state = next_state
                    info = next_info (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==NFSP.nfsp_agent_clean:[427:437]
==pacman:[1738:1748]
        plot_graphs(
            self.stats,
            self.targets,
            training_step,
            frames_seen,
            time_taken,
            self.model_name,
            f"{dir}/graphs",
        )
 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==ape_x.learner:[194:204]
==rainbow.rainbow_agent:[87:97]
                observation_dimensions=self.observation_dimensions,
                observation_dtype=self.env.observation_space.dtype,
                max_size=self.config.replay_buffer_size,
                batch_size=self.config.minibatch_size,
                max_priority=1.0,
                alpha=self.config.per_alpha,
                beta=self.config.per_beta,
                # epsilon=config["per_epsilon"],
                n_step=self.config.n_step,
                gamma=self.config.discount_factor, (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==ape_x.hyperopt_local:[278:290]
==rainbow.hyperparameter_optimization:[124:135]
        )
    except:  # create a new trials object and start searching
        trials = None

    best = fmin(
        fn=objective,  # Objective Function to optimize
        space=search_space,  # Hyperparameter's Search Space
        algo=tpe.suggest,  # Optimization algorithm (representative TPE)
        max_evals=max_trials,  # Number of optimization attempts
        trials=trials,  # Record the results
        # early_stop_fn=no_progress_loss(5, 1), (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==B:[25:38]
==ape_x.hyperopt_local:[30:43]
ch = logging.StreamHandler()
ch.setFormatter(logging.Formatter("%(message)s"))

logger.addHandler(fh)
logger.addHandler(ch)

logging.basicConfig(
    level=logging.DEBUG,
    handlers=[fh, ch],
    format="%(asctime)s %(name)s %(threadName)s %(levelname)s: %(message)s",
)

 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==ape_x.hyperopt_local:[9:20]
==ape_x.hyperparameter_optimization:[8:19]
import numpy as np
import pandas as pd
import gymnasium as gym
from hyperopt import tpe, hp, fmin, space_eval, STATUS_OK, STATUS_FAIL

from agent_configs import ApeXActorConfig, ApeXLearnerConfig
from game_configs.cartpole_config import CartPoleConfig
from learner import ApeXLearner
import utils

SIGTERM = 15 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.custom_gym_envs.custom_gym_envs.envs.connect4:[75:100]
==rl-research.custom_gym_envs.custom_gym_envs.envs.tictactoe:[80:108]
            illegal_move = True
        if action not in self._legal_moves:
            # could return a negative reward
            # raise ValueError(
            #     "Illegal move {} Legal Moves {}".format(action, self._legal_moves)
            # )
            print("Illegal move {} Legal Moves {}".format(action, self._legal_moves))
            illegal_move = True
        if illegal_move:
            observation = self._get_obs()
            info = self._get_info()

            if self.render_mode == "human":
                self._render_frame()

            reward = [0, 0]
            reward[self._current_player] = -1

            return observation, reward, False, False, info
        self._step_count += 1
        # output next player's token first (since that's the one we're inputting to)
        current_player_board = copy.deepcopy(self._grid[0, :, :])
        self._grid[0, :, :] = self._grid[1, :, :]
        self._grid[1, :, :] = current_player_board
        # print(self._grid[:, :, 0])
        # print(self._grid[:, :, 1])
        # print(self._grid[:, :, 2])
        # print("================") (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.custom_gym_envs.custom_gym_envs.envs.checkers:[378:400]
==rl-research.custom_gym_envs.custom_gym_envs.envs.tictactoe:[119:140]
                reward = [-1, 1]
            else:
                reward = [1, -1]
        else:
            reward = [0, 0]
        observation = self._get_obs()
        info = self._get_info()

        if self.render_mode == "human":
            self._render_frame()

        return observation, reward, terminated, truncated, info

    def render(self):
        if self.render_mode == "rgb_array":
            return self._render_frame()

    def _render_frame(self):
        if self.window is None and self.render_mode == "human":
            pygame.init()
            pygame.display.init() (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.custom_gym_envs.custom_gym_envs.envs.checkers:[378:407]
==rl-research.custom_gym_envs.custom_gym_envs.envs.connect4:[117:146]
                reward = [-1, 1]
            else:
                reward = [1, -1]
        else:
            reward = [0, 0]

        observation = self._get_obs()
        info = self._get_info()

        if self.render_mode == "human":
            self._render_frame()

        return observation, reward, terminated, truncated, info

    def render(self):
        if self.render_mode == "rgb_array":
            return self._render_frame()

    def _render_frame(self):
        if self.window is None and self.render_mode == "human":
            pygame.init()
            pygame.display.init()
            self.window = pygame.display.set_mode(self.window_size)
        if self.clock is None and self.render_mode == "human":
            self.clock = pygame.time.Clock()

        canvas = pygame.Surface(self.window_size)
        canvas.fill((255, 255, 255))
        pix_square_size = ( (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.custom_gym_envs.custom_gym_envs.envs.armed_bandits:[45:57]
==rl-research.custom_gym_envs.custom_gym_envs.envs.nonstationary_armed_bandits:[55:67]
        observation = self._get_obs()
        info = self._get_info()
        return observation, reward, False, self.current_step == self.total_steps, info

    def render(self):
        pass

    def _render_frame(self):
        pass

    def close(self):
        pass (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==agent:[30:40]
==pacman:[3505:3515]
        device: torch.device = (
            torch.device("cuda")
            if torch.cuda.is_available()
            # MPS is sometimes useful for M2 instances, but only for large models/matrix multiplications otherwise CPU is faster
            else (
                torch.device("mps")
                if torch.backends.mps.is_available() and torch.backends.mps.is_built()
                else torch.device("cpu")
            )
        ), (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==alphazero_agent:[15:27]
==rl-research.muzero.muzero_agent:[21:33]
gpus = tf.config.list_physical_devices("GPU")
if gpus:
    try:
        # Currently, memory growth needs to be the same across GPUs
        for gpu in gpus:
            tf.config.experimental.set_memory_growth(gpu, True)
        logical_gpus = tf.config.list_logical_devices("GPU")
        print(len(gpus), "Physical GPUs,", len(logical_gpus), "Logical GPUs")
    except RuntimeError as e:
        # Memory growth must be set before GPUs have been initialized
        print(e)
 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.alphazero.alphazero_network:[258:267]
==rl-research.muzero.muzero_network:[198:207]
                input_shape=input_shape,
                filters=filters,
                kernel_sizes=kernel_sizes,
                strides=strides,
                activation=self.config.activation,
                noisy_sigma=config.noisy_sigma,
            )
            current_shape = (
                B, (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.alphazero.alphazero_network:[160:169]
==rl-research.muzero.muzero_network:[50:59]
                input_shape=input_shape,
                filters=filters,
                kernel_sizes=kernel_sizes,
                strides=strides,
                activation=self.config.activation,
                noisy_sigma=config.noisy_sigma,
            )
            current_shape = (
                B, (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.alphazero.alphazero_network:[69:78]
==rl-research.imitation_learning.supervised_network:[34:43]
                input_shape=input_shape,
                filters=filters,
                kernel_sizes=kernel_sizes,
                strides=strides,
                activation=self.config.activation,
                noisy_sigma=config.noisy_sigma,
            )
            current_shape = (
                B, (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.alphazero.alphazero_mcts:[35:46]
==rl-research.muzero.muzero_mcts:[27:38]
    def expanded(self):
        return len(self.children) > 0

    def value(self):
        if self.visits == 0:
            return 0
        return self.value_sum / self.visits

    def add_noise(self, dirichlet_alpha, exploration_fraction):
        actions = list(self.children.keys())
        noise = np.random.dirichlet([dirichlet_alpha] * len(actions)) (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.alphazero.alphazero_agent:[62:72]
==rl-research.imitation_learning.policy_imitation_agent:[43:52]
        )
        if self.config.optimizer == Adam:
            self.optimizer: torch.optim.Optimizer = self.config.optimizer(
                params=self.model.parameters(),
                lr=self.config.learning_rate,
                eps=self.config.adam_epsilon,
                weight_decay=self.config.weight_decay,
            )
        elif self.config.optimizer == SGD: (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==a2c_network:[280:289]
==pacman:[3279:3288]
                input_shape=input_shape,
                filters=filters,
                kernel_sizes=kernel_sizes,
                strides=strides,
                activation=self.config.activation,
                noisy_sigma=config.noisy_sigma,
            )
            current_shape = (
                B, (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==a2c_network:[156:165]
==rainbow.rainbow_network:[49:58]
                input_shape=input_shape,
                filters=filters,
                kernel_sizes=kernel_sizes,
                strides=strides,
                activation=self.config.activation,
                noisy_sigma=config.noisy_sigma,
            )
            current_shape = (
                B, (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==a2c_network:[124:135]
==rl-research.alphazero.alphazero_network:[227:238]
    def reset_noise(self):
        if self.has_conv_layers:
            self.conv_layers.reset_noise()
        if self.has_dense_layers:
            self.dense_layers.reset_noise()
        self.value.reset_noise()


class ActorNetwork(nn.Module):
    def __init__(
        self, (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==a2c_network:[60:69]
==rl-research.alphazero.alphazero_network:[47:56]
                input_shape=input_shape,
                filters=filters,
                kernel_sizes=kernel_sizes,
                strides=strides,
                activation=self.config.activation,
                noisy_sigma=config.noisy_sigma,
            )
            current_shape = (
                B, (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==a2c_agent:[32:42]
==pacman:[1488:1498]
        device: torch.device = (
            torch.device("cuda")
            if torch.cuda.is_available()
            # MPS is sometimes useful for M2 instances, but only for large models/matrix multiplications otherwise CPU is faster
            else (
                torch.device("mps")
                if torch.backends.mps.is_available() and torch.backends.mps.is_built()
                else torch.device("cpu")
            )
        ), (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==game_configs.game_configs.cartpole_config:[8:16]
==game_configs.game_configs.classiccontrol_config:[8:16]
            is_discrete=True,
            is_image=False,
            is_deterministic=True,  # i think it is deterministic (pretty sure if you input the same actions the same thing will happen, it just has a random start state)
            has_legal_moves=False,
            perfect_information=True,
            multi_agent=False,
            num_players=1,
        ) (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==double_dqn_config:[14:29]
==n_step_dqn_config:[15:30]
        self.atom_size: int = 1

        assert not (
            self.game.is_image and len(self.conv_layers) == 0
        ), "Convolutional layers must be defined for image based games"

        # maybe don't use a game config, since if tuning for multiple games this should be the same regardless of the game <- (it is really a hyper parameter if you are tuning for multiple games or a game with unknown bounds)

        # could use a MuZero min-max config and just constantly update the suport size (would this break the model?) <- might mean this is not in the config but just a part of the model

        self.v_min = game_config.min_score
        self.v_max = game_config.max_score

    def _verify_game(self):
        assert self.game.is_discrete, "Rainbow only supports discrete action spaces" (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==categorical_dqn_config:[7:17]
==dqn_config:[7:16]
        self.noisy_sigma: float = 0
        self.deuling: bool = False

        self.soft_update: bool = False
        self.transfer_interval: int = 1
        self.per_alpha: float = 0
        self.per_beta: float = 0
        self.per_epsilon: float = 0
        self.n_step: int = 1 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[2398:2407]
==rl-research.replay_buffers.nfsp_reservoir_buffer:[21:30]
            max_size=max_size,
            batch_size=batch_size,
            compressed_observations=compressed_observations,
        )

    def store(
        self,
        observation,
        info: dict, (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[2440:2448]
==rl-research.replay_buffers.n_step_replay_buffer:[49:58]
            observation,
            info,
            action,
            reward,
            next_observation,
            next_info,
            done,
        )
        # print("store t:", transition) (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[2423:2432]
==rl-research.replay_buffers.n_step_replay_buffer:[66:74]
            observation,
            info,
            action,
            reward,
            next_observation,
            next_info,
            done,
        ) (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[313:324]
==utils.utils.utils:[239:250]
    if key in targets and targets[key] is not None:
        axs[row][col].axhline(
            y=targets[key],
            color="r",
            linestyle="dashed",
            label="Target Score: {}".format(targets[key]),
        )

    axs[row][col].legend()

 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[263:274]
==utils.utils.utils:[289:300]
    if key in targets and targets[key] is not None:
        axs[row][col].axhline(
            y=targets[key],
            color="r",
            linestyle="dashed",
            label="Target Score: {}".format(targets[key]),
        )

    axs[row][col].legend()

 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[3383:3392]
==rl-research.muzero.muzero_network:[268:277]
            )

    def initialize(self, initializer: Callable[[Tensor], None]) -> None:
        if self.has_residual_layers:
            self.residual_layers.initialize(initializer)
        if self.has_conv_layers:
            self.conv_layers.initialize(initializer)
        if self.has_dense_layers:
            self.dense_layers.initialize(initializer) (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rainbow.rainbow_network:[153:162]
==rl-research.muzero.muzero_network:[122:131]
        )

    def initialize(self, initializer: Callable[[Tensor], None]) -> None:
        if self.has_residual_layers:
            self.residual_layers.initialize(initializer)
        if self.has_conv_layers:
            self.conv_layers.initialize(initializer)
        if self.has_dense_layers:
            self.dense_layers.initialize(initializer) (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rainbow.rainbow_agent:[70:78]
==rl-research.imitation_learning.policy_imitation_agent:[44:52]
        if self.config.optimizer == Adam:
            self.optimizer: torch.optim.Optimizer = self.config.optimizer(
                params=self.model.parameters(),
                lr=self.config.learning_rate,
                eps=self.config.adam_epsilon,
                weight_decay=self.config.weight_decay,
            )
        elif self.config.optimizer == SGD: (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[3595:3607]
==rainbow.rainbow_agent:[137:149]
    def predict(self, states, *args, **kwargs) -> torch.Tensor:
        # could change type later
        state_input = self.preprocess(states)
        q_distribution: torch.Tensor = self.model(state_input)
        return q_distribution

    def predict_target(self, states) -> torch.Tensor:
        # could change type later
        state_input = self.preprocess(states)
        q_distribution: torch.Tensor = self.target_model(state_input)
        return q_distribution
 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==B:[8:22]
==ape_x.remote_worker:[6:20]
import logging
import argparse
import torch.distributed
import torch.distributed.rpc as rpc


stop_chan = queue.Queue()


def recv_stop_msg(msg):
    global stop_chan
    stop_chan.put(msg)

 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==ape_x.learner:[460:470]
==classes:[139:149]
            dummy_q.put(0)

        def on_sample_recieved(samples):
            sample = samples.wait()
            if sample == None:
                # no sample recieved, request another sample after 1 second
                logger.info("no sample recieved, waiting 1 second")
                time.sleep(1)
                dummy_q.put(0)
            else: (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==ape_x.actor:[221:229]
==classes:[295:303]
                        batch = Batch(
                            observations=self.rb.observation_buffer,
                            infos=self.rb.info_buffer,
                            actions=self.rb.action_buffer,
                            rewards=self.rb.reward_buffer,
                            next_observations=self.rb.next_observation_buffer,
                            next_infos=self.rb.next_info_buffer,
                            dones=self.rb.done_buffer, (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.custom_gym_envs.custom_gym_envs.envs.grid_world:[106:115]
==rl-research.custom_gym_envs.custom_gym_envs.envs.mississippi_marbles:[439:450]
        if self.window is None and self.render_mode == "human":
            pygame.init()
            pygame.display.init()
            self.window = pygame.display.set_mode((self.window_size, self.window_size))
        if self.clock is None and self.render_mode == "human":
            self.clock = pygame.time.Clock()

        canvas = pygame.Surface((self.window_size, self.window_size))
        canvas.fill((255, 255, 255))

        # First we draw the dice (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.custom_gym_envs.custom_gym_envs.envs.armed_bandits:[15:25]
==rl-research.custom_gym_envs.custom_gym_envs.envs.nonstationary_armed_bandits:[17:26]
    ):
        assert len(means) == len(std_devs)
        self.means = means
        self.std_devs = std_devs
        self.observation_space = spaces.Discrete(1)  # or 0
        self.action_space = spaces.Discrete(len(means))

        self.total_steps = steps
        self.spec.reward_threshold = np.max(means) * self.total_steps
 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==agent:[79:87]
==pacman:[1510:1518]
                copy.deepcopy(env),
                ".",
                name_prefix="{}".format(self.model_name),
            )
        else:
            print(
                "Warning: test_env will not record videos as render_mode is not 'rgb_array'"
            ) (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==agent:[62:72]
==pacman:[1531:1541]
        print("observation_dimensions: ", self.observation_dimensions)
        if isinstance(env.action_space, gym.spaces.Discrete):
            self.num_actions = env.action_space.n
            self.discrete_action_space = True
        else:
            self.num_actions = env.action_space.shape[0]
            self.discrete_action_space = False

        print("num_actions: ", self.num_actions)
 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.alphazero.alphazero_agent:[35:48]
==rl-research.ppo.ppo_agent:[32:45]
        name=datetime.datetime.now().timestamp(),
        device: torch.device = (
            torch.device("cuda")
            if torch.cuda.is_available()
            # MPS is sometimes useful for M2 instances, but only for large models/matrix multiplications otherwise CPU is faster
            # else (
            #     torch.device("mps")
            #     if torch.backends.mps.is_available() and torch.backends.mps.is_built()
            else torch.device("cpu")
            # )
        ),
        from_checkpoint=False,
    ): (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==a2c_network:[229:238]
==rl-research.ppo.ppo_network:[98:107]
    def forward(self, inputs: Tensor):
        if self.has_conv_layers:
            assert inputs.dim() == 4

        x = inputs
        if self.has_conv_layers:
            x = self.conv_layers(x)
        if self.has_dense_layers:
            x = self.dense_layers(x) (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==a2c_network:[112:121]
==rl-research.ppo.ppo_network:[215:224]
    def forward(self, inputs: Tensor):
        if self.has_conv_layers:
            assert inputs.dim() == 4

        x = inputs
        if self.has_conv_layers:
            x = self.conv_layers(x)
        if self.has_dense_layers:
            x = self.dense_layers(x) (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==a2c_network:[27:40]
==rl-research.ppo.ppo_network:[20:32]
        self.critic = CriticNetwork(config, input_shape)
        self.actor = ActorNetwork(config, input_shape, output_size, discrete)

    def initialize(self, initializer: Callable[[Tensor], None]) -> None:
        self.actor.initialize(initializer)
        self.critic.initialize(initializer)

    def forward(self, inputs: Tensor):
        return self.actor(inputs), self.critic(inputs)


class CriticNetwork(nn.Module): (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==a2c_agent:[120:131]
==rl-research.ppo.ppo_agent:[114:125]
        }

    def checkpoint_optimizer_state(self, checkpoint):
        checkpoint["actor_optimizer"] = self.actor_optimizer.state_dict()
        checkpoint["critic_optimizer"] = self.critic_optimizer.state_dict()
        return checkpoint

    def load_optimizer_state(self, checkpoint):
        self.actor_optimizer.load_state_dict(checkpoint["actor_optimizer"])
        self.critic_optimizer.load_state_dict(checkpoint["critic_optimizer"])
 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==game_configs.game_configs.leduc_holdem_config:[6:13]
==game_configs.game_configs.toytext_config:[6:13]
            max_score=10,
            min_score=-10,
            is_discrete=True,
            is_image=False,
            is_deterministic=False,
            has_legal_moves=False,
            perfect_information=False, (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==lib.connect4_config:[6:13]
==lib.tictactoe_config:[6:13]
            max_score=1,
            min_score=-1,
            is_discrete=True,
            is_image=True,
            is_deterministic=True,
            has_legal_moves=True,
        ) (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==categorical_dqn_config:[8:17]
==noisy_dqn_config:[7:15]
        self.deuling: bool = False

        self.soft_update: bool = False
        self.transfer_interval: int = 1
        self.per_alpha: float = 0
        self.per_beta: float = 0
        self.per_epsilon: float = 0
        self.n_step: int = 1
 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==categorical_dqn_config:[7:15]
==n_step_dqn_config:[7:15]
        self.noisy_sigma: float = 0
        self.deuling: bool = False

        self.soft_update: bool = False
        self.transfer_interval: int = 1
        self.per_alpha: float = 0
        self.per_beta: float = 0
        self.per_epsilon: float = 0 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==categorical_dqn_config:[17:30]
==double_dqn_config:[16:29]
        assert not (
            self.game.is_image and len(self.conv_layers) == 0
        ), "Convolutional layers must be defined for image based games"

        # maybe don't use a game config, since if tuning for multiple games this should be the same regardless of the game <- (it is really a hyper parameter if you are tuning for multiple games or a game with unknown bounds)

        # could use a MuZero min-max config and just constantly update the suport size (would this break the model?) <- might mean this is not in the config but just a part of the model

        self.v_min = game_config.min_score
        self.v_max = game_config.max_score

    def _verify_game(self):
        assert self.game.is_discrete, "Rainbow only supports discrete action spaces" (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.muzero.muzero_network:[598:608]
==rl-research.ppo.ppo_network:[197:207]
                in_features=initial_width,
                out_features=output_size,
                sigma=self.config.noisy_sigma,
            )

    def initialize(self, initializer: Callable[[Tensor], None]) -> None:
        if self.has_conv_layers:
            self.conv_layers.initialize(initializer)
        if self.has_dense_layers:
            self.dense_layers.initialize(initializer) (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[2423:2430]
==rl-research.replay_buffers.prioritized_n_step_replay_buffer:[58:65]
            observation,
            info,
            action,
            reward,
            next_observation,
            next_info,
            done, (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[2521:2528]
==rl-research.replay_buffers.n_step_replay_buffer:[49:56]
            observation,
            info,
            action,
            reward,
            next_observation,
            next_info,
            done, (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[2267:2274]
==rl-research.replay_buffers.base_replay_buffer:[183:190]
        return dict(
            observations=self.observation_buffer[indices],
            next_observations=self.next_observation_buffer[indices],
            actions=self.action_buffer[indices],
            rewards=self.reward_buffer[indices],
            dones=self.done_buffer[indices],
            ids=self.id_buffer[indices], (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[2255:2262]
==rl-research.replay_buffers.base_replay_buffer:[195:202]
        return dict(
            observations=self.observation_buffer[indices],
            next_observations=self.next_observation_buffer[indices],
            actions=self.action_buffer[indices],
            rewards=self.reward_buffer[indices],
            dones=self.done_buffer[indices],
            ids=self.id_buffer[indices], (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[1227:1237]
==utils.utils.utils:[1209:1219]
class StoppingCriteria:
    def __init__(self):
        pass

    def should_stop(self, details: dict) -> bool:
        return False


class TimeStoppingCriteria(StoppingCriteria):
    def __init__(self, max_runtime_sec=60 * 10): (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[522:530]
==utils.utils.utils:[453:461]
    sqrt_num_plots = math.ceil(np.sqrt(num_plots))
    fig, axs = plt.subplots(
        sqrt_num_plots,
        sqrt_num_plots,
        figsize=(10 * sqrt_num_plots, 5 * sqrt_num_plots),
        squeeze=False,
    )
 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[477:485]
==utils.utils.utils:[498:506]
    sqrt_num_plots = math.ceil(np.sqrt(num_plots))
    fig, axs = plt.subplots(
        sqrt_num_plots,
        sqrt_num_plots,
        figsize=(10 * sqrt_num_plots, 5 * sqrt_num_plots),
        squeeze=False,
    )
 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[367:375]
==utils.utils.utils:[231:239]
        axs[row][col].plot(
            x,
            best_fit_x * x + best_fit_y,
            color="g",
            label="Best Fit Line",
            linestyle="dotted",
        )
 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[255:263]
==utils.utils.utils:[343:351]
        axs[row][col].plot(
            x,
            best_fit_x * x + best_fit_y,
            color="g",
            label="Best Fit Line",
            linestyle="dotted",
        )
 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==lib.game_config:[9:19]
==pacman:[1313:1323]
    ):
        self.max_score = max_score
        self.min_score = min_score
        self.is_discrete = is_discrete  # can just check the action space type instead of setting manually if the env is passed in (ALSO COULD DO THIS IN THE BASE GAME CONFIG)
        # self.num_actions = num_actions
        # self.observation_space = observation_space
        self.is_image = is_image
        self.is_deterministic = is_deterministic
        # self.num_players = num_players (might not need this idk) <- it would likely be for muzero but could also be for rainbow and stuff when they play multiplayer games (like connect 4)
        self.has_legal_moves = has_legal_moves (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[3401:3415]
==rl-research.muzero.muzero_network:[134:154]
        if self.has_conv_layers:
            assert inputs.dim() == 4

        # (B, *)
        S = inputs
        # INPUT CONV LAYERS???
        # input batch norm
        # relu?

        # (B, C_in, H, W) -> (B, C_out, H, W)
        if self.has_residual_layers:
            S = self.residual_layers(S)

        # (B, C_in, H, W) -> (B, C_out, H, W)
        if self.has_conv_layers:
            S = self.conv_layers(S)

        # (B, *) -> (B, dense_features_in)

        # (B, dense_features_in) -> (B, dense_features_out) (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[3385:3392]
==rl-research.muzero.muzero_network:[402:410]
    def initialize(self, initializer: Callable[[Tensor], None]) -> None:
        if self.has_residual_layers:
            self.residual_layers.initialize(initializer)
        if self.has_conv_layers:
            self.conv_layers.initialize(initializer)
        if self.has_dense_layers:
            self.dense_layers.initialize(initializer)
 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[3266:3275]
==rl-research.muzero.muzero_network:[183:194]
        self.output_size = output_size

        current_shape = input_shape
        B = current_shape[0]

        if self.has_residual_layers:
            assert (
                len(input_shape) == 4
            ), "Input shape should be (B, C, H, W), got {}".format(input_shape) (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rainbow.rainbow_network:[36:45]
==rl-research.muzero.muzero_network:[33:44]
        self.output_size = output_size

        current_shape = input_shape
        B = current_shape[0]

        # INPUTS = CONV + BATCHNORM + maybe RELU? into residual etc

        if self.has_residual_layers:
            assert (
                len(input_shape) == 4
            ), "Input shape should be (B, C, H, W), got {}".format(input_shape) (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[3241:3248]
==rainbow.rainbow_network:[11:18]
class RainbowNetwork(nn.Module):
    def __init__(
        self,
        config: RainbowConfig,
        output_size: int,
        input_shape: Tuple[int],
        *args, (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[3883:3891]
==rainbow.rainbow_agent:[358:367]
                    )
                    done = terminated or truncated
                    # print("State", state)
                    self.replay_buffer.store(
                        state, info, action, reward, next_state, next_info, done
                    )
                    state = next_state
                    info = next_info (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==ape_x.learner:[370:380]
==classes:[113:122]
        self.flag = threading.Event()

        self.replay_thread = threading.Thread(
            target=self._fetch_batches, args=(self.flag,)
        )
        self.replay_thread.daemon = True
        self.replay_thread.start()

        for actor in self.actor_rrefs:
            # no timeout (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==ape_x.hyperopt_local:[33:43]
==ape_x.main_learner:[13:23]
logger.addHandler(fh)
logger.addHandler(ch)

logging.basicConfig(
    level=logging.DEBUG,
    handlers=[fh, ch],
    format="%(asctime)s %(name)s %(threadName)s %(levelname)s: %(message)s",
)

 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.custom_gym_envs.custom_gym_envs.envs.checkers:[392:400]
==rl-research.custom_gym_envs.custom_gym_envs.envs.grid_world:[101:109]
    def render(self):
        if self.render_mode == "rgb_array":
            return self._render_frame()

    def _render_frame(self):
        if self.window is None and self.render_mode == "human":
            pygame.init()
            pygame.display.init() (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.custom_gym_envs.custom_gym_envs.envs.checkers:[107:129]
==rl-research.custom_gym_envs.custom_gym_envs.envs.grid_world:[73:85]
        )
        # self._legal_moves_p2 = np.array(
        #     [
        #         8 * 8 + 2,
        #         8 * 8 + 3,
        #         9 * 8 + 2,
        #         9 * 8 + 3,
        #         10 * 8 + 2,
        #         10 * 8 + 3,
        #         11 * 8 + 3,
        #     ]
        # )

        observation = self._get_obs()
        info = self._get_info()

        if self.render_mode == "human":
            self._render_frame()

        return observation, info

    def step(self, action): (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.custom_gym_envs.custom_gym_envs.envs.checkers:[452:462]
==rl-research.custom_gym_envs.custom_gym_envs.envs.connect4:[165:177]
                    pygame.draw.circle(
                        canvas,
                        (255, 255, 0),
                        (
                            j * pix_square_size + pix_square_size // 2,
                            i * pix_square_size + pix_square_size // 2,
                        ),
                        pix_square_size // 3,
                        width=3,
                    ) (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.custom_gym_envs.custom_gym_envs.envs.checkers:[41:58]
==rl-research.custom_gym_envs.custom_gym_envs.envs.connect4:[28:45]
        assert render_mode is None or render_mode in self.metadata["render_modes"]
        self.render_mode = render_mode

        """
        If human-rendering is used, `self.window` will be a reference
        to the window that we draw to. `self.clock` will be a clock that is used
        to ensure that the environment is rendered at the correct framerate in
        human-mode. They will remain `None` until human-mode is used for the
        first time.
        """
        self.window = None
        self.clock = None

    def _get_obs(self):
        return copy.deepcopy(self._grid)

    def _get_info(self): (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.custom_gym_envs.custom_gym_envs.envs.armed_bandits:[7:15]
==rl-research.custom_gym_envs.custom_gym_envs.envs.nonstationary_armed_bandits:[7:15]
    metadata = {"render_fps": 4}

    def __init__(
        self,
        render_mode=None,
        means=[np.random.uniform(-1, 1) for _ in range(1000)],
        std_devs=[np.random.rand() for _ in range(1000)],
        steps=1000, (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==agent:[292:304]
==pacman:[1727:1738]
        with open(Path(training_step_dir, f"graphs_stats/stats.pkl"), "wb") as f:
            pickle.dump(self.stats, f)
        with open(Path(training_step_dir, f"graphs_stats/targets.pkl"), "wb") as f:
            pickle.dump(self.targets, f)

        # to periodically clear uneeded memory, if it is drastically slowing down training you can comment this out, checkpoint less often, or do less trials
        gc.collect()

        # plot the graphs (and save the graph)
        print(self.stats)
        print(self.targets) (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.alphazero.alphazero_network:[185:193]
==rl-research.muzero.muzero_network:[391:399]
                activation=self.config.activation,
                noisy_sigma=self.config.noisy_sigma,
            )
            current_shape = (
                B,
                self.dense_layers.output_width,
            )
 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.alphazero.alphazero_network:[0:10]
==rl-research.muzero.muzero_network:[0:8]
from typing import Callable, Tuple
from agent_configs.alphazero_config import AlphaZeroConfig
from torch import nn, Tensor
from utils.utils import to_lists

from modules.conv import Conv2dStack
from modules.dense import DenseStack, build_dense
from modules.residual import ResidualStack

 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rainbow.rainbow_network:[171:185]
==rl-research.alphazero.alphazero_network:[117:135]
        if self.has_conv_layers:
            assert inputs.dim() == 4

        # (B, *)
        S = inputs
        # (B, C_in, H, W) -> (B, C_out, H, W)
        if self.has_residual_layers:
            S = self.residual_layers(S)

        # (B, C_in, H, W) -> (B, C_out, H, W)
        if self.has_conv_layers:
            S = self.conv_layers(S)

        # (B, *) -> (B, dense_features_in) (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rainbow.rainbow_network:[155:162]
==rl-research.alphazero.alphazero_network:[105:113]
    def initialize(self, initializer: Callable[[Tensor], None]) -> None:
        if self.has_residual_layers:
            self.residual_layers.initialize(initializer)
        if self.has_conv_layers:
            self.conv_layers.initialize(initializer)
        if self.has_dense_layers:
            self.dense_layers.initialize(initializer) (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==a2c_network:[264:272]
==rl-research.ppo.ppo_network:[125:132]
        *args,
        **kwargs
    ):
        super().__init__(*args, **kwargs)
        self.config = config
        self.has_conv_layers = len(config.actor_conv_layers) > 0
        self.has_dense_layers = len(config.actor_dense_layer_widths) > 0 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==a2c_network:[307:315]
==rl-research.muzero.muzero_network:[245:254]
                activation=self.config.activation,
                noisy_sigma=self.config.noisy_sigma,
            )
            current_shape = (
                B,
                self.dense_layers.output_width,
            )
 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==a2c_network:[183:191]
==rl-research.muzero.muzero_network:[97:106]
                activation=self.config.activation,
                noisy_sigma=self.config.noisy_sigma,
            )
            current_shape = (
                B,
                self.dense_layers.output_width,
            )
 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==a2c_network:[295:304]
==pacman:[3334:3342]
        if len(current_shape) == 4:
            initial_width = current_shape[1] * current_shape[2] * current_shape[3]
        else:
            assert (
                len(current_shape) == 2
            ), "Input shape should be (B, width), got {}".format(current_shape)
            initial_width = current_shape[1]
 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==a2c_network:[171:180]
==rainbow.rainbow_network:[104:112]
            if len(current_shape) == 4:
                initial_width = current_shape[1] * current_shape[2] * current_shape[3]
            else:
                assert (
                    len(current_shape) == 2
                ), "Input shape should be (B, width), got {}".format(current_shape)
                initial_width = current_shape[1]

            # (B, width_in) -> (B, width_out) (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==a2c_network:[211:221]
==rl-research.alphazero.alphazero_network:[301:311]
            in_features=initial_width,
            out_features=output_size,
            sigma=self.config.noisy_sigma,
        )

    def initialize(self, initializer: Callable[[Tensor], None]) -> None:
        if self.has_conv_layers:
            self.conv_layers.initialize(initializer)
        if self.has_dense_layers:
            self.dense_layers.initialize(initializer) (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==a2c_network:[85:93]
==rl-research.alphazero.alphazero_network:[94:102]
                activation=self.config.activation,
                noisy_sigma=self.config.noisy_sigma,
            )
            current_shape = (
                B,
                self.dense_layers.output_width,
            )
 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==a2c_network:[139:146]
==rl-research.alphazero.alphazero_network:[241:249]
        *args,
        **kwargs
    ):
        super().__init__(*args, **kwargs)
        self.config = config
        self.has_conv_layers = len(config.actor_conv_layers) > 0
        self.has_dense_layers = len(config.actor_dense_layer_widths) > 0 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==game_configs.game_configs.blackjack_config:[8:14]
==game_configs.game_configs.toytext_config:[8:14]
            is_discrete=True,
            is_image=False,
            is_deterministic=False,
            has_legal_moves=False,
            perfect_information=False,
            multi_agent=False, (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==game_configs.game_configs.connect4_config:[6:12]
==lib.tictactoe_config:[6:12]
            max_score=1,
            min_score=-1,
            is_discrete=True,
            is_image=True,
            is_deterministic=True,
            has_legal_moves=True, (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==game_configs.game_configs.tictactoe_config:[6:12]
==lib.connect4_config:[6:12]
            max_score=1,
            min_score=-1,
            is_discrete=True,
            is_image=True,
            is_deterministic=True,
            has_legal_moves=True, (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==n_step_dqn_config:[8:15]
==noisy_dqn_config:[7:14]
        self.deuling: bool = False

        self.soft_update: bool = False
        self.transfer_interval: int = 1
        self.per_alpha: float = 0
        self.per_beta: float = 0
        self.per_epsilon: float = 0 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==agent_configs.agent_configs.actor_config:[5:11]
==agent_configs.agent_configs.critic_config:[5:11]
    def __init__(self, config_dict):
        super().__init__(config_dict)
        self.adam_epsilon = self.parse_field("adam_epsilon", 1e-7)
        self.learning_rate = self.parse_field("learning_rate", 0.005)
        self.clipnorm = self.parse_field("clipnorm", None)
        self.optimizer: Optimizer = self.parse_field("optimizer", Adam) (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.muzero.muzero_network:[601:608]
==rl-research.ppo.ppo_network:[89:96]
        )

    def initialize(self, initializer: Callable[[Tensor], None]) -> None:
        if self.has_conv_layers:
            self.conv_layers.initialize(initializer)
        if self.has_dense_layers:
            self.dense_layers.initialize(initializer) (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.muzero.muzero_network:[500:507]
==rl-research.ppo.ppo_network:[200:207]
        )

    def initialize(self, initializer: Callable[[Tensor], None]) -> None:
        if self.has_conv_layers:
            self.conv_layers.initialize(initializer)
        if self.has_dense_layers:
            self.dense_layers.initialize(initializer) (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[2189:2195]
==rl-research.replay_buffers.n_step_replay_buffer:[7:13]
    def __init__(
        self,
        observation_dimensions: tuple,
        observation_dtype: np.dtype,
        max_size: int,
        batch_size: int = 32, (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[2298:2305]
==rl-research.replay_buffers.base_replay_buffer:[132:139]
        )

    def store(
        self,
        observation,
        info: dict,
        action, (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[2204:2211]
==rl-research.replay_buffers.base_replay_buffer:[226:233]
        )

    def store(
        self,
        observation,
        info: dict,
        action, (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[2381:2387]
==rl-research.replay_buffers.base_replay_buffer:[117:123]
    def __init__(
        self,
        observation_dimensions: tuple,
        observation_dtype: np.dtype,
        max_size: int,
        batch_size: int = 32, (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[2283:2289]
==rl-research.replay_buffers.a2c_replay_buffer:[6:12]
    def __init__(
        self,
        observation_dimensions,
        observation_dtype: np.dtype,
        max_size: int,
        gamma: float = 0.99, (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[771:777]
==utils.utils.utils:[730:736]
        augemented_boards[0] = np.rot90(board)
        augmented_policies[0] = np.rot90(policy)
        augemented_boards[1] = np.rot90(np.rot90(board))
        augmented_policies[1] = np.rot90(np.rot90(policy))
        augemented_boards[2] = np.rot90(np.rot90(np.rot90(board)))
        augmented_policies[2] = np.rot90(np.rot90(np.rot90(policy))) (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[754:760]
==utils.utils.utils:[747:753]
        augemented_boards[0] = np.rot90(board)
        augmented_policies[0] = np.rot90(policy)
        augemented_boards[1] = np.rot90(np.rot90(board))
        augmented_policies[1] = np.rot90(np.rot90(policy))
        augemented_boards[2] = np.rot90(np.rot90(np.rot90(board)))
        augmented_policies[2] = np.rot90(np.rot90(np.rot90(policy))) (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[439:446]
==utils.utils.utils:[232:239]
            x,
            best_fit_x * x + best_fit_y,
            color="g",
            label="Best Fit Line",
            linestyle="dotted",
        )
 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[256:263]
==utils.utils.utils:[415:422]
        x,
        best_fit_x * x + best_fit_y,
        color="g",
        label="Best Fit Line",
        linestyle="dotted",
    )
 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[3252:3259]
==rl-research.muzero.muzero_network:[322:329]
        self.has_residual_layers = len(config.residual_layers) > 0
        self.has_conv_layers = len(config.conv_layers) > 0
        self.has_dense_layers = len(config.dense_layer_widths) > 0
        assert (
            self.has_conv_layers or self.has_dense_layers or self.has_residual_layers
        ), "At least one of the layers should be present."
 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[2876:2884]
==residual:[137:145]
    def initialize(self, initializer: Callable[[Tensor], None]) -> None:
        def initialize_if_conv(m: nn.Module):
            if isinstance(m, nn.Conv2d):
                initializer(m.weight)

        self.apply(initialize_if_conv)

    def forward(self, inputs): (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==conv:[103:111]
==pacman:[3222:3230]
    def initialize(self, initializer: Callable[[Tensor], None]) -> None:
        def initialize_if_conv(m: nn.Module):
            if isinstance(m, nn.Conv2d):
                initializer(m.weight)

        self.apply(initialize_if_conv)

    def forward(self, inputs): (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rainbow.rainbow_network:[238:244]
==rl-research.imitation_learning.supervised_network:[133:139]
        if self.has_residual_layers:
            self.residual_layers.reset_noise()
        if self.has_conv_layers:
            self.conv_layers.reset_noise()
        if self.has_dense_layers:
            self.dense_layers.reset_noise() (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==NFSP.nfsp_agent_clean:[359:365]
==pacman:[1687:1695]
    def save_checkpoint(
        self,
        training_step,
        frames_seen,
        time_taken,
    ):
        # test model
 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==ape_x.learner:[324:331]
==classes:[184:191]
    def store_weights(self):
        # TODO - async
        logger.info("storing weights")
        attempts = 5
        t = time.time()
        for attempt in range(attempts):
            try: (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==ape_x.learner:[471:479]
==classes:[152:160]
                dummy_q.put(0)

        while not flag.is_set():
            try:
                dummy_q.get(timeout=5)
            except queue.Empty:
                continue
 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==ape_x.hyperopt_local:[0:6]
==ape_x.hyperparameter_optimization:[0:6]
import os
import pickle
import subprocess
from subprocess import Popen
from pathlib import Path
import time (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==ape_x.actor:[264:271]
==classes:[328:336]
        logger.info("fetching initial network params from learner...")
        has_weights = self.update_params()
        while not has_weights:
            print("no weights, trying again")
            has_weights = self.update_params()
            time.sleep(2)
 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.custom_gym_envs.custom_gym_envs.envs.grid_world:[75:85]
==rl-research.custom_gym_envs.custom_gym_envs.envs.mississippi_marbles:[220:229]
        observation = self._get_obs()
        info = self._get_info()

        if self.render_mode == "human":
            self._render_frame()

        return observation, info

    def step(self, action): (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.custom_gym_envs.custom_gym_envs.envs.checkers:[489:495]
==rl-research.custom_gym_envs.custom_gym_envs.envs.connect4:[178:184]
            pygame.draw.line(
                canvas,
                (0, 0, 0),
                (0, i * pix_square_size),
                (self.window_size[0], i * pix_square_size),
            ) (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.custom_gym_envs.custom_gym_envs.envs.checkers:[120:129]
==rl-research.custom_gym_envs.custom_gym_envs.envs.connect4:[61:70]
        observation = self._get_obs()
        info = self._get_info()

        if self.render_mode == "human":
            self._render_frame()

        return observation, info

    def step(self, action): (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rainbow.rainbow_network:[22:29]
==rl-research.alphazero.alphazero_network:[25:32]
        self.has_residual_layers = len(config.residual_layers) > 0
        self.has_conv_layers = len(config.conv_layers) > 0
        self.has_dense_layers = len(config.dense_layer_widths) > 0
        assert (
            self.has_conv_layers or self.has_dense_layers or self.has_residual_layers
        ), "At least one of the layers should be present."
 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.alphazero.alphazero_agent:[73:80]
==rl-research.imitation_learning.policy_imitation_agent:[52:59]
            self.optimizer: torch.optim.Optimizer = self.config.optimizer(
                params=self.model.parameters(),
                lr=self.config.learning_rate,
                momentum=self.config.momentum,
                weight_decay=self.config.weight_decay,
            )
 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==a2c_network:[156:162]
==rl-research.muzero.muzero_network:[261:267]
                input_shape=input_shape,
                filters=filters,
                kernel_sizes=kernel_sizes,
                strides=strides,
                activation=self.config.activation,
                noisy_sigma=config.noisy_sigma, (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==a2c_network:[60:66]
==rl-research.muzero.muzero_network:[115:121]
            input_shape=input_shape,
            filters=filters,
            kernel_sizes=kernel_sizes,  # 3
            strides=strides,  # 1
            activation=self.config.activation,
            noisy_sigma=config.noisy_sigma, (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==a2c_network:[43:49]
==rainbow.rainbow_network:[16:22]
        input_shape: Tuple[int],
        *args,
        **kwargs
    ):
        super().__init__(*args, **kwargs)
        self.config = config (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==a2c_network:[262:322]
==rl-research.alphazero.alphazero_network:[239:300]
        input_shape: Tuple[int],
        output_size: int,
        *args,
        **kwargs
    ):
        super().__init__(*args, **kwargs)
        self.config = config
        self.has_conv_layers = len(config.actor_conv_layers) > 0
        self.has_dense_layers = len(config.actor_dense_layer_widths) > 0

        current_shape = input_shape
        B = current_shape[0]
        if self.has_conv_layers:
            # WITH BATCHNORM FOR EVERY CONV LAYER
            assert len(input_shape) == 4
            filters, kernel_sizes, strides = to_lists(config.actor_conv_layers)

            # (B, C_in, H, W) -> (B, C_out H, W)
            self.conv_layers = Conv2dStack(
                input_shape=input_shape,
                filters=filters,
                kernel_sizes=kernel_sizes,
                strides=strides,
                activation=self.config.activation,
                noisy_sigma=config.noisy_sigma,
            )
            current_shape = (
                B,
                self.conv_layers.output_channels,
                current_shape[2],
                current_shape[3],
            )

        if self.has_dense_layers:
            if len(current_shape) == 4:
                initial_width = current_shape[1] * current_shape[2] * current_shape[3]
            else:
                assert (
                    len(current_shape) == 2
                ), "Input shape should be (B, width), got {}".format(current_shape)
                initial_width = current_shape[1]

            # (B, width_in) -> (B, width_out)
            self.dense_layers = DenseStack(
                initial_width=initial_width,
                widths=self.config.actor_dense_layer_widths,
                activation=self.config.activation,
                noisy_sigma=self.config.noisy_sigma,
            )

            current_shape = (
                B,
                self.dense_layers.output_width,
            )

        if len(current_shape) == 4:
            initial_width = current_shape[1] * current_shape[2] * current_shape[3]
        else:
            assert len(current_shape) == 2
            initial_width = current_shape[1]
 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==a2c_network:[214:221]
==rl-research.alphazero.alphazero_network:[203:210]
        )

    def initialize(self, initializer: Callable[[Tensor], None]) -> None:
        if self.has_conv_layers:
            self.conv_layers.initialize(initializer)
        if self.has_dense_layers:
            self.dense_layers.initialize(initializer) (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==a2c_network:[103:110]
==rl-research.alphazero.alphazero_network:[304:311]
        )

    def initialize(self, initializer: Callable[[Tensor], None]) -> None:
        if self.has_conv_layers:
            self.conv_layers.initialize(initializer)
        if self.has_dense_layers:
            self.dense_layers.initialize(initializer) (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.replay_buffers.base_replay_buffer:[211:216]
==rl-research.replay_buffers.prioritized_n_step_replay_buffer:[8:13]
    def __init__(
        self,
        observation_dimensions,
        observation_dtype: np.dtype,
        max_size: int, (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==game_configs.game_configs.blackjack_config:[8:13]
==game_configs.game_configs.leduc_holdem_config:[8:13]
            is_discrete=True,
            is_image=False,
            is_deterministic=False,
            has_legal_moves=False,
            perfect_information=False, (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==agent_configs.agent_configs.a2c_config:[47:52]
==agent_configs.agent_configs.ppo_config:[57:63]
        self.noisy_sigma = self.parse_field("noisy_sigma", 0.0)
        self.critic_conv_layers = self.parse_field("conv_layers", [])
        self.actor_conv_layers = self.parse_field("conv_layers", [])
        self.critic_dense_layer_widths = self.parse_field("critic_dense_layers", [])
        self.actor_dense_layer_widths = self.parse_field("actor_dense_layers", [])
 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.muzero.muzero_network:[627:632]
==rl-research.ppo.ppo_network:[110:115]
    def reset_noise(self):
        if self.has_conv_layers:
            self.conv_layers.reset_noise()
        if self.has_dense_layers:
            self.dense_layers.reset_noise() (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.muzero.muzero_network:[524:529]
==rl-research.ppo.ppo_network:[232:237]
    def reset_noise(self):
        if self.has_conv_layers:
            self.conv_layers.reset_noise()
        if self.has_dense_layers:
            self.dense_layers.reset_noise() (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.muzero.muzero_network:[490:496]
==rl-research.ppo.ppo_network:[61:68]
            if len(current_shape) == 4:
                initial_width = current_shape[1] * current_shape[2] * current_shape[3]
            else:
                assert len(current_shape) == 2
                initial_width = current_shape[1]

            # (B, width_in) -> (B, width_out) (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.muzero.muzero_network:[381:388]
==rl-research.ppo.ppo_network:[177:183]
        if len(current_shape) == 4:
            initial_width = current_shape[1] * current_shape[2] * current_shape[3]
        else:
            assert len(current_shape) == 2
            initial_width = current_shape[1]
 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.muzero.muzero_network:[235:242]
==rl-research.ppo.ppo_network:[79:85]
            if len(current_shape) == 4:
                initial_width = current_shape[1] * current_shape[2] * current_shape[3]
            else:
                assert len(current_shape) == 2
                initial_width = current_shape[1]

            # (B, width_in) -> (B, width_out) (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.imitation_learning.supervised_network:[91:97]
==rl-research.muzero.muzero_network:[87:94]
        if len(current_shape) == 4:
            initial_width = current_shape[1] * current_shape[2] * current_shape[3]
        else:
            assert len(current_shape) == 2
            initial_width = current_shape[1]
 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[2300:2305]
==rl-research.replay_buffers.prioritized_n_step_replay_buffer:[44:49]
    def store(
        self,
        observation,
        info: dict,
        action, (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[2670:2676]
==rl-research.replay_buffers.prioritized_n_step_replay_buffer:[12:18]
        max_size: int,
        batch_size: int = 32,
        max_priority: float = 1.0,
        alpha: float = 0.6,
        beta: float = 0.4,
        # epsilon=0.01, (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[2475:2481]
==rl-research.replay_buffers.prioritized_n_step_replay_buffer:[207:213]
        max_size: int,
        batch_size: int = 32,
        max_priority: float = 1.0,
        alpha: float = 0.6,
        beta: float = 0.4,
        # epsilon=0.01, (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[2283:2288]
==rl-research.replay_buffers.nfsp_reservoir_buffer:[8:13]
    def __init__(
        self,
        observation_dimensions,
        observation_dtype: np.dtype,
        max_size: int, (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[2507:2512]
==rl-research.replay_buffers.base_replay_buffer:[228:233]
    def store(
        self,
        observation,
        info: dict,
        action, (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[2471:2476]
==rl-research.replay_buffers.a2c_replay_buffer:[6:11]
    def __init__(
        self,
        observation_dimensions,
        observation_dtype: np.dtype,
        max_size: int, (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[385:418]
==utils.utils.utils:[287:294]
    axs[row][col].set_xlim(1, len(values))
    # axs[row][col].set_ylim(0.01, 10)
    # axs[row][col].set_ylim(
    #     -(10 ** math.ceil(math.log10(abs(min_exploitability)))),
    #     10 ** math.ceil(math.log10(max_exploitability)),
    # )

    # axs[row][col].set_yticks(
    #     [
    #         -(10**i)
    #         for i in range(
    #             math.ceil(math.log10(abs(min_exploitability))),
    #             math.floor(math.log10(abs(min_exploitability))) - 1,
    #             -1,
    #         )
    #         if -(10**i) < min_exploitability
    #     ]
    #     + [0]
    #     + [
    #         10**i
    #         for i in range(
    #             math.ceil(math.log10(max_exploitability)),
    #             math.floor(math.log10(max_exploitability)) + 1,
    #         )
    #         if 10**i > max_exploitability
    #     ]
    # )

    if key in targets and targets[key] is not None:
        axs[row][col].axhline(
            y=targets[key],
            color="r",
            linestyle="dashed", (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[311:318]
==utils.utils.utils:[361:394]
    axs[row][col].set_xlim(1, len(values))
    # axs[row][col].set_ylim(0.01, 10)
    # axs[row][col].set_ylim(
    #     -(10 ** math.ceil(math.log10(abs(min_exploitability)))),
    #     10 ** math.ceil(math.log10(max_exploitability)),
    # )

    # axs[row][col].set_yticks(
    #     [
    #         -(10**i)
    #         for i in range(
    #             math.ceil(math.log10(abs(min_exploitability))),
    #             math.floor(math.log10(abs(min_exploitability))) - 1,
    #             -1,
    #         )
    #         if -(10**i) < min_exploitability
    #     ]
    #     + [0]
    #     + [
    #         10**i
    #         for i in range(
    #             math.ceil(math.log10(max_exploitability)),
    #             math.floor(math.log10(max_exploitability)) + 1,
    #         )
    #         if 10**i > max_exploitability
    #     ]
    # )

    if key in targets and targets[key] is not None:
        axs[row][col].axhline(
            y=targets[key],
            color="r",
            linestyle="dashed", (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[413:418]
==utils.utils.utils:[239:244]
    if key in targets and targets[key] is not None:
        axs[row][col].axhline(
            y=targets[key],
            color="r",
            linestyle="dashed", (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[263:268]
==utils.utils.utils:[389:394]
    if key in targets and targets[key] is not None:
        axs[row][col].axhline(
            y=targets[key],
            color="r",
            linestyle="dashed", (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==agent_configs.agent_configs.base_config:[44:49]
==pacman:[1394:1399]
    @classmethod
    def load(cls, filepath: str):
        with open(filepath, "r") as f:
            o = yaml.load(f, yaml.Loader)
            print(o) (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==agent_configs.agent_configs.base_config:[61:66]
==pacman:[1377:1382]
    @classmethod
    def load(cls, filepath: str):
        with open(filepath, "r") as f:
            o = yaml.load(f, yaml.Loader)
            print(o) (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[3300:3325]
==rl-research.muzero.muzero_network:[219:244]
            self.conv_layers = Conv2dStack(
                input_shape=input_shape,
                filters=filters,
                kernel_sizes=kernel_sizes,
                strides=strides,
                activation=self.config.activation,
                noisy_sigma=config.noisy_sigma,
            )
            current_shape = (
                B,
                self.conv_layers.output_channels,
                current_shape[2],
                current_shape[3],
            )

        if self.has_dense_layers:
            if len(current_shape) == 4:
                initial_width = current_shape[1] * current_shape[2] * current_shape[3]
            else:
                assert len(current_shape) == 2
                initial_width = current_shape[1]

            # (B, width_in) -> (B, width_out)
            self.dense_layers = DenseStack(
                initial_width=initial_width, (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[2839:2847]
==residual:[32:40]
        self.noisy = noisy_sigma != 0
        if self.noisy:
            print("warning: Noisy convolutions not implemented yet")
            # raise NotImplementedError("")

        current_input_channels = input_shape[1]
        for i in range(len(filters)):
 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==conv:[66:74]
==pacman:[3117:3125]
        self.noisy = noisy_sigma != 0
        if self.noisy:
            print("warning: Noisy convolutions not implemented yet")
            # raise NotImplementedError("")

        current_input_channels = input_shape[1]

        for i in range(len(filters)): (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==NFSP.nfsp_agent_clean:[545:551]
==pacman:[1670:1677]
        with open(Path(training_step_dir, f"graphs_stats/stats.pkl"), "rb") as f:
            self.stats = pickle.load(f)
        with open(Path(training_step_dir, f"graphs_stats/targets.pkl"), "rb") as f:
            self.targets = pickle.load(f)

        self.start_training_step = training_step
 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==ape_x.learner:[480:487]
==classes:[161:168]
            try:
                self.replay_rref.rpc_async(10).sample(False).then(on_sample_recieved)
            except Exception as e:
                logger.exception(f"error getting batch: {e}")

        logger.info("replay thread exited")
 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==ape_x.hyperopt_local:[87:92]
==ape_x.hyperparameter_optimization:[108:113]
    print("running cmd: ", cmd)
    out = subprocess.run(cmd.split(" "), capture_output=True, text=True)
    logger.debug(f"write_configs stdout: {out.stdout}")
    logger.debug(f"write_configs stderr: {out.stderr}")
    try: (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==ape_x.hyperopt_local:[77:85]
==ape_x.hyperparameter_optimization:[88:96]
    actor_config = ApeXActorConfig(conf, game_config=CartPoleConfig())
    actor_config.dump(actor_config_path)

    conf["distributed_actor_config_file"] = str(actor_config_path.absolute())

    learner_config = ApeXLearnerConfig(conf, game_config=CartPoleConfig())
    learner_config.dump(learner_config_path)
 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.custom_gym_envs.custom_gym_envs.envs.leduc_holdem:[135:140]
==rl-research.custom_gym_envs.custom_gym_envs.envs.mississippi_marbles:[0:7]
import gymnasium as gym
from gymnasium import spaces
import numpy as np
import pygame
import copy (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.custom_gym_envs.custom_gym_envs.envs.connect4:[214:221]
==rl-research.custom_gym_envs.custom_gym_envs.envs.tictactoe:[220:227]
                if self._grid[1, i, j] == 1:
                    if self._check_win(i, j):
                        return True
        return False

    def _check_win(self, i, j):
        # Check row (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.custom_gym_envs.custom_gym_envs.envs.connect4:[28:42]
==rl-research.custom_gym_envs.custom_gym_envs.envs.mississippi_marbles:[164:178]
        assert render_mode is None or render_mode in self.metadata["render_modes"]
        self.render_mode = render_mode

        """
        If human-rendering is used, `self.window` will be a reference
        to the window that we draw to. `self.clock` will be a clock that is used
        to ensure that the environment is rendered at the correct framerate in
        human-mode. They will remain `None` until human-mode is used for the
        first time.
        """
        self.window = None
        self.clock = None

    def _get_obs(self): (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.custom_gym_envs.custom_gym_envs.envs.checkers:[41:55]
==rl-research.custom_gym_envs.custom_gym_envs.envs.grid_world:[38:52]
        assert render_mode is None or render_mode in self.metadata["render_modes"]
        self.render_mode = render_mode

        """
        If human-rendering is used, `self.window` will be a reference
        to the window that we draw to. `self.clock` will be a clock that is used
        to ensure that the environment is rendered at the correct framerate in
        human-mode. They will remain `None` until human-mode is used for the
        first time.
        """
        self.window = None
        self.clock = None

    def _get_obs(self): (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.custom_gym_envs.custom_gym_envs.envs.checkers:[1:8]
==rl-research.custom_gym_envs.custom_gym_envs.envs.connect4:[0:7]
import gymnasium as gym
from gymnasium import spaces
import numpy as np
import pygame
import copy

 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==NFSP.nfsp_agent_clean:[418:426]
==agent:[292:301]
        with open(Path(training_step_dir, f"graphs_stats/stats.pkl"), "wb") as f:
            pickle.dump(self.stats, f)
        with open(Path(training_step_dir, f"graphs_stats/targets.pkl"), "wb") as f:
            pickle.dump(self.targets, f)

        # to periodically clear uneeded memory, if it is drastically slowing down training you can comment this out, checkpoint less often, or do less trials
        gc.collect()

        # plot the graphs (and save the graph) (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.alphazero.alphazero_network:[68:87]
==rl-research.muzero.muzero_network:[554:573]
            self.conv_layers = Conv2dStack(
                input_shape=input_shape,
                filters=filters,
                kernel_sizes=kernel_sizes,
                strides=strides,
                activation=self.config.activation,
                noisy_sigma=config.noisy_sigma,
            )
            current_shape = (
                B,
                self.conv_layers.output_channels,
                current_shape[2],
                current_shape[3],
            )

        if self.has_dense_layers:
            if len(current_shape) == 4:
                initial_width = current_shape[1] * current_shape[2] * current_shape[3]
            else: (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.alphazero.alphazero_network:[68:93]
==rl-research.muzero.muzero_network:[71:96]
            self.conv_layers = Conv2dStack(
                input_shape=input_shape,
                filters=filters,
                kernel_sizes=kernel_sizes,
                strides=strides,
                activation=self.config.activation,
                noisy_sigma=config.noisy_sigma,
            )
            current_shape = (
                B,
                self.conv_layers.output_channels,
                current_shape[2],
                current_shape[3],
            )

        if self.has_dense_layers:
            if len(current_shape) == 4:
                initial_width = current_shape[1] * current_shape[2] * current_shape[3]
            else:
                assert len(current_shape) == 2
                initial_width = current_shape[1]

            # (B, width_in) -> (B, width_out)
            self.dense_layers = DenseStack(
                initial_width=initial_width, (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==pacman:[3316:3323]
==rl-research.alphazero.alphazero_network:[294:300]
            if len(current_shape) == 4:
                initial_width = current_shape[1] * current_shape[2] * current_shape[3]
            else:
                assert len(current_shape) == 2
                initial_width = current_shape[1]

            # (B, width_in) -> (B, width_out) (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rainbow.rainbow_network:[70:89]
==rl-research.alphazero.alphazero_network:[257:276]
            self.conv_layers = Conv2dStack(
                input_shape=input_shape,
                filters=filters,
                kernel_sizes=kernel_sizes,
                strides=strides,
                activation=self.config.activation,
                noisy_sigma=config.noisy_sigma,
            )
            current_shape = (
                B,
                self.conv_layers.output_channels,
                current_shape[2],
                current_shape[3],
            )

        if self.has_dense_layers:
            if len(current_shape) == 4:
                initial_width = current_shape[1] * current_shape[2] * current_shape[3]
            else: (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rainbow.rainbow_network:[70:95]
==rl-research.alphazero.alphazero_network:[159:184]
            self.conv_layers = Conv2dStack(
                input_shape=input_shape,
                filters=filters,
                kernel_sizes=kernel_sizes,
                strides=strides,
                activation=self.config.activation,
                noisy_sigma=config.noisy_sigma,
            )
            current_shape = (
                B,
                self.conv_layers.output_channels,
                current_shape[2],
                current_shape[3],
            )

        if self.has_dense_layers:
            if len(current_shape) == 4:
                initial_width = current_shape[1] * current_shape[2] * current_shape[3]
            else:
                assert len(current_shape) == 2
                initial_width = current_shape[1]

            # (B, width_in) -> (B, width_out)
            self.dense_layers = DenseStack(
                initial_width=initial_width, (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.alphazero.alphazero_mcts:[8:14]
==rl-research.muzero.muzero_mcts:[8:13]
        self.visits = 0
        self.to_play = -1
        # print("Prior Policy", prior_policy)
        self.prior_policy = prior_policy
        self.value_sum = 0
        self.children = {} (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.alphazero.alphazero_mcts:[0:7]
==rl-research.muzero.muzero_mcts:[0:7]
from copy import deepcopy
from math import log, sqrt, inf
import copy
import numpy as np


class Node: (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==rl-research.alphazero.alphazero_agent:[222:228]
==rl-research.imitation_learning.policy_imitation_agent:[88:95]
        self.optimizer.zero_grad()
        loss.backward()
        if self.config.clipnorm > 0:
            clip_grad_norm_(self.model.parameters(), self.config.clipnorm)

        self.optimizer.step() (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==a2c_network:[5:12]
==rl-research.ppo.ppo_network:[2:10]
from torch import Tensor
from utils.utils import to_lists

from modules.conv import Conv2dStack
from modules.dense import DenseStack, build_dense
import torch.nn as nn

 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==a2c_network:[155:182]
==rl-research.imitation_learning.supervised_network:[55:82]
            self.conv_layers = Conv2dStack(
                input_shape=input_shape,
                filters=filters,
                kernel_sizes=kernel_sizes,
                strides=strides,
                activation=self.config.activation,
                noisy_sigma=config.noisy_sigma,
            )
            current_shape = (
                B,
                self.conv_layers.output_channels,
                current_shape[2],
                current_shape[3],
            )

        if self.has_dense_layers:
            if len(current_shape) == 4:
                initial_width = current_shape[1] * current_shape[2] * current_shape[3]
            else:
                assert (
                    len(current_shape) == 2
                ), "Input shape should be (B, width), got {}".format(current_shape)
                initial_width = current_shape[1]

            # (B, width_in) -> (B, width_out)
            self.dense_layers = DenseStack(
                initial_width=initial_width, (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==a2c_network:[59:78]
==rl-research.imitation_learning.supervised_network:[55:74]
            self.conv_layers = Conv2dStack(
                input_shape=input_shape,
                filters=filters,
                kernel_sizes=kernel_sizes,
                strides=strides,
                activation=self.config.activation,
                noisy_sigma=config.noisy_sigma,
            )
            current_shape = (
                B,
                self.conv_layers.output_channels,
                current_shape[2],
                current_shape[3],
            )

        if self.has_dense_layers:
            if len(current_shape) == 4:
                initial_width = current_shape[1] * current_shape[2] * current_shape[3]
            else: (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==a2c_network:[315:322]
==rainbow.rainbow_network:[86:93]
        if len(current_shape) == 4:
            initial_width = current_shape[1] * current_shape[2] * current_shape[3]
        else:
            assert len(current_shape) == 2
            initial_width = current_shape[1]

 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==a2c_network:[246:251]
==rl-research.alphazero.alphazero_network:[227:232]
    def reset_noise(self):
        if self.has_conv_layers:
            self.conv_layers.reset_noise()
        if self.has_dense_layers:
            self.dense_layers.reset_noise() (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==a2c_network:[124:129]
==rl-research.alphazero.alphazero_network:[330:335]
    def reset_noise(self):
        if self.has_conv_layers:
            self.conv_layers.reset_noise()
        if self.has_dense_layers:
            self.dense_layers.reset_noise() (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==a2c_network:[322:327]
==rl-research.alphazero.alphazero_network:[205:210]
    def initialize(self, initializer: Callable[[Tensor], None]) -> None:
        if self.has_conv_layers:
            self.conv_layers.initialize(initializer)
        if self.has_dense_layers:
            self.dense_layers.initialize(initializer) (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==a2c_network:[191:197]
==rl-research.alphazero.alphazero_network:[175:182]
        if len(current_shape) == 4:
            initial_width = current_shape[1] * current_shape[2] * current_shape[3]
        else:
            assert len(current_shape) == 2
            initial_width = current_shape[1]
 (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==a2c_network:[93:99]
==rl-research.alphazero.alphazero_network:[84:91]
            if len(current_shape) == 4:
                initial_width = current_shape[1] * current_shape[2] * current_shape[3]
            else:
                assert len(current_shape) == 2
                initial_width = current_shape[1]

            # (B, width_in) -> (B, width_out) (duplicate-code)
vectorhash/vectorhash_functions.py:1:0: R0801: Similar lines in 2 files
==a2c_network:[75:82]
==rl-research.alphazero.alphazero_network:[193:199]
            if len(current_shape) == 4:
                initial_width = current_shape[1] * current_shape[2] * current_shape[3]
            else:
                assert len(current_shape) == 2
                initial_width = current_shape[1]

            # (B, width_in) -> (B, width_out) (duplicate-code)

------------------------------------------------------------------
Your code has been rated at 4.09/10 (previous run: 4.09/10, +0.00)

